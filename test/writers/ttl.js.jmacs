/* eslint-env mocha */
/* eslint indent: 1 */
const assert = require('assert');
const eq = assert.strictEqual;
const deq = assert.deepEqual;

const graphy = require('graphy');

const ST_PREFIXES = /* syntax: turtle */ `
	@prefix : <> .
	@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
`;

const write = (h_triples, st_verify) => new Promise((fk_test) => {
	let k_set_expected = graphy.set();

	graphy.ttl.parser({input:ST_PREFIXES+st_verify})
		.pipe(k_set_expected)
		.on('finish', () => {
			let k_set_actual = graphy.set(null, {debug:true});

			let k_writer = graphy.ttl.writer({
				prefixes: {
					'': '',
				},
				indent: '    ',
				trailling: true,
			});

			// k_writer.pipe(process.stdout);

			k_writer
				.pipe(graphy.ttl.parser())
				.pipe(k_set_actual)
				.on('finish', () => {
					eq(k_set_actual.canonicalize(), k_set_expected.canonicalize());
					fk_test();
				});

			k_writer.add(h_triples);
			k_writer.end();
		});
});

const comment = () => graphy.comment({
	width: 100,
	border: {
		char: '*',
		top: 1,
		bottom: 1,
	},
	indent: '    ',
});

@> pairs(s_group='a', n_recursions=0)
	@*{
		let i_hi = 4;
		if(n_recursions >= 0) i_hi = 6;
		for(let i_p=0; i_p<i_hi; i_p++) {
			let s_comment = `i_p: ${i_p}, `;

			let s_terminal;
			// first object; string only
			if(!i_p) {
				s_terminal = `'>o${s_group}0'`;
			}
			else if(i_p < 4) {
				let a_insides = [];
				for(let i_inside=0; i_inside<i_p; i_inside++) {
					a_insides.push(`'>o${s_group}${i_inside}'`);
				}
				s_terminal = `[${a_insides.join(', ')}]`;
			}
			else if(i_p < 5) {
				s_comment += `/${String.fromCodePoint(s_group.codePointAt(0)+1)}, `;
				s_terminal = `{
					${pairs(String.fromCodePoint(s_group.codePointAt(0)+1), n_recursions-1)}
				}`;
			}
			else {
				s_terminal = `[
					'>on0',
					['>on1'],
					['>on2', '>on3'],
					['>on4', '>on5', '>on6'],
					{
						${pairs(String.fromCodePoint(s_group.codePointAt(0)+2), n_recursions-1)}
					}
				]`;
			}
			yield /* syntax: js */ `
				[comment()]: '${s_comment}',
				[comment()]: 'following comment',
				'>p${s_group}${i_p}': ${s_terminal},
			`.replace(/^\s+/, '');
		}
	}
@;

let h_tests = {
	basic: {
		'absolute IRIs': {
			write: {
				[comment()]: 'start at the top',
				'>s0': {
					@{pairs('a', 1)}
				},
			},
			expect: `
				<a> <b> <c> .
			`,
		},

		'prefixed names': {
			write: {
				':a': {
					':b': ':c',
				},
			},
			expect: `
				<a> <b> <c> .
			`,
		},

		'coercions': (() => {
			let dt_now = new Date();
			return {
				write: {
					':coerce': {
						':integer': 42,
						':decimal': 4.2,
						':dateTime': dt_now,
					},
				},
				expect: `
					:coerce :integer 42 ;
						:decimal 4.2 ;
						:dateTime "${dt_now.toISOString()}"^^xsd:dateTime ;
					.
				`,
			};
		})(),
	},
};

for(let s_describe in h_tests) {
	let h_cases = h_tests[s_describe];
	describe(s_describe, () => {
		for(let s_it in h_cases) {
			let g_test = h_cases[s_it];
			it(s_it, async() => await write(g_test.write, g_test.expect));
		}
	});
}
