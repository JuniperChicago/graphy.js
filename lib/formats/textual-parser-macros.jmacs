/* eslint-disable */

@ // import parser macros
@include 'general-parser-macros.jmacs'


@ // possible mode types are:
@ // TTL: Turtle
@ // TRIG: TriG
@ // NT: N-Triples
@ // NQ: N-Quads
@ // T: Turtle or TriG
@ // N: N-Triples or N-Quads

@ // constants for all modes
@macro constants()
	@ // all modes need to unescape characters inside of string literals and IRIs
	const R_ESCAPES = /(\\[\\])|\\([^tbnrfu\\])/g;

	// const R_UNICODE_8 = /\\U(?:0000([0-9A-Fa-f]{4})|([0-9A-Fa-f]{8}))/g;
	// const R_UNICODE_ANY = /\\u([0-9A-Fa-f]{4})|\\U([0-9A-Fa-f]{8})/g;

	// const F_UNICODE_REPLACE = (s_, s_4, s_8) => {
	// 	if(s_4) return String.fromCharCode(parseInt(s_4, 16));

	// 	// produce utf16 be surrogate pair
	// 	let x_cp = parseInt(s_8, 16) - 0x10000;
	// 	return String.fromCharCode(0xD800 + (x_cp >> 10), 0xDC00 + (x_cp & 0x3FF));
	// };

	const R_UNICODE_8 = /\\U([0-9A-Fa-f]{8})/g;
	const R_UNICODE_ANY = /\\U([0-9A-Fa-f]{8})|\\u([0-9A-Fa-f]{4})/g;

	const F_UNICODE_REPLACE = (s_, s_8, s_4) => String.fromCodePoint(parseInt(s_8 || s_4, 16));

	// queue data events instead of emitting them
	const F_QUEUE_DATA = function(h_data) {
		@if N
			this.queue_event.push(h_data);
		@else
			this.queue_event.push({
				event: 'restore_data',
				data: h_data,
			});
		@end
	};

	// simply flag that consumer requested pause
	const F_PAUSE_NEGATIZE = function() {
		this.n = -1;
	};
@end

/* whitespace */


@ // control variables

@ // count how many braces need closing
@set match_counter 0

@ // whether or not the method macro is going to account for relative iris
@set RELATIVE_IRIS true


@if TRIPLES
	@set STATEMENT_TYPE 'triple'
@elseif QUADS
	@set STATEMENT_TYPE 'quad'
@end


@ // keys for the object that represents the RDF object term
@set KEY_IRI 'value'
@set KEY_LITERAL_VALUE 'value'
@set KEY_LITERAL_DATATYPE 'datatype'
@set KEY_LITERAL_LANGUAGE 'language'
@set KEY_BLANK_NODE_LABEL 'value'
@set KEY_DEFAULT_GRAPH_IRI 'value'

@macro dot(key)
.@{key}
@end


@macro iri()
@{dot(KEY_IRI)}
@end

@macro literal_value()
@{dot(KEY_LITERAL_VALUE)}
@end

@macro literal_datatype()
@{dot(KEY_LITERAL_DATATYPE)}
@end

@macro literal_language()
@{dot(KEY_LITERAL_LANGUAGE)}
@end

@macro blank_node_label()
@{dot(KEY_BLANK_NODE_LABEL)}
@end



@ // save current state to stack
@macro push_state(state)
	this.nested.push([this.subject, this.predicate, '@{state}']);
@end

@ // restore previous state from stack
@macro pop_state()
	let s_resume_state;
	[this.subject, this.predicate, s_resume_state] = this.nested.pop();
	return this[s_resume_state]();
@end

@ // save current state to stack
@macro push_nest(state)
	this.nested.push('@{state}');
@end

@ // restore previous state from stack
@macro pop_nest()
	return this[this.nested.pop()]();
@end


@ // change state
@macro goto(method)
	return this.@{method}();
@end


@ // declare a parse state
@macro method(name, extern)
	// parse state for @{name}
	@if extern
		@{name}: () => {
	@else
		@{name}() {
	@end
		// destruct chunk, length, and index
		let {@{CHUNK}, n, i} = this;

		// start labeled loop, run while there are characters
		@{name}: while(i < n) {
@end


@ // end parse state method
@macro end_method(name, max_token)
		}

		// ran out of characters
		@{resume_state(name, false, max_token)}
	},
@end


@ // set resume state & stop parsing in this stack
@macro resume_state(mode, use_field_chunk, max_token)
	// update index value
	this.i = i;

	// not yet eos
	if(i < this.n) {
		// expected token was not found
		if(0 === i) {
			// we've exceeded the maximum token length
			if(this.n > this.@{max_token? max_token: 'max_token_length'}) {
				return this.parse_error('@{mode}');
			}
		}
	}

	// save state before pausing
	this.state = this.@{mode};

	// consumer is pausing
	if(this.n < 0) {
		// go async
		return;
	}

	// store what is unparsed
	this.pre = @{use_field_chunk?'this.':''}@{CHUNK}.slice(i);

	// if we're not parsing a stream, then this is an error
	this.eos && this.eos();
	return;
@end



@ // test the current character
@macro if_char(a, b)
	if(`@{a}` === x@{b?' || `':''}@{b?b:''}@{b?'` === x':''}) {
@end

@ // else, test the current character
@macro else_if_char(a, b)
	} else @{if_char(a, b)}
@end

@ // else, test the current character without use of intermediate variable
@macro else_if_char_only(a)
	} else if (`@{a}` === s[i]) {
@end


@ // test regex
@macro if_test(regex, local)
	@ // count how many else branches we'll need to close
	@set match_counter (match_counter + 0)

	// prepare sticky regex index
	@{regex}.lastIndex = i;

	if(@{regex}.test(s)) {

	// advance index
	@{local? '': 'this.'}i = @{regex}.lastIndex;
@end

@ // try next test
@macro else_if_test(regex, local)
	@ // count how many else branches we'll need to close
	@set match_counter (match_counter + 1)

	@ // whern previous test fails
	} else {
		@ // try next test
		@{if_test(regex, local)}
@end


@ // exec regex and store match
@macro if_match(regex, match, local)
	@ // count how many else branches we'll need to close
	@set match_counter (match_counter + 0)

	// prepare sticky regex index
	@{regex}.lastIndex = i;

	@ // store the match
	@if match
		// execute regex
		let @{match} = @{regex}.exec(s);

		// regex was a match
		if(@{match}) {
	@ // no need to store the match
	@else
		if(@{regex}.exec(s)) {
	@end

	// advance index
	@{local? '': 'this.'}i = @{regex}.lastIndex;
@end

@ // try next match
@macro else_if_match(regex, match, local)
	@ // increment number of else branches we'll need to close
	@set match_counter (match_counter + 1)

	// match_counter: @{match_counter}

	@ // when previous match fails
	} else {
		@ // try next match
		@{if_match(regex, match, local)}
@end


@ // close all preceeding else branches
@macro end_else()
 	@ // end last branch
	}

	@ // for all other branches
	@repeat match_counter
		} // @{loop.index}
	@end

	@ // reset match counter
	@set match_counter 0
@end


@ // all matches failed, pause parser
@macro else_retry()
	// match counter: @{match_counter}
	} else {
		// break loop to retry on next chunk if eos
		break;

	@ // close all preceeding else branches
	@{end_else()}
@end



@ // emit a statement event to listener using current subject/predicate/object
@macro emit_statement()
	this.data(new Quad(this));
	// this.operator.emit('data', new Quad(this));
@end


@ // emit statement and return control to whatever function asked for it
@macro end_of_statement()
	// at this point, a new statement has been parsed
	@{emit_statement()}

	// goto next parsing state; bail out of stack
	return this.after_end_of_statement;
@end


@ // consume whitespace
@macro whitespace(offset, local)
	R_WS.lastIndex = @{offset};
	R_WS.exec(s);
	@{!local? 'this.': ''}i = R_WS.lastIndex;
@end


@ // replace unicode escapes; all_ranges will also escape single char code
@macro replace_unicode(all_ranges)
	replace(@{all_ranges? 'R_UNICODE_ANY': 'R_UNICODE_8'}, F_UNICODE_REPLACE)
@end

@ // extract name from suffix
@macro suffix(term)
	// escape local escapes
	let s_suffix = @{term}[2]
		.@{replace_unicode(true)}
		.replace(R_PN_LOCAL_ESCAPES, '$1');
@end


@ // extract uri from absolute / relative iri refs
@macro iriref(term, match, object, set_base, has_escapes, not_this)
	// ref iri
	let s_iri = @{match}[1]
		@if has_escapes
			.@{replace_unicode(true)};
		@end
	;

	// absolute iri
	if(!this.base_url || R_IRI_ABSOLUTE.test(s_iri)) {
		// set @{term}
		@{not_this? '': 'this.'}@{term} = @{object?'new NamedNode(':''}s_iri@{object?')':''};
	}
	// relative iri
	else {
		// make @{term}
		switch(s_iri[0]) {
			case '#':
				@{not_this? '': 'this.'}@{term} = @{object?'new NamedNode(':''}this.base_url + s_iri@{object?')':''};
				break;
			case '?':
				@{not_this? '': 'this.'}@{term} = @{object?'new NamedNode(':''}this.base_url.replace(/(\?.*)?$/, s_iri)@{object?')':''};
				break;
			case '/':
				// relative to scheme
				if('/' === s_iri[1]) {
					@{not_this? '': 'this.'}@{term} = @{object?'new NamedNode(':''}this.base_url_scheme + F_DOT_SEGMENTS(s_iri.substr(1))@{object?')':''};
				}
				// relative to root
				else {
					@{not_this? '': 'this.'}@{term} = @{object?'new NamedNode(':''}this.base_url_root + F_DOT_SEGMENTS(s_iri)@{object?')':''};
				}
				break;
			// empty
			case undefined:
				// identity
				@{not_this? '': 'this.'}@{term} = @{object?'new NamedNode(':''}this.base_url@{object?')':''};
				break;
			// dot segment
			case '.':
				// prepend so it is relative to root
				s_iri = '/'+s_iri;
			// relative to path
			default:
				@{not_this? '': 'this.'}@{term} = @{object?'new NamedNode(':''}this.base_url_root + F_DOT_SEGMENTS(this.base_url_path + s_iri)@{object?')':''};
		}
	}

	@ // update the base iri
	@if set_base
		let m_base_iri = R_BASE_IRI.exec(this.base_url);
		this.@{term} = m_base_iri[1];
		this.@{term}_root = m_base_iri[2] || '';
		this.@{term}_scheme = m_base_iri[3] || '';
		this.@{term}_path = m_base_iri[4] || ''; 
	@end
@end


@ // set object value and datatype for numeric literal
@macro numeric_literal()
	// it has exponent term, xsd:double
	if(m_numeric_literal[4]) {
		this.object = new DoubleLiteral(m_numeric_literal[1]);
	}
	// contains decimal point, xsd:decimal
	else if(m_numeric_literal[2] || m_numeric_literal[3]) {
		this.object = new DecimalLiteral(m_numeric_literal[1]);
	}
	// otherwise, it is an integer
	else {
		this.object = new IntegerLiteral(m_numeric_literal[1]);
	}
@end


@ // set object value and datatype for boolean literal
@macro boolean_literal()
	// make literal
	this.object = new BooleanLiteral(m_boolean_literal[1]? true: false);
@end


@ // unescape a string literal
@macro unescape(str, version)
	JSON.parse('"'
		+@{str}
			.@{replace_unicode()}
			.replace(R_ESCAPES, '$1$2') // no need to escape anything other than reserved characters
			@if 'long' == version
				.replace(/[\t\n"\r\f\u0008]/g, (s) => {
					return H_SPECIAL_ESCAPES[s];
				})
			@else
				.replace(/"/g, '\\"') // escape all quotes ;)
			@end
		+'"')
@end

@ // set the object value of a string literal
@macro set_string_literal(match, version)
	// set literal value
	h_literal@{literal_value()} = 
	@if 'no-escape' == version
		@{match}[1];
	@else
		@{unescape(match+'[1]', version)};
	@end
@end


@ // assert the prefix found in prefixed name is valid
@macro valid_prefix(match)
	// check valid prefix
	let s_prefix_id = @{match}[1] || '';

	// invalid prefix
	if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this._error(`no such prefix "${s_prefix_id}"`);
@end


@ // 
@macro full_stop()
	if(this.expect_full_stop) {
		// change state
		@{goto('full_stop')}
	}
@end


@macro this_defer_errors()
	// error event
	_error: h_config.error || ((e_parse) => {
		throw `parse error: ${e_parse}`;
	}),

	// parse_error (not meant to be an event callback)
	parse_error(s_expected, b_eof) {
		@if T
			let i = this.i;
			let i_off = Math.min(i, Math.abs(i-15));
		@else
			let i = 0;
			let i_off = 0;
		@end
		let s = this.s;
		this._error(`\n\`${s.substr(i_off, i_off+90).replace(/[\n\t]/g, ' ')}\`\n`
			+` ${' '.repeat(i-i_off)}^\n`
			+`expected ${s_expected} ${b_eof? 'but encountered <<EOF>>': ''}.  failed to parse a valid token starting at ${s[i]? '"'+s[i]+'"': '<<EOF>>'}`);
	},
@end
