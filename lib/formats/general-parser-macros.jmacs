/* eslint-disable */

@ // control variables

@ // count how many braces need closing
@set match_counter 0

@ // whether or not the method macro is going to account for relative iris
@set RELATIVE_IRIS true

@if BINARY
	@set CHUNK 'a'
@else
	@set CHUNK 's'
@end



@ // make stream controls
@macro stream_control(stream, transform)

	// pause the parser (& stream if applicable)
	this.pause = this.restore_pause = function() {
		// already paused
		if(this.n < 0) {
			debugger;
			return;
		}

		// set length too low so execution will hault
		this.n = -1;

		@ // parser is streaming input
		@if stream
			// pause readable input stream
			@{stream}.pause();
		@end

		// make sure we are not currently emptying queue
		if(this.data !== F_QUEUE_DATA) {
			// save original data event callback
			this.restore_data = this.data;

			// set up callback to capture data events that happen while pausing
			this.data = F_QUEUE_DATA;
		}

		@ // for Turtle and TriG
		@if T
			// consumer is subscribed to prefix events
			if(this.prefix) {
				// save original prefix event callback
				this.restore_prefix = this.prefix;

				// set up callback to capture prefix events that happen while pausing
				this.prefix = F_QUEUE_PREFIX;
			}
		@end
	};

	// hault the parser (& close stream if applicable/possible)
	this.stop = function() {
		// cause parser to break asap
		this.n = -1;

		// safely remove event callbacks and user functions
		this.pause = this.restore_pause =
		this.resume = this.stop =
		this.error = this.end = this.parse_error =
		this.data = this.restore_data =
		@if T
			this.restore_prefix = this.prefix =
			this.base =
		@end
			function(){};

		@ // for transforms
		@if transform
			// empty event queue in case user paused and accumulated events
			this.queue_event.length = 0;
		@end

		@ // for streams
		@if stream
			// attempt to destroy the readable stream
			if('function' === typeof @{stream}.destroy) {
				@{stream}.destroy();
			}
		@end
	};

	// resume the parser (& stream if applicable)
	this.resume = function() {
		// not even paused
		if(this.n >= 0) return;

		// enter pseudo-"flowing" mode
		this.n = 0;

		// temporarily re-route calls to pause
		this.pause = F_PAUSE_NEGATIZE;

		// now back in "flowing", drain event queue
		while(this.queue_event.length) {
			// remove event from front of queue
			let h_event = this.queue_event.shift();

			// make event callback
			@if N
				this.restore_data(h_event@{transform? ', d_transform': ''});
			@else
				this[h_event.event].call(this, h_event.data@{transform? ', d_transform': ''});
			@end

			// callback paused stream
			if(this.n < 0) {
				// stop emptying event queue and go async immediately
				return;
			}
		}

		// restore pause function
		this.pause = this.restore_pause;

		// restore data event
		this.data = this.restore_data;

		// eof'ed
		if(null === this.s) return;

		@ // for Turtle and TriG
		@if T
			// restore actual length
			this.n = this.s.length;

			// restore prefix event
			if(this.prefix) {
				this.prefix = this.restore_prefix;
			}

			// parse remainder
			if(this.i < this.n) {
				this.safe_parse();

				// user paused!
				if(this.n < 0) {
					// slice current
					if(this.i) {
						this.pre = this.s.slice(this.i);
					}

					// do not turn stream back on
					return;
				}
			}

			// slice current
			if(this.i) {
				this.pre = this.s.slice(this.i);
			}
		@end

		@ // for streams only
		@if stream
			// now that event queue is empty, resume readable input stream
			@{stream}.resume();
		@end
	};
@end



@ // joins output buffer to string, writes that to stream and resets list
@macro write_buffer()
	if(a_buffer.length) {
		d_transform.push(a_buffer.join('')+'', 'utf8');
		a_buffer.length = 0;
	}
@end


@ // ensure there are no conflicting blank node labels
@macro no_label_conflict()
	// not first time use of label
	let z_label_state = this.labels[s_label];
	if(z_label_state) {
		// label was used previously by document and has no conflict
		if(1 === z_label_state) {}
		// label is in use by invention, this would cause a conflict
		else if(2 === z_label_state) {
			// so create a redirect mapping for this actual label & use it instead
			s_label = this.labels[s_label] = this.next_label();
		}
		// label already has a redirect mapping
		else {
			// use redirected label
			s_label = this.labels[s_label];
		}
	}
	// first time use of label
	else {
		// store label in hash so we avoid future collisions
		this.labels[s_label] = 1;
	}
@end

@def PN_CHARS_BASE()
	A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}
@end

@def PN_CHARS_U()
	@{PN_CHARS_BASE()}_
@end

@def PN_CHARS()
	@{PN_CHARS_U()}\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}
@end

@def PN_CHARS_FS()
	([@{PN_CHARS()}.]*[@{PN_CHARS()}])?
@end

@def PN_PREFIX()
	[@{PN_CHARS_BASE()}]@{PN_CHARS_FS()}
@end

@def PLX()
	%[A-Fa-f0-9]{2}|\\[_~.\-!$&'()*+,;=/?#@%]
@end

@def PN_LOCAL()
	([@{PN_CHARS_U()}:0-9]|@{PLX()})(([@{PN_CHARS()}.:]|@{PLX()})*([@{PN_CHARS()}:]|@{PLX()}))?
@end

@def UCHAR(ins='')
	\\u[@{ins}A-Fa-f0-9]{4}|\\U[@{ins}A-Fa-f0-9]{8}
@end

@def validators()
	{
		blank_node(s_value, b_named) {
			if(!R_BLANK_NODE_VALID.test(s_value)) return this._error(`invalid blank node label: "${s_value}"`);
			return new BlankNode(s_value, b_named);
		},

		named_node(s_iri) {
			if(!R_NAMED_NODE_VALID.test(s_iri)) return this._error(`invalid IRI: "${s_iri}"`);
			return new NamedNode(s_iri);
		},

		unescape_literal_long(s_literal) {
			if(R_ESCAPES_INVALID.test(s_literal)) return this._error(`invalid literal: "${s_literal}"`);
			try {
				return unescape_literal_long(s_literal);
			}
			catch(e_parse) {
				return this._error(`invalid string literal: "${s_literal}"`);
			}
		},

		unescape_literal_short(s_literal) {
			if(R_ESCAPES_INVALID.test(s_literal)) return this._error(`invalid literal: "${s_literal}"`);
			try {
				return unescape_literal_short(s_literal);
			}
			catch(e_parse) {
				return this._error(`invalid string literal: "${s_literal}"`);
			}
		},

		match_prefixed_name_escapeless(s, i) {
			let [m_prefixed_name_e, im_prefixed_name_e] = match_prefixed_name_escapeless(s, i);
			if(m_prefixed_name_e) {
				// invalid namespace
				if(!R_PREFIXED_NAME_NAMESPACE_VALID.test(m_prefixed_name_e[1])) {
					this._error(`invalid prefixed name namespace: "${m_prefixed_name_e[1]}:"`);
					return;
				}
				// invalid local name
				else if(!R_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name_e[2])) {
					this._error(`invalid prefixed name local name: "${m_prefixed_name_e[2]}:"`);
					return;
				}
			}

			return [m_prefixed_name_e, im_prefixed_name_e];
		},

		match_prefixed_name(s, i) {
			let [m_prefixed_name, im_prefixed_name] = match_prefixed_name(s, i);
			if(m_prefixed_name) {
				// invalid namespace
				if(!R_PREFIXED_NAME_NAMESPACE_VALID.test(m_prefixed_name[1])) {
					this._error(`invalid prefixed name namespace: "${m_prefixed_name[1]}:"`);
					return;
				}
				// invalid local name
				else if(!R_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name[2])) {
					this._error(`invalid prefixed name local name: "${m_prefixed_name[2]}:"`);
					return;
				}
			}

			return [m_prefixed_name, im_prefixed_name];
		},
	}
@end


@ // create a class for each of the term types that the object of a triple can be
@macro term_types(from_this)
	function GenericTerm() {}
	Object.assign(GenericTerm.prototype, {
		equals(h_other) {
			return (h_other.termType === this.termType && h_other.value === this.value);
		},
		toCanonical() {
			return this.valueOf();
		},
	});


	function NamedNode(s_iri) {
		this.value = s_iri;
	} NamedNode.prototype = Object.assign(
		Object.create(GenericTerm.prototype), {
			termType: 'NamedNode',
			isNamedNode: true,
			valueOf() {
				return this.value;
			},
			verbose() {
				return '<'+this.value+'>';
			},
			terse() {
				return '<'+this.value+'>';
			},
			concise() {
				return this.value;
			},
		});

	const HP_NN_XSD_STRING = new NamedNode('http://www.w3.org/2001/XMLSchema#string');
	const HP_NN_RDFS_LANG_STRING = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');
	function Literal(s_value) {
		this.value = s_value;
	} Literal.prototype = Object.assign(
		Object.create(GenericTerm.prototype), {
			datatype: HP_NN_XSD_STRING,
			termType: 'Literal',
			isLiteral: true,
			equals(h_other) {
				return 'Literal' === h_other.termType && h_other.value === this.value
					&& this.datatype.equals(h_other.datatype) && h_other.language === this.language;
			},
			valueOf() {
				return (this.language? '@'+this.language: '^'+this.datatype.value)
					+'"'+this.value;
			},
			verbose() {
				return JSON.stringify(this.value) +
					(this.language
						? '@'+this.language
						: (this.datatype !== HP_NN_XSD_STRING
							? '^^<'+this.datatype.value+'>'
							: '')) ;
			},
			terse() {
				return JSON.stringify(this.value) +
					(this.language
						? '@'+this.language
						: (this.datatype !== HP_NN_XSD_STRING
							? '^^<'+this.datatype.value+'>'
							: '')) ;
			},
			concise() {
				return this.language
					? '@'+this.language+'"'+this.value
					: (this.datatype !== HP_NN_XSD_STRING
							? '^'+this.datatype.value+'"'+this.value
							: '"'+this.value);
			},
		});

	@ // for Turtle an TriG only
	@if T
		function IntegerLiteral(s_value) {
			this.value = s_value;
			this.number = parseInt(s_value);
		}
		IntegerLiteral.prototype = Object.assign(
			Object.create(Literal.prototype), {
				terse() {
					return this.value;
				},
				concise() {
					return '^http://www.w3.org/2001/XMLSchema#integer"'+this.value;
				},
				datatype: new NamedNode('http://www.w3.org/2001/XMLSchema#integer'),
				isNumeric: true,
				isInteger: true,
			});

		function DecimalLiteral(s_value) {
			this.value = s_value;
			this.number = parseFloat(s_value);
		}
		DecimalLiteral.prototype = Object.assign(
			Object.create(Literal.prototype), {
				terse() {
					return this.value;
				},
				concise() {
					return '^http://www.w3.org/2001/XMLSchema#decimal"'+this.value;
				},
				datatype: new NamedNode('http://www.w3.org/2001/XMLSchema#decimal'),
				isNumeric: true,
				isDecimal: true,
			});

		function DoubleLiteral(s_value) {
			this.value = s_value;
			this.number = parseFloat(s_value);
		}
		DoubleLiteral.prototype = Object.assign(
			Object.create(Literal.prototype), {
				terse() {
					return this.value;
				},
				concise() {
					return '^http://www.w3.org/2001/XMLSchema#double"'+this.value;
				},
				datatype: new NamedNode('http://www.w3.org/2001/XMLSchema#double'),
				isNumeric: true,
				isDouble: true,
			});

		function BooleanLiteral(b_value) {
			this.value = b_value? 'true': 'false';
			this.boolean = b_value;
		}
		BooleanLiteral.prototype = Object.assign(
			Object.create(Literal.prototype), {
				terse() {
					return this.value;
				},
				concise() {
					return '^http://www.w3.org/2001/XMLSchema#boolean"'+this.value;
				},
				datatype: new NamedNode('http://www.w3.org/2001/XMLSchema#boolean'),
				isBoolean: true,
			});
	@end

	function BlankNode(s_value) {
		this.value = s_value;
	} BlankNode.prototype = Object.assign(
		Object.create(GenericTerm.prototype), {
			termType: 'BlankNode',
			isBlankNode: true,
			valueOf() {
				return '_'+this.value;
			},
			verbose() {
				return '_:'+this.value;
			},
			terse() {
				return '_:'+this.value;
			},
			concise() {
				return '_'+this.value;
			},
		});

	function AnonymousBlankNode(s_value) {
		this.value = s_value;
	} AnonymousBlankNode.prototype = Object.assign(
		Object.create(BlankNode.prototype), {
			isAnonymous: true,
		});

	function DefaultGraph() {}
	DefaultGraph.prototype = Object.assign(
		Object.create(GenericTerm.prototype), {
			value: '',
			termType: 'DefaultGraph',
			isDefaultGraph: true,
			valueOf() {
				return '*';
			},
			verbose() {
				return '';
			},
			terse() {
				return '';
			},
			concise() {
				return '*';
			},
		});

	const H_DEFAULT_GRAPH = new DefaultGraph();

	@ // make Quad constructor
	@if T
		// creates a new Quad by copying the current terms from the parser state
		function Quad(quad) {
			this.subject = quad.subject;
			this.predicate = quad.predicate;
			this.object = quad.object;
			this.graph = quad.graph;
		}
	@else
		// creates the quad from components
		function Quad(k_subject, k_predicate, k_object, k_graph) {
			this.subject = k_subject;
			this.predicate = k_predicate;
			this.object = k_object;
			this.graph = k_graph;
		}
	@end

	Object.assign(Quad.prototype, {
		equals(y_other) {
			return this.object.equals(y_other.object)
				&& this.subject.equals(y_other.subject)
				&& this.predicate.equals(y_other.predicate)
				&& this.graph.equals(y_other.graph);
		},
		verbose() {
			return this.subject.verbose()
				+' '+this.predicate.verbose()
				+' '+this.object.verbose()
				+' '+(this.graph.isDefaultGraph? '': this.graph.verbose()+' ')+'.\n';
		},
		concise() {
			return this.graph.concise()+'\n\t'
				+this.subject.concise()+'\n\t\t'
				+this.predicate.concise()+'\n\t\t\t'
				+this.object.concise()+'\n';
		},
		toCanonical() {
			return this.verbose();
		},
		// terse() {
		// 	return this.subject.terse()
		// 		+' '+this.predicate.terse()
		// 		+' '+this.object.terse()
		// 		+' '+(this.graph.isDefaultGraph ? '' : this.graph.toCanonical()+' ')+'.\n';
		// },
		valueOf() {
			return this.graph+' '+this.subject+' '+this.predicate+' '+this.object;
		},
	});

	const R_BLANK_NODE_VALID = /^[@{PN_CHARS_U()}0-9]@{PN_CHARS_FS()}$/u;
	const R_NAMED_NODE_VALID = /^([^\0- <>"{}|^`\\]|@{UCHAR()})*$/;

@end


@macro export_module()
	module.exports = function(z_input, h_config) {
		// duplex mode
		if(1 === arguments.length) {
			// shift arguments
			h_config = z_input; z_input = null;
		}

		// create parser, return operator if it wants to
		return (new Parser(z_input, h_config)).operator;
	};
@end


/* whitespace */
