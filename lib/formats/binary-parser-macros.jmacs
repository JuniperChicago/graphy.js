/* eslint-disable */

@ // import parser macros
@include 'general-parser-macros.jmacs'

@ // possible mode types are:
@ // HDT: Header Dictionary Triples

@set brace_counter 0

@ // convert utf8-encoded byte sequence to string
@macro utf8_string(array)
	decode_utf_8(@{array? array: 'a.slice(i, i_null)'})
@end

// only if the 
@macro if_null_termination()
@end

@ // change state
@macro goto(method)
	return this.@{method}(a, n, i);
@end


@ // save current state to stack
@macro push_state(state, is_var)
	@set q "'"
	this.nested.push(@{is_var? '': q}@{state}@{is_var? '': q});
@end

@ // restore previous state from stack
@macro pop_state()
	let s_resume_state = this.nested.pop();
	return this[s_resume_state](a, n, i);
@end


@macro method(name, bytes_needed, string_var, n)
	@{name}(a, n, i) {
		@ // minimum number of bytes needed for this state
		@if bytes_needed
			@ // count how many braces need to be closed
			@set brace_counter (brace_counter + 1)

			@if bytes_needed == 1
				// single byte needed
				if(i < n) {
			@else
				// need at least @{bytes_needed} bytes
				if(n - i >= @{bytes_needed}) {
			@end
		@ // null-terminated string
		@elseif string_var
			@ // count how many braces need to be closed
			@set brace_counter (brace_counter + 1)

			// index of null character
			let i_null = a.indexOf(0, i);

			// string is within buffer
			if(-1 !== i_null) {
				@{crc(n? n: 16)}
				// decode string from buffer
				let @{string_var} = @{utf8_string()};
		@end
@end


@macro bail(state)
	// save state before pausing
	this.state = this.@{state};

	// update offset
	this.offset += i;

	// consumer is pausing
	if(n < 0) {
		// go async
		return;
	}

	// store what is unparsed
	this.pre = a.slice(i);

	// if we're not parsing a stream, then this is an error
	// return this.eos && this.eos();
	return;
@end


@macro end_method(name)
		@ // for all braces that need to be closed
		@repeat brace_counter
			} // @{loop.index}
		@end

		@ // reset brace counter
		@set brace_counter 0

		// not yet eos
		if(i < n) {
			// no bytes were consumed
			if(0 === i) {
				// we've exceeded the maximum buffer size
				if(n > this.max_buffer_size) {
					return this.parse_error(a, n, i, '@{name}');
				}
			}
		}

		@{bail(name)}
	},
@end


/* whitespace */