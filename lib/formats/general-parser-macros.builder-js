/* eslint-disable */

@ /** control variables **/

@ // count how many braces need closing
@set match_counter 0

@ // whether or not the method macro is going to account for relative iris
@set RELATIVE_IRIS true

@if BINARY
	@set CHUNK 'a'
@else
	@set CHUNK 's'
@end



@ // make stream controls
@macro stream_control(stream, transform)

	// pause the parser (& stream if applicable)
	this.pause = this.restore_pause = function() {
		// already paused
		if(this.n < 0) return;

		@ // parser is streaming input
		@if stream
			// pause readable input stream
			@{stream}.pause();
		@end

		// set length too low so execution will hault
		this.n = -1;

		// save original data event callback
		this.restore_data = this.data;

		// set up callback to capture data events that happen while pausing
		this.data = F_QUEUE_DATA;

		@ // for Turtle and TriG
		@if T
			// consumer is subscribed to prefix events
			if(this.prefix) {
				// save original prefix event callback
				this.restore_prefix = this.prefix;

				// set up callback to capture prefix events that happen while pausing
				this.prefix = F_QUEUE_PREFIX;
			}
		@end
	};

	// hault the parser (& close stream if applicable/possible)
	this.stop = function() {
		// cause parser to break asap
		this.n = -1;

		// safely remove event callbacks and user functions
		this.pause = this.restore_pause =
		this.resume = this.stop =
		this.error = this.end = this.parse_error =
		this.data = this.restore_data =
		@if T
			this.restore_prefix = this.prefix =
			this.base =
		@end
			function(){};

		@ // for transforms
		@if transform
			// empty event queue in case user paused and accumulated events
			this.queue_event.length = 0;
		@end

		@ // for streams
		@if stream
			// attempt to destroy the readable stream
			if('function' === typeof @{stream}.destroy) {
				@{stream}.destroy();
			}
		@end
	};

	// resume the parser (& stream if applicable)
	this.resume = function() {
		// not even paused
		if(this.n >= 0) return;

		// enter pseudo-"flowing" mode
		this.n = 0;

		// temporarily re-route calls to pause
		this.pause = F_PAUSE_NEGATIZE;

		// now back in "flowing", drain event queue
		while(this.queue_event.length) {
			// remove event from front of queue
			let h_event = this.queue_event.shift();

			// make event callback
			@if N
				this.restore_data(h_event@{transform? ', d_transform': ''});
			@else
				this[h_event.event].call(this, h_event.data@{transform? ', d_transform': ''});
			@end

			// callback paused stream
			if(this.n < 0) {
				// stop emptying event queue and go async immediately
				return;
			}
		}

		@ // for streams only
		@if stream
			// now that event queue is empty, resume readable input stream
			@{stream}.resume();
		@end

		// restore pause function
		this.pause = this.restore_pause;

		// restore data event
		this.data = this.restore_data;

		@ // for Turtle and TriG
		@if T
			// restore actual length
			this.n = this.s.length;

			// restore prefix event
			if(this.prefix) {
				this.prefix = this.restore_prefix;
			}

			// resume state
			this.state();
		@end
	};
@end



@ // joins output buffer to string, writes that to stream and resets list
@macro write_buffer()
	if(a_buffer.length) {
		d_transform.push(a_buffer.join('')+'', 'utf8');
		a_buffer.length = 0;
	}
@end


@ // ensure there are no conflicting blank node labels
@macro no_label_conflict()
	// not first time use of label
	let z_label_state = this.labels[s_label];
	if(z_label_state) {
		// label was used previously by document and has no conflict
		if(1 === z_label_state) {}
		// label is in use by invention, this would cause a conflict
		else if(2 === z_label_state) {
			// so create a redirect mapping for this actual label & use it instead
			s_label = this.labels[s_label] = this.next_label();
		}
		// label already has a redirect mapping
		else {
			// use redirected label
			s_label = this.labels[s_label];
		}
	}
	// first time use of label
	else {
		// store label in hash so we avoid future collisions
		this.labels[s_label] = 1;
	}
@end


@ // create a class for each of the term types that the object of a triple can be
@macro term_types(from_this)
	function GenericTerm() {}
	Object.assign(GenericTerm.prototype, {
		equals(h_other) {
			return (h_other.termType === this.termType && h_other.value === this.value);
		},
		toCanonical() {
			return this.valueOf();
		},
	});


	function NamedNode(s_iri) {
		this.value = s_iri;
	} NamedNode.prototype = Object.assign(
		Object.create(GenericTerm.prototype), {
			termType: 'NamedNode',
			isNamedNode: true,
			valueOf() {
				return this.value;
			},
			verbose() {
				return '<'+this.value+'>';
			},
			terse() {
				return '<'+this.value+'>';
			},
		});

	const HP_NN_XSD_STRING = new NamedNode('http://www.w3.org/2001/XMLSchema#string');
	const HP_NN_RDFS_LANG_STRING = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString');
	function Literal(s_value) {
		this.value = s_value;
	} Literal.prototype = Object.assign(
		Object.create(GenericTerm.prototype), {
			datatype: HP_NN_XSD_STRING,
			termType: 'Literal',
			isLiteral: true,
			equals(h_other) {
				return 'Literal' === h_other.termType && h_other.value === this.value
					&& this.datatype.equals(h_other.datatype) && h_other.language === this.language;
			},
			valueOf() {
				return (this.language? '@'+this.language: '^'+this.datatype.value)
					+'"'+this.value;
			},
			verbose() {
				return JSON.stringify(this.value) +
					(this.language
						? '@'+this.language
						: (this.datatype !== HP_NN_XSD_STRING
							? '^^<'+this.datatype.value+'>'
							: '')) ;
			},
			terse() {
				return JSON.stringify(this.value) +
					(this.language
						? '@'+this.language
						: (this.datatype !== HP_NN_XSD_STRING
							? '^^<'+this.datatype.value+'>'
							: '')) ;
			},
		});

	@ // for Turtle an TriG only
	@if T
		function IntegerLiteral(s_value) {
			this.value = s_value;
			this.number = parseInt(s_value);
		}
		IntegerLiteral.prototype = Object.assign(
			Object.create(Literal.prototype), {
				terse() {
					return this.value;
				},
				datatype: new NamedNode('http://www.w3.org/2001/XMLSchema#integer'),
				isNumeric: true,
			});

		function DecimalLiteral(s_value) {
			this.value = s_value;
			this.number = parseFloat(s_value);
		}
		DecimalLiteral.prototype = Object.assign(
			Object.create(Literal.prototype), {
				terse() {
					return this.value;
				},
				datatype: new NamedNode('http://www.w3.org/2001/XMLSchema#decimal'),
				isNumeric: true,
			});

		function DoubleLiteral(s_value) {
			this.value = s_value;
			this.number = parseFloat(s_value);
		}
		DoubleLiteral.prototype = Object.assign(
			Object.create(Literal.prototype), {
				terse() {
					return this.value;
				},
				datatype: new NamedNode('http://www.w3.org/2001/XMLSchema#double'),
				isNumeric: true,
			});

		function BooleanLiteral(b_value) {
			this.value = b_value? 'true': 'false';
			this.boolean = b_value;
		}
		BooleanLiteral.prototype = Object.assign(
			Object.create(Literal.prototype), {
				terse() {
					return this.value;
				},
				datatype: new NamedNode('http://www.w3.org/2001/XMLSchema#boolean'),
				isBoolean: true,
			});
	@end

	function BlankNode(s_value) {
		this.value = s_value;
	} BlankNode.prototype = Object.assign(
		Object.create(GenericTerm.prototype), {
			termType: 'BlankNode',
			isBlankNode: true,
			valueOf() {
				return ' '+this.value;
			},
			verbose() {
				return '_:'+this.value;
			},
			terse() {
				return '_:'+this.value;
			},
		});

	function DefaultGraph() {}
	DefaultGraph.prototype = Object.assign(
		Object.create(GenericTerm.prototype), {
			value: '',
			termType: 'DefaultGraph',
			isDefaultGraph: true,
			valueOf() {
				return '*';
			},
			verbose() {
				return '';
			}
			terse() {
				return '';
			},
		});

	const H_DEFAULT_GRAPH = new DefaultGraph();

	@ // make Quad constructor
	@if T
		// creates a new Quad by copying the current terms from the parser state
		function Quad(quad) {
			this.subject = quad.subject;
			this.predicate = quad.predicate;
			this.object = quad.object;
			this.graph = quad.graph;
		}
	@else
		function Quad(subject, predicate, object, graph) {
			this.subject = subject;
			this.predicate = predicate;
			this.object = object;
			this.graph = graph;
		}
	@end

	Object.assign(Quad.prototype, {
		equals(y_other) {
			return this.object.equals(y_other.object)
				&& this.subject.equals(y_other.subject)
				&& this.predicate.equals(y_other.predicate)
				&& this.graph.equals(y_other.graph);
		},
		// terse() {
		// 	return this.subject.terse()
		// 		+' '+this.predicate.terse()
		// 		+' '+this.object.terse()
		// 		+' '+(this.graph.isDefaultGraph ? '' : this.graph.toCanonical()+' ')+'.\n';
		// },
		valueOf() {
			return this.graph+' '+this.subject+' '+this.predicate+' '+this.object;
		},
	});

@end


@macro export_module()
	module.exports = function(z_input, h_config) {
		// duplex mode
		if(1 === arguments.length) {
			// shift arguments
			h_config = z_input; z_input = null;
		}

		// create parser, return operator if it wants to
		return (new Parser(z_input, h_config)).operator;
	};
@end


/* whitespace */
