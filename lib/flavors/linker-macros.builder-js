

@set range_counter 0
@set range_name ''

@macro range(low, high)
	@{range_counter}() {
		if(@{low} === i_@{range_name}_id) {
			i_@{range_name}_id = @{high};
			next_@{range_name}_id = h_@{range_name}_id_generators[@{range_counter+1}];
		}
		return String.fromCodePoint(i_@{range_name}_id++);
	},
	@set range_counter range_counter + 1
@end

@macro id_generator(name)
	@ // prep for external macro
	@set range_name name

	@ // reset index for multiple uses
	@set range_counter  0

	// starting index
	let i_@{name}_id = 0x41;

	// generators
	const h_@{name}_id_generators = {
		// [A-Z]
		@{range('0x5b', '0x61')}

		// [a-z]
		@{range('0x7b', '0xc0')}

		// [\u00c0-\u00d6]
		@{range('0xd7', '0xd8')}

		// [\u00d8-\u00f6]
		@{range('0xf7', '0xf8')}

		// [\u00f8-\u02ff]
		@{range('0x0300', '0x037F')}

		// [\u037f-\u01fff]
		@{range('0x2000', '0x02070')}

		// [\u2070-\u218f]
		@{range('0x2190', '0x2c00')}

		// [\u2c00-\u2fef]
		@{range('0x2fd0', '0x3001')}

		// [\u3001-\ud7ff]
		@{range('0xd800', '0xf900')}

		// [\uf900-\ufdcf]
		@{range('0xfdd0', '0xfdf0')}

		// [\ufdf0-\ufffd]
		@{range('0xfffe', '0x10000')}

		// [\u{10000}-\u{effff}]
		@{range('0xf0000', 'NaN')}

		@{range_counter}() {
			throw 'ran out of ids for "@{name}"!';
		},
	};

	// initialize
	let next_@{name}_id = h_@{name}_id_generators[0];
@end


@macro compress_named_node(position, hash, value)
	// ref @{position} iri
	let p_@{position}_iri = h_@{position}.value;

	// determine actual best prefix
	let m_compress_@{position} = R_COMPRESS.exec(p_@{position}_iri);
	if(m_compress_@{position}) {
		// destruct prefix fragments
		let [, p_compress_prefix, s_compress_suffix] = m_compress_@{position};

		// ref/create prefix mapping
		let s_prefix_id = h_prefix_lookup[p_compress_prefix] = h_prefix_lookup[p_compress_prefix] || next_prefix_id();

		// // make terse form
		// let s_@{position}_terse = s_prefix_id+':'+s_compress_suffix;

		s_@{position}_id = s_prefix_id+':'+s_compress_suffix;

		@ // // add to @{hash} hash as @{position}
		@ // h_@{hash}[s_@{position}_terse] |= @{value};
	}
	// unable to create prefix for @{position} iri
	else {
		// create dictionary entry; like canonicalized form but without closing angle bracket
		s_@{position}_id = '<'+p_@{position}_iri;
		@ // // add raw iri to @{hash} hash as @{position}
		@ // h_@{hash}['<'+p_@{position}_iri+'>'] |= @{value};
	}
@end


@macro compress_blank_node(position, hash, value)
	// ref @{position} label
	let s_@{position}_label = h_@{position}.value;

	@ // // ref/create label mapping
	@ // let s_label_id = h_label_lookup[s_@{position}_label] = h_label_lookup[s_@{position}_label] || next_label_id();

	s_@{position}_id = h_label_lookup[s_@{position}_label] = h_label_lookup[s_@{position}_label] || next_label_id();

	@ // // add blank node label to dictionary as @{position}
	@ // h_nodes[s_label_id] |= @{value};
@end


@macro mk_uint_array(size, range)
	@{range} <= 0x100
		? new Uint8Array(@{size})
		: (@{range} <= 0x10000
			? new Uint16Array(@{size})
			: new Uint32Array(@{size}))
@end


@macro mk_ref(kind)
	// allocate array of indicies for @{kind}s' dictionary fragment
	let n_bytes_dict_@{kind} = a_dict_@{kind}.length;
	let a_ref_@{kind} = @{mk_uint_array('c_words_'+kind, 'n_bytes_dict_'+kind)};

	// fill array
	i_index = 0; i_item = -1;
	do {
		a_ref_@{kind}[i_index++] = ++i_item;
		i_item = a_dict_@{kind}.indexOf(2, i_item+1);
	} while(i_item > 0);

	// store to instance
	k_graph.ref_@{kind} = a_ref_@{kind};
@end



@macro mk_idx(kind, size, range)
	// allocate array of indicies for @{kind}s' dictionary fragment
	let a_idx_@{kind} = @{mk_uint_array(size, range)};

	// fill array
	i_index = 0; i_item = -1;
	do {
		a_idx_@{kind}[i_index++] = (++i_item);
		i_item = a_data_@{kind}.indexOf(0, i_item);
		@ // R_NEXT_ITEM.test(a_data_@{kind});
		@ // i_item = R_NEXT_ITEM.lastIndex;
	} while(i_index < @{size});

	// store to instance
	k_graph.idx_@{kind} = a_idx_@{kind};
@end

@ // 120120230
@ // 012345678: 9

