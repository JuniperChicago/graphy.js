
@macro constants()
	// for creating new prefixes
	const R_COMPRESS = /^(.*?)([^/#]*)$/;
@end


@macro mk_uint_array(size, range)
	@{range} <= 0xff
		? new Uint8Array(@{size})
		: (@{range} <= 0xffff
			? new Uint16Array(@{size})
			: (@{range} <= 0xffffffff
				? new Uint32Array(@{size})
				: new Float64Array(@{size})))
@end


@macro string_to_buffer(str, buffer)
	let @{buffer};

	// find out-of-bound characters
	let a_oob_matches = @{str}.match(/[^\u0000-\u007f]/g);
	if(a_oob_matches) {
		// number of out-of-bound characters
		let n_oobs = a_oob_matches.length;

		// estimate utf8 length (add weighted average probability of exceeding 2 bytes)
		let n_utf8_len = @{str}.length + (n_oobs * 1.9395);

		// estimate utf16 length (add weighted average probability of exceeding 2 bytes)
		let n_utf16_len = (@{str}.length * 2) + (n_oobs * 1.8858);

		// encode in whichever probably saves more space
		@{buffer} = n_utf8_len <= n_utf16_len? encode_utf_8(@{str}): encode_utf_16(@{str});
	}
	// all characters can be encoded in utf8
	else {
		@{buffer} = encode_utf_8(@{str});
	}
@end


@macro each(what, ref, name)
	for(let i_@{what}=0, n_@{what}s=a_@{what}s.length; i_@{what}<n_@{what}s; i_@{what}++) {
		@if ref
			@if ref == 'i' && !name
				throw 'you need to name the each value something explicitly to avoid variable name collision';
			@else
				let @{ref}_@{name? name: what} = a_@{what}s[i_@{what}];
			@end
		@end
@end


@macro end_each()
	@if close_each_abc
		@{close_each_abc}
		@set close_each_abc null
	@elseif close_each_ab
		@{close_each_ab}
		@set close_each_ab null
	@else
		}
	@end
@end


@macro encoders()
	const I_UTF_16_TOKEN = 0x04;
	const AB_UTF_16_TOKEN = Buffer.from([I_UTF_16_TOKEN]);

	const encode_utf_8 = (s_chunk) => Buffer.from(s_chunk, 'utf-8');
	const encode_utf_16le = (s_chunk) => {
		// encode chunk as utf-16le
		let ab_chunk = Buffer.from(s_chunk, 'utf-16le');

		// prefix buffer w/ utf-16 token
		return Buffer.concat([AB_UTF_16_TOKEN, ab_chunk], ab_chunk.length + 1);
	};

	const R_OUTSIDE_UTF_8_SINGLE_BYTE_RANGE = /[^\u0000-\u007f]/g;
	const encode_utf_auto = (s_str) => {
		// encode in utf-8
		let ab_utf8 = encode_utf_8(s_str);

		// string contains out-of-bounds characters
		if(R_OUTSIDE_UTF_8_SINGLE_BYTE_RANGE.test(s_str)) {
			// encode in utf-16
			let ab_utf16 = encode_utf_16le(s_str);

			// return whichever saves more space
			if(ab_utf8.length <= ab_utf16.length) {
				return ab_utf8;
			}
			else {
				return ab_utf16;
			}
		}
		// all characters can be encoded in utf8
		else {
			return ab_utf8;
		}
	};
@end


@macro decoders()
	const decode_utf_8 = (ab_chunk) => ab_chunk.toString('utf-8');
	const decode_utf_16le = (ab_chunk) => ab_chunk.toString('utf-16le');
@end


@macro buffer_utils()
	const join_buffers = (ab_a, ab_b) => {
		return Buffer.concat([ab_a, ab_b], ab_a.length + ab_b.length);
	};
@end

