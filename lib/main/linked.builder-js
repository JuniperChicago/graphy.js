
@set ENV_NODE_JS true

@if ENV_BROWSER
	const D_UTF8_TEXT_ENCODER = new TextEncoder('utf-8');
@end


@macro constants()
	// for creating new prefixes
	const R_COMPRESS = /^(.*?)([^/#]*)$/;
@end


@macro as_autf8(str, nullify_var)
	@if ENV_BROWSER
		D_UTF8_TEXT_ENCODER.encode(@{str})
	@elseif ENV_NODE_JS
		Buffer.from(@{str})
	@end
	@if nullify_var
		;
		// free string to GC
		@{str} = null;
	@end
@end


@macro mk_uint_array(size, range)
	@{range} <= 0xff
		? new Uint8Array(@{size})
		: (@{range} <= 0xffff
			? new Uint16Array(@{size})
			: (@{range} <= 0xffffffff
				? new Uint32Array(@{size})
				: new Float64Array(@{size})))
@end



@macro string_to_buffer(str, buffer)
	let @{buffer};

	// find out-of-bound characters
	let a_oob_matches = @{str}.match(/[^\u0000-\u007f]/g);
	if(a_oob_matches) {
		// number of out-of-bound characters
		let n_oobs = a_oob_matches.length;

		// estimate utf8 length (add weighted average probability of exceeding 2 bytes)
		let n_utf8_len = @{str}.length + (n_oobs * 1.9395);

		// estimate utf16 length (add weighted average probability of exceeding 2 bytes)
		let n_utf16_len = (@{str}.length * 2) + (n_oobs * 1.8858);

		// encode in whichever probably saves more space
		@{buffer} = n_utf8_len <= n_utf16_len? encode_utf_8(@{str}): encode_utf_16(@{str});
	}
	// all characters can be encoded in utf8
	else {
		@{buffer} = encode_utf_8(@{str});
	}
@end
