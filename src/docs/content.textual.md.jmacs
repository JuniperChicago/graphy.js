@import './docs.jmacs'
@{api_title('Textual RDF Content Handlers')}
This documentation covers the following graphy packages:
 - N-Triples
   - reader: `@graphy/content.nt.read`
 - N-Quads
   - reader: `@graphy/content.nq.read`
 - Turtle
   - reader: `@graphy/content.ttl.read`
 - TriG
   - reader: `@graphy/content.trig.read`

----

## Contents
 - [A Note About Events](#note_events) -- two different styles for event binding
 - [Accessibility](#accessibility) -- all textual RDF content modules
 - [Verbs](#verbs) -- the module export functions under each content namespace
   - [`read`](#verb_read) -- for reading RDF from a string or stream
   - [`write`](#verb_write) -- for writing RDF using write event objects
 - [Classes](#classes)
 - [Events](#events) -- definitions for event interfaces
 - [Configs](#configs) -- definitions for config interfaces
 - [Interfaces](#interfaces) -- definitions for all other interfaces

<!--
- [`scan`](#verb_scan) -- for reading RDF from a string or stream using multiple threads
- [`scribe`](#verb_scribe) -- for writing RDF using Quad objects only
-->

----

<a name="note_events" />

#### A note about Events
These modules offer two distinct approaches to binding event listeners. The traditional `.on(...)` approach will allow you to attach event listeners on the `Transform` object that is returned by the module function. This style was popularized by node.js, however this actually does incur a non-trivial amount of overhead for setup, teardown, and emittance.

A sleeker alternative to the `.on(...)` approach is the *inline events* style. Simply provide a callback function for each event you want to attach a listener to at the time the module function is called, passing a direct reference to at most one callback function per event. This approach allows the module to bypass the `EventEmitter` methods and can result in slightly better performance; it is also more pleasant to look at. However, it might not be suitable for users who need the ability to add multiple event listeners, to remove listeners, or to add listeners at a later time.

See the [`read`](#verb_read) examples for a demonstration of the two styles of attaching event listeners.

----

<a name="accessibility" />

## Accessibility
The following code block demonstrates three *different* ways to access this module.
```js
// stand-alone readers
const nt_read = require('@graphy/content.nt.read');
const nq_read = require('@graphy/content.nq.read');
const ttl_read = require('@graphy/content.ttl.read');
const trig_read = require('@graphy/content.trig.read');

// readers via named access from the graphy 'super module'
const graphy = require('graphy');
const nt_read = graphy.content.nt.read;
const nq_read = graphy.content.nq.read;
const ttl_read = graphy.content.ttl.read;
const trig_read = graphy.content.trig.read;

// readers via Content-Type query from the graphy 'super module'
const graphy = require('graphy');
const nt_read = graphy.content('application/n-triples').read;
const nq_read = graphy.content('application/n-quads').read;
const ttl_read = graphy.content('text/turtle').read;
const trig_read = graphy.content('application/trig').read;

```

<!--

// stand-alone turbos
const nt_turbo = require('@graphy/content.nt.turbo');
const nq_turbo = require('@graphy/content.nq.turbo');
const ttl_turbo = require('@graphy/content.ttl.turbo');
const trig_turbo = require('@graphy/content.trig.turbo');

// turbos via the graphy 'super module'
const graphy = require('graphy');
const nt_turbo = graphy.content.nt.turbo;
const nq_turbo = graphy.content.nq.turbo;
const ttl_turbo = graphy.content.ttl.turbo;
const trig_turbo = graphy.content.trig.turbo;


// stand-alone writers
const nt_write = require('@graphy/content.nt.write');
const nq_write = require('@graphy/content.nq.write');
const ttl_write = require('@graphy/content.ttl.write');
const trig_write = require('@graphy/content.trig.write');

// writers via the graphy 'super module'
const graphy = require('graphy');
const nt_write = graphy.content.nt.write;
const nq_write = graphy.content.nq.write;
const ttl_write = graphy.content.ttl.write;
const trig_write = graphy.content.trig.write;

-->

----

<a name="datatypes" />

## Datatypes
The following section describes hinted formatting on ES primitives that are used throughout this document.

<!--
<a name="strings" />

### Strings:

<a name="#string_js-function-" />

 - `#string/js_function_*` -- a string that will be turned into a JavaScript function using `eval`, `new Function`, `new vm.Script`, or whatever else is appropriate depending on the environment. This is done in order to transmit the function between threads. If the library were to accept an actual function instead, it would require first serializing it into a `string` which introduces potential dangers such as externally scoped references, native code stringification, and so forth. 
   - > If you are developing in Sublime Text 3, it is recommended to use the [Ecmascript-Sublime](https://github.com/bathos/Ecmascript-Sublime) package to enable nested syntax highlighting on template literal strings for instances like this and a better highlighting experience all around ;)
 
<a name="#string_js-function-map" />

 - `#string/js-function-map` -- see [`@string/js-function-*`](#string_js-function-).
   - **signature:** `function(result_callback: callback(result: any))` : [`#config/read-no-input`](#config_read)

<a name="#string_js-function-reduce" />

 - `#string/js-function-reduce` -- see [`@string/js-function-*`](#string_js-function-).
   - **signature:** `function(result_a: any, result_b: any)` : `any`

-->

----

<a name="verbs" />

## Verbs
This section documents the 'verb' part of each content module. A 'verb' refers to the fact that the module's export is itself a function.
 - [read](#verb_read) -- read serialized RDF documents using a single thread.
 - [write](#verb_write) -- write serialized RDF data to an output destination in an event-driven manner using the elegant concise-struct language.

<!--
 - [turbo](#verb_turbo) -- read serialized RDF documents using multiple threads.
-->

----

<a name="verb_read" />

### read
Read RDF data (in other words, deserialize it) from a document given by an input stream, input string or via duplexing. Uses a single thread.

**Accessible via the following modules:**
 - N-Triples (.nt) -- `@graphy/content.nt.read`
 - N-Quads (.nq) -- `@graphy/content.nq.read`
 - Turtle (.ttl) -- `@graphy/content.ttl.read`
 - TriG (.trig) -- `@graphy/content.trig.read`

**Overloaded variants:**
 - `read([config: `[`#config/read-no-input`](#config_read-no-input)`])`
   - creates a new content reader that will act as a transform, accepting utf8-encoded strings on the writable side and outputting [Quads](core.data.factory#class-quad) on the readable side.
   - **returns** a [`new Transform<string, Quad>`](core.iso.stream#transform_string-writable_quad-readable)

 - `read(input_string: string[, config: `[`#config/read-no-input`](#config_read-no-input)`])`
   - shortcut for:
      ```js
      read(config)
        .end(input_string, 'utf-8');
      ```
   - equivalent to:
      ```js
      read({
        ...config,
        input: {string:input_string},
      });
      ```
   - **returns** a [`new Transform<string, Quad>`](core.iso.stream#transform_string-writable_quad-readable)
 
 - `read(input_stream: `[`ReadableStream<string>`](core.iso.stream#readable_string)`[, config: `[`#config/read-no-input`](#config_read-no-input)`])`
   - shortcut for:
      ```js
      input_stream
        .pipe(read(config));
      ```
   - equivalent to:
      ```js
      read({
        ...config,
        input: {stream:input_stream},
      });
      ```
   - **returns** a [`new Transform<string, Quad>`](core.iso.stream#transform_string-writable_quad-readable)

 - `read(config: `[`#config/read-with-input`](#config_read-with-input)`)`
   - creates a new content reader that will output [Quads](core.data.factory#class_quad).
   - **returns** a [`new Transform<string, Quad>`](core.iso.stream#transform_string-writable_quad-readable)

**Examples**:
```js
const nt_read = require('@graphy/content.nt.read');

// input string
nt_read('<a> <b> <c> .', {
    data(y_quad) {
        y_quad.predicate.value;  // 'b'
    },
});

// -----

// equivalent to above
nt_read({
    input: {
        string: '<a> <b> <c> .',
    },
    data(y_quad) {
        y_quad.predicate.value;  // 'b'
    },
});

// -----

// also equivalent to above
nt_read('<a> <b> <c> .')
    .on('data', (y_quad) => {
        y_quad.predicate.value;  // 'b'
    });

// -----

// input stream
let ds_input = fs.createReadStream('./input.nt');
nt_read(ds_input, {
    data(y_quad) { /* ... */ },
});

// -----

// equivalent to above
nt_read({
    input: {
        stream: fs.createReadStream('./input.nt'),
    },
    data(y_quad) { /* ... */ },
});

// -----

// also equivalent to above
nt_read(fs.createReadStream('./input.nt'))
    .on('data', () => { /* ... */ });

// -----

// no input given yet
let ds_reader = nt_read({
    data(y_quad) { /* ... */ },
});

// pipe in data later
fs.createReadStream('./input.nt').pipe(ds_reader);

// -----

// no input given yet
let ds_reader = nt_read({
    data(y_quad) { /* ... */ },
});

// write data later
ds_reader.write('<a> <b> <c> .');
```

----

<a name="verb_write" />

### write
Write RDF (in other words, serialize it) to a document for storage, transmission, etc. Uses a single thread.

**Accessible via the following modules:**
 - N-Triples (.nt) -- `@graphy/content.nt.write`
 - N-Quads (.nq) -- `@graphy/content.nq.write`
 - Turtle (.ttl) -- `@graphy/content.ttl.write`
 - TriG (.trig) -- `@graphy/content.trig.write`

**Overloaded variants:**
 - `write([config: `[`WriteConfig`](#config_write)`])`
   - creates a new content writer and returns a transform that operates in object mode on the writable side and emits utf8-encoded strings on the readable side. The types of objects it responds to on the writable side may depend on the capabilities of the format.
     - **returns** a [new `Transform<WritableDataEvent, string>`](#transform_writable-data-event-writable_string-readable)

**Example A**:
Convert a CSV document into an RDF Turtle document using a custom transform in a pipeline.
```js
@{cat('snippets/transform-csv.js')}
```

<br /><br />
Then, we can run the following command:
```sh
cat <<EOF | node snippets/transform-csv.js
> 1,Blake,Banana
> 2,Banana,Water Sunlight Soil
> EOF
```

<br /><br />
And get the output:
```turtle
@{exec('snippets/transform-csv.js', {
  input: [
    '1,Blake,Banana',
    '2,Banana,Water Sunlight Soil',
  ].join('\n'),
})}
```

----

<a name="events" />

## Event definitions

<a name="event_read" />

#### events **ReadEvents**
The definition for all possible events emitted during content reading. Please [see this note about events](#note_events) to understand how this definition applies to both the traditional `.on()`-style of event binding as well as the inline-style.

**Events:**
 - `ready()`
   - Gets called once the input stream is readable. If the input is a string, then this event gets called immediately.
 - `base(iri: string)`
   - Gets called once for each base statement as soon as it is parsed. `iri` is the full IRI of the new base.
   - *example:*
      ```js
      ttl_read('@base <http://example.org/vocabulary/> .', {
          base(p_iri) {
              p_iri;  // 'http://example.org/vocabulary/'
          },
      });
      ```
 - `prefix(id: string, iri: string)`
   - Gets called once for each prefix statement as soon as it is parsed. `id` will be the name of the prefix without the colon and `iri` will be the full IRI of the associated mapping.
   - *example:*
      ```js
      ttl_read('@prefix dbr: <http://dbpedia.org/resource/> .', {
          prefix(s_id, p_iri) {
              s_id;  // 'dbr'
              p_iri;  // 'http://dbpedia.org/resource/'
          },
      });
      ```
 - `data(quad: `[`Quad`](core.data.factory#class_quad)`)`
   - Gets called once for each triple/quad as soon as it is parsed.
   - *examples:*
      ```js
      // inline event style (less overhead)
      ttl_read('<#banana> a <#Fruit> .', {
          data(y_quad) {
              y_quad.predicate.value;  // 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'
          },
      });
      
      // attach event listener style (more overhead)
      let ds_read = ttl_read('<#banana> a <#Fruit> .');
      ds_read.on('data', (y_quad) => {
          y_quad.predicate.value;  // 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'
      });
      ```
 - `enter(graph: `[`Term`](core.data.factory#class_namednode)`)`
   - Gets called each time a graph block is entered as soon as the opening brace character `{` is read. `graph` will either be a [NamedNode](#namednode), [BlankNode](#blanknode) or [DefaultGraph](#defaultgraph).
   - *example:*
      ```js
      // only inspect triples within a certain graph
      let b_inspect = false;
      trig_read(ds_input, {
          enter(y_graph) {
              if(y_graph.value === 'http://target-graph') b_inspect = true;
          },
          exit(y_graph) {
              b_inpsect = false;
          },
          data(y_quad) {
              if(b_inspect) {  // much faster than comparing y_quad.graph to a string!
                  // do something with triples
              }
          },
      });
      ```
 - `exit(graph: `[`NamedNode`](core.data.factory#class_named-node)`)`
   - Gets called each time a graph block is exitted as soon as the closing brace character `}` is read.       `graph` will either be a [NamedNode](core.data.factory#class_named-node), [BlankNode](core.data.factory#class_blank-node) or       [DefaultGraph](core.data.factory#class_default-graph).
  - `progress(delta: integer)`
    - Gets called each time the reader has finished processing a chunk of data and is about to go asynchronous and wait for the next I/O event. `delta` will reflect the number of characters that were consumed from the input which resulted in a change to the reader's internal state (i.e., incomplete tokens must wait for next chunk to be terminated). This event offers a nice way to provide progress updates to the user, however this would require knowing ahead of time how many characters in total are contained by the input. This event also provides hints to resource-hungry applications when it might be an opportunistic time to perform synchronous tasks. This event will also be called right before the `eof()` event with a `delta` equal to `0`.
  - `error(err: Error)`
    - Gets called if an error occurs any time during the read process, including malformed syntax errors, unreadable inputs, and so forth. If an error does occur, no other events will be emitted after this one. If you do not include an error event handler, the parser will throw the error.
  - `eof(prefixes: `[`#hash/prefix-mappings`](core.data.factory#hash_prefix-mappings)`)`
    - Gets called once the 'end-of-file' has been reached on the input and all other events have been emitted, except for the final `end()` event to indicate the the output stream is done. This event is useful for grabbing the final map of `prefixes`.
  - `end()`
    - Gets called once at the very end of the input. It indicates that the input stream (if any) has been closed and no more events will be emitted.


<a name="events_write" />

#### events **WriteEvents**
The definition for all possible events emitted during content writing. Please [see this note about events](#note-events) to understand how this definition applies to both the traditional `.on()`-style of event binding as well as the inline-style.

**Events:**
 - ... [see those inherited from @nodejs/stream.Transform](https://nodejs.org/api/stream.html#stream_class_stream_transform) (i.e., events from both @nodejs/stream.Readable and @nodejs/stream.Writable)


<!--

----

<a name="classes" />

## Classes

<a name="class_concise-quad-writer" />

### class **ConciseQuadWriter** _extends_ [Transform](core.iso.stream#transform)&lt;[#hash/c4](concise#c4-hash), string&gt;
Acts as an object-writable, string-readable Transform for serializing RDF quads from memory to an output destination. Expects objects on the writable side to be of type [#hash/c4](concise#c4-hash).

**Construction:**
See [`write`](#verb_write).

**Methods:**
 - ... [see those inheritted from Transform](core.iso.stream#transform)
 - `graph(graph: `[`NamedNode`](core.data.factory#class_named-node)`)` -- creates an instance of a [`ConciseTripleWriter`](#class_triple-writer) that allows for writing multiple statements which belong to the same given `graph`.
   - **returns** a [new `ConciseTripleWriter`](#class_concise-triple-writer)
 - `subject(subject: `[`NamedNode`](core.data.factory#class_named-node)`)` -- creates an instance of a [`ConcisePairWriter`](#class_pair-writer) that allows for writing multiple statements which belong to the same given `subject` under the default graph.
   - **returns** a [new `ConcisePairWriter`](#class_concise-pair-writer)

<a name="class_concise-triple-writer" />

### class **ConciseTripleWriter** _extends_ [Transform](core.iso.stream#transform)&lt;[#hash/c3](concise#c3-hash), string&gt;
Acts as an object-writable, string-readable Transform for serializing RDF triples from memory to an output destination. Expects objects on the writable side to be of type [#hash/c3](concise#c3-hash).

**Construction:**
See [`write`](#verb_write).

**Methods:**
 - ... [see those inheritted from Transform](core.iso.stream#transform)
 - `subject(subject: `[`NamedNode`](core.data.factory#class_named-node)`)` -- creates an instance of a [`ConcisePairWriter`](#class_concise-pair-writer) that allows for writing multiple statements which belong to the same given `subject` under the default graph.
   - **returns** a [new `ConcisePairWriter`](#class_concise-pair-writer)


<a name="class_concise-pair-writer" />

### class **ConcisePairWriter** _extends_ [Transform](core.iso.stream#transform)&lt;[#hash/c2](concise#c2-hash), string&gt;
Acts as an object-writable, string-readable Transform for serializing RDF quads from memory to an output destination. Expects objects on the writable side to be of type [#hash/c2](concise#c2-hash).

**Methods:**
 - ... [see those inheritted from Transform](core.iso.stream#transform)
 - `predicate(predicate: `[`NamedNode`](core.data.factory#class_namednode)`)` -- creates an instance of a [`ConciseObjectWriter`](#class_concise-object-writer) that allows for writing multiple statements which belong to the same given `predicate` under the current graph and subject.
   - **returns** a [new `ConciseObjectWriter`](#class_concise-object-writer)


<a name="class_concise-object-writer" />

### class **ConciseObjectWriter** _extends_ [Transform](core.iso.stream#transform)&lt;[#hash/c2](concise#c2-hash), string&gt;
Acts as an object-writable, string-readable Transform for serializing RDF quads from memory to an output destination. Expects objects on the writable side to be of type [#hash/c2](concise#c2-hash).

**Methods:**
 - ... [see those inheritted from Transform](core.iso.stream#transform)
 - `add(predicate: `[`NamedNode`](core.data.factory#class_namednode)`)` -- creates an instance of a [`ConciseObjectWriter`](#class_concise-object-writer) that allows for writing multiple statements which belong to the same given `predicate` under the current graph and subject.
   - **returns** a [new `ConciseObjectWriter`](#class_concise-object-writer)

<!--

<a name="class_rdfjs-quad-writer" />

### class **RDFJSQuadWriter** _extends_ [Transform](core.iso.stream#transform)&lt;[@RDFJS/Quad](http://rdf.js.org/#quad-interface), string&gt;]
Contains methods for serializing RDF quads from memory to an output destination.

**Construction:**
See [`write`](#verb_write).

**Methods:**
 - `async add(quads: `[`#hash/c4`](concise#struct_c4)`)` -- serialize 
   - **resolves to** a [`WriteReport`](#class_writereport)
 - `async add(quad: `[`@RDFJS/Quad`](http://rdf.js.org/#quad-interface)`)`
   - **resolves to** a [`WriteReport`](#class_writereport)
 - `graph(graph: `[`NamedNode`](core.data.factory#class_namednode)`)` -- creates an instance of a [`TripleWriter`](#class_triplewriter) that allows for writing multiple statements which belong to the same given `graph`.
   - **returns** a [new `TripleWriter`](#class_triplewriter)
 - `subject(subject: `[`NamedNode`](core.data.factory#class_namednode)`)` -- creates an instance of a [`PairWriter`](#class_pairwriter) that allows for writing multiple statements which belong to the same given `subject` under the default graph.
   - **returns** a [new `PairWriter`](#class_pairwriter)


<a name="class_generic-quad-writer" />

### class **GenericQuadWriter** _extends_ [Transform&lt;Quad | @RDFJS/Quad, string&gt;]()
Contains methods for serializing RDF quads from memory to an output destination.

**Construction:**
See [`write`](#verb_write).

**Methods:**
 - `async add(quads: `[`#hash/concise-quads`](concise#c4_hash)`)` -- serialize 
   - **resolves to** a [`WriteReport`](#class_writereport)
 - `async add(quad: `[`@RDFJS/Quad`](http://rdf.js.org/#quad-interface)`)`
   - **resolves to** a [`WriteReport`](#class_writereport)
 - `graph(graph: `[`NamedNode`](core.data.factory#class_namednode)`)` -- creates an instance of a [`TripleWriter`](#class_triplewriter) that allows for writing multiple statements which belong to the same given `graph`.
   - **returns** a [new `TripleWriter`](#class_triplewriter)
 - `subject(subject: `[`NamedNode`](core.data.factory#class_namednode)`)` -- creates an instance of a [`PairWriter`](#class_pairwriter) that allows for writing multiple statements which belong to the same given `subject` under the default graph.
   - **returns** a [new `PairWriter`](#class_pairwriter)

<a name="class_triple-writer" />

### class **TripleWriter**
Contains methods for serializing RDF triples from memory to an output destination.

**Construction:**
See [`write`](#verb_write) and [`QuadWriter#graph`](#class_quadwriter).

**Methods:**
 - `async add(triples: `[`#hash/concise-triples`](concise#c3-hash)`)`
   - **resolves to** a [`WriteReport`](#class_writereport)
 - `async add(quad: `[`@RDFJS/Triple`](http://rdf.js.org/#triple-interface)`)`
   - **resolves to** a [`WriteReport`](#class_writereport)
 - `subject(subject: `[`NamedNode`](core.data.factory#class_namednode)`)` -- creates an instance of a [`PairWriter`](#class_pairwriter) that allows for writing multiple statements which belong to the same given `subject` under the default graph.
   - **returns** a [new `PairWriter`](#class_pairwriter)

-->

----

<a name="configs" />

## Configs

<a name="config_read-no-input" />

#### config **read-no-input** _inlines_ [ReadEvents](#events_read)
An interface that defines the config object passed to a content reader.

**Options:**
 - ... [see those inlined from ReadEvents](#events_read)
 - `baseUri | baseURI`: `string` -- sets the starting base URI for the RDF document.
 - `validate` : `boolean=false` -- whether or not to validate the contents of tokens, such as checking for invalid characters in IRIs, literals, and so on. The stream will emit an `'error'` event if an invalid token is encountered. Enabling validation incurs a performance cost, so each reader defaults to `false`. 
 - `maxTokenLength` : `number=2048` -- defines the maximum number of characters to expect of any token other than a quoted literal. This option only exists to prevent invalid input from endlessly consuming the reader when using a stream as input. By default, this value is set to **2048**, which is more than the recommended maximum URL length. However, you may wish to set this value to `Infinity` if you never expect to encounter invalid syntax on the input stream.
 - `maxStringLength` : `boolean=false` -- defines the maximum number of characters to expect of any quoted literal. This option only exists to prevent invalid input from endlessly consuming the reader (such as a long-quoted literal `""" that never ends...`) when using a stream as input. By default, this value is set to **65536** characters. However, you may set this value to `Infinity` if you never expect to encounter invalid syntax on the input stream.

<a name="config_read-with-input" />

#### config **read-with-input** _extends_ [#config/read-no-input](#config_read-no-input)
      
**Options:**
 - ... [see those inheritted from #config/read-no-input](#config_read-no-input)

**Required:**
 - `input` : [`UseInputString`](#interface_use-input-string)` | `[`UseInputStream`](#interface_use-input-stream)


<a name="config_write" />

#### config **write** _inlines_ [WriteEvents](#events_write)
An interface that defines the config object passed to a content writer.

**Options:**
 - ... [see those inlined from WriteEvents](#events_write)
 - `prefixes` : [`#hash/prefix-mappings`](core.data.factory#hash_prefix-mappings) -- prefix mappings to use in order to expand the concise-term strings within concise-quad hashes as they are written. These prefixes will also be used to create prefix statements and terse terms on the output stream whenever possible (e.g., for Turtle and TriG documents).


<a name="config_comment" />

#### config **comment**
 - _required properties:_
   - `.contents`: `string` -- the contents of the comment
 - _optional properties:_
   - `.width`: `int` -- if specified, breaks comments longer than the given `width` onto multiple lines.


<!-- - `coercions` : [`#map/object-coercions`](#map-objectcoercions) -- allows for extending the built-in mappings for coercing objects that are an `instanceof` some class or function to their RDF representation. For example, an instance of the `Date` object will -->


<!--

<a name="config_turbo-no-input" />

#### config **TurboConfig_WithInput** _inlines_ [TurboEvents](#events-turbo)
 
**Required:**
 - `input` : [`#struct/input-file`](#struct_input-file)` | `[`#struct/input-url`](#struct_input-url)
 - `map` : [`#string/js_function_map`](#string-js_function_map)
   - **signature:** `function(result_callback: callback(result: any))` : [`ReadConfig_NoInput`](#config_read)
   - This string will be copied and given to each worker thread where it will be turned into a new function in order to build the reader config as well as to distill the results that you are interested in obtaining. The function should accept a single argument, a callback function `result_callback` which expects to be called once the worker thread is ready to pass its results back to the main thread.
 - `reduce` : [`#string/js_function_reduce`](#string-js_function_reduce)
   - **signature:** `function(result_a: any, result_b: any)` : `any`
   - This string will be copied, turned into a new function, and used each time the worker group needs to merge the results from two different workers. The function should return a value that merges the relevant information from `result_a` and `result_b`. This merge result will likely get used again to merge with another result.

**Examples:**
```js
const nt_turbo = require('@graphy/content.nt.turbo');

(async function() {
    // count the total number of triples in a file
    let c_total = await nt_turbo({
        input: {
            file: '../data/input/master-incomplete.nt',
        },
        map: /* syntax: js */ `
            // this function will be created and called in each worker thread
            function(fk_result) {
                let c_triples = 0;
                
                // return the config for a new reader
                return {
                    data(y_quad) {
                        c_triples += 1;
                    },
                    // once the reader has finished its share of the document
                    end() {
                        // callback the result handler with our result value
                        fk_result(c_triples);
                    },
                };
            }`,
        reduce: /* syntax: js */ `
            // take two results and merge them into one result
            function(c_a, c_b) {
                return c_a + c_b;
            }`,
    });

    // this is the final result
    console.log(c_total);
})();
```

-->

<a name="interfaces" />

## Interfaces


<a name="interface_input-string" />

#### interface **UseInputString**
Indicates a utf8-encoded string to use as input to a reader.

 - _required properties:_
   - `.string`: `string`


<a name="interface_input-stream" />

#### interface **UseInputStream**
Indicates a readable stream to use as input to a reader.

 - _required properties:_
   - `.stream`: [`ReadableStream<string>`](core.iso.stream#readable-string)


<a name="interface_writable-data-event" />

#### interface **WritableDataEvent**
An object that describes an event of writable RDF data (including metadata and directives such as prefix mappings, comments, etc.).

 - _required properties:_
   - `.type`: `string` -- the type of event this object represents, see below
   - `.value`: `any` -- the value of the object
 - The string given for `.type` should be one of the following:
   - `'array'` -- write a series of data events (useful for aggregating events synchronously before going async).
      - *expects* `.value` to be an `Array<`[`WritableDataEvent`](#interface_writable-data-event)`>`.
   - `'c3'` -- write a set of triples to the output.
      - *expects* `.value` to be a [concise triple hash](concise#hash_c3)
   - `'c4'` -- write a set of quads to the output.
      - *expects* `.value` to be a [concise quad hash](concise#hash_c4)
   - `'triple'` -- write a single RDFJS-compatible triple to the output.
      - *expects* `.value` to be a [Triple](core.data.factory#class_triple)
   - `'quad'` -- write a single RDFJS-compatible quad to the output.
      - *expects* `.value` to be a [Quad](core.data.factory#class_quad)
   - `'base'`-- sets or updates the current base URI used for relative IRI resolution. Will also cause the writer to output a `@base` statement if supported by the underlying RDF format.
      - *expects* `.value` to be an IRI `string`.
   - `'prefixes'` -- updates the current prefix mappings which are used to expand CURIEs found in following concise triple (c3) and concise quad (c4) hashes. Will also cause the writer to output the given prefix mappings if supported by the underlying RDF format.
      - *expects* `.value` to be a [#hash/prefix-mappings](core.data.factory#hash_prefix-mappings)
   - `'comment'` -- if the underlying RDF format supports it, a comment will be written to the output document, otherwise this has no effect.
      - *expects* `.value` to be one of the following:
         - `string` -- a single-line comment
         - [#config/comment](#config_comment) -- enhanced comment 
