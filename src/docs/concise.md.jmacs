@import './docs.jmacs'
@.{
  const factory = require(`@${process.env.GRAPHY_CHANNEL || 'graphy'}/core.data.factory`);
  const h_prefixes = {xsd:'http://www.w3.org/2001/XMLSchema#', dbr:'http://dbpedia.org/resource/'};
}
@{api_title('Concise Terms, Triples and Quads')}
This document describes a language for concisely expressing RDF data from within a JavaScript programming environment, allowing for a convenient technique of mixing in data from live variables and objects to create RDF quads and RDF terms such as named nodes, blank nodes, and literals.

<a name="string_c1" />

### `#string/c1` -- Concise Term String
The concise term string defines a syntax that allows developers to quickly create RDF terms such as named nodes, blank nodes, and literals from a simple string. The syntax should be familiar to those who use Turtle.
 
The first character of the string dictates what type of Term it is:
 - `>` -- NamedNode (the absolute IRI)
 - `_` -- BlankNode
 - `@` -- Literal w/ language tag
 - `^` -- Literal w/ datatype
 - `"` -- plain Literal
 - `` ` `` *(backtick)* -- directive
 - *else* -- NamedNode (prefixed name)

#### Named Nodes: No Closing Brackets
Notice that the first character to indicate an absolute IRI is the right-angle bracket `>`. This was selected intentionally to remind you that the format does not have a closing bracket for absolute IRIs.

```js
let p_iri = 'http://dbpedia.org/resource/9/11_Memorial_(Arizona)';
let yt_node = factory.c1('>'+p_iri);
```

#### Blank Nodes: When to Use Them
There's not much need to create blank nodes using concise-term strings since you can implicitly create them using [concise triple](#hash/c3) and [concise quad](#hash/c4) hashes. However, if you need to create new triples where the subject is a blank node, or need to use labeled blank nodes, this syntax will allow you to create them explicitly.

```js
let a_triples = [...factory.c3({
    '_:b1': {
        // usual blank node label
        '>http://ex.org/dislikes': '_:b2',

        // some custom blank node label
        '>http://ex.org/pointsTo': '_:someLabeledBlankNode',

        // automatically creates a unique labeled blank node (using uuidv4)
        '>http://ex.org/unique': '_:',

        // creates anonymous blank node
        '>http://ex.org/anonymous': {},

        // creates anonymous blank node with its own triple(s)
        '>http://ex.org/likes': {
            a: '>http://ex.org/AnonymousBlankNode',
        },
    },
})];
```


#### Literals: No Escaping Needed
Since only one term can be expressed in a string, the syntax does not need to have delimiters for the start or end of certain sequences and so the contents of a Literal do not need to be escaped. For example, a plain RDF literal can be expressed like so:

```js
let s_expression = 'Hello World!';
let yt_greeting = factory.c1('"'+s_expression);
```

Here, the double quote at position `0` indicates that this is a plain literal, and that the contents follow (until the end of the string). If you wanted to add quote characters to the contents of the RDF literal, it would simply look like this:

```js
let s_expression = '"Hello World!"';
let yt_greeting = factory.c1('"'+s_expression);
```

#### Prefixed Names: All Characters Allowed
The 'suffix' of prefixed names may contain any character, such as `/`, `.`, `,`, and so on, without having to worry about the way it is serialized to the output destination. Invalid IRI characters (`[#x00-#x20<>"{}|^`\]`) will be automatically converted to URI escape sequences.

```js
let h_prefixes = {dbr:'http://dbpedia.org/resource/'};
let yt_node = factory.c1('dbr:9/11_Memorial_(Arizona)', h_prefixes);
yt_node.value;  // '@{factory.c1('dbr:9/11_Memorial_(Arizona)', h_prefixes).value}'
```

#### Directives
Directives allow for special events to be passed to the output serializer at a given location within the document, such as for the insertion of comments and newlines. See [factory.comment](core.data.factory#function_comment) and [factory.newlines](core.data.factory#function_comment) for creating directive strings which can be used as keys in concise triples and concise quads hashes.


#### Grammar


| State            | Production                                           |
| ---------------- | ---------------------------------------------------- |
| Term             | `NamedNode | BlankNode | Literal | Directive`        |
| NamedNode        | `AbsoluteIRI` | `PrefixedName` | `TypeAlias`         |
| AbsoluteIRI      | `'>' .*`                                             |
| PrefixedName     | `([^_:@"^\`][^:]*)? ':' .*`                          |
| TypeAlias        | `'a'`                                                |
| BlankNode        | `'_' ':' .*`                                         |
| Literal          | `PlainLiteral | DatatypedLiteral | LanguagedLiteral` |
| PlainLiteral     | `'"' .*`                                             |
| DatatypedLiteral | `'^' NamedNode PlainLiteral`                         |
| LanguagedLiteral | `'@' [a-zA-Z0-9-]+ PlainLiteral`                     |
| Directive        | `` '`' '[' uuid_v4 ']' JSON ``                       |


----

## Hash Interfaces:
A 'hash' refers to a dictionary (a plain ES object) `value` with enumerable properties (which themselves may or may not be defined in `value`'s prototype chain). The following section documents the implications of the key and value types.


<a name="hash_c4" />

### `#hash/c4` -- Concise Quads Hash
A concise quads hash describes a plain object whose keys represent the *graph* of a set of quads, and whose values are [concise triple hashes](#hash_c3), which represent the subjects, predicates and objects, collections, or nested blank nodes related to the graph/subject/predicate combinations in a tree-like structure.

**Example:**
```js
@{cat('snippets/concise-quads.js')}
```

**Outputs:**
```turtle
@{exec('snippets/concise-quads.js')}
```

----

<a name="hash_c3" />

### `#hash/c3` -- Concise Triples Hash
A concise triples hash describes a plain object whose keys represent the *subject* of a set of triples, and whose values are [concise pair hashes](#hash_c2), which represent the objects, collections, or nested blank nodes related to the subject/predicate combination in a tree-like structure.

**Example:**
```js
@{cat('snippets/concise-triples.js')}
```

**Outputs:**
```turtle
@{exec('snippets/concise-triples.js')}
```

----

<a name="hash_c2" />

### `#hash/c2` -- Concise Pairs Hash
A concise pairs hash describes a plain object whose keys represent the *predicate* of a set of predicate/object pairs, and whose values are [ConciseObjects](#value_concise-object), which represent the objects, collections, or nested blank nodes related to the predicate in a tree-like structure.

----

## Values 

<a name="value_concise-object" />

### value **ConciseObject**
A value that must be one of the following types:
 - [`#string/c1`](#string_c1) -- represents a single RDF term such as a named node, blank node, or literal.
 - [`#hash/c2`](#hash_c2) -- such that `value.constructor === Object`; represents an anonymous nested blank node, allowing you to continue nesting subtrees in the same object literal.
 - `Array<`[`ConciseObjectItem`](#value_concise-object-item)`>` -- represents a list of objects, each one belonging to the same graph, subject, and predicate.
 - `number` -- represents an RDF literal with some numeric datatype; calls [`factory.number()`](core.data.factory#function_number) on `value` to determine the datatype IRI.
 - [GenericTerm](core.data.factory#class_generic-term) | [@RDFJS/Term](https://rdf.js.org/#term-interface) -- a single RDF term
 - _overridable_ `Date` -- represents an RDF literal with datatype `xsd:dateTime`; calls [`factory.dateTime()`](core.data.factory#function_date-time) on `value` to handle conversion.
@.{/* - *other* -- providers allow for coercions */}


<a name="value_concise-object-item" />

### value **ConciseObjectItem** _extends_ [ConciseObject](#value_concise-object)
A value that expects the same types as [ConciseObject](#value_concise-object) with one overriding feature:
 - `Array<`[`ConciseObject`](#value_concise-object)`>` -- represents an [RDF collection](https://www.w3.org/TR/rdf11-mt/#rdf-collections) whereby each element in the array is transformed into an ordered linked-list structure using the provider's configurable `.first` and `.rest` predicates (which default to `rdf:first` and `rdf:rest`).


----


