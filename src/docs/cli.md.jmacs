@import './docs.jmacs'
@.{
  const factory = require(`@${process.env.GRAPHY_CHANNEL || 'graphy'}/core.data.factory`);
  const h_prefixes = {xsd:'http://www.w3.org/2001/XMLSchema#', dbr:'http://dbpedia.org/resource/'};
}
# [Â« Home](https://graphy.link/) / Command Line Interface

<div class="larger">
  This document describes the command-line interface for the binary <code>graphy</code> available from npm.
</div>

### `npm i -g graphy`

<div class="larger">
  <a href="cli.examples">See some examples here.</a>
</div>

<br />
## Internal Pipeline
The `graphy` CLI works by pushing RDF data through a series of [internal transforms](#commands), starting with a single input on `stdin` (or instead, [multiple inputs](#inputs)) and ending with a single output on `stdout`. This internal pipeline feature allows for efficient, high-bandwidth transformation of RDF data.


### `Usage: graphy COMMAND [--pipe COMMAND]*`

<br />

## Commands
@.{/*
 - `content TYPE VERB [OPTIONS]`
   - select a content handler command by its content-type and verb.
   - **Type:** `-t, --type`
     - argument to [super.content()](super#function_content).
   - **Verb:** `-v, --verb`
     - which verb to access on the given content handler, e.g., `read`, `write`, etc.
   - *examples:*
     ```bash
     $ graphy content --type=text/turtle --verb=read < input.ttl

     $ graphy content -t application/n-triples -v read < input.nt
     ```
*/}

<a name="command_content-format-read" />

### [`content.FORMAT.read`](#command_content-format-read)` [OPTIONS]`
   - `N-to-N<`[`StringStream`](#class_string-stream)`, `[`QuadStream`](#class_quad-stream)`>` -- maps 1 or more utf8-encoded input streams into 1 or more object output streams of RDF [Quad](core.data.factory#class_quad) objects.
   - **Format:**
     - `nt` -- read N-Triples document(s)
     - `nq` -- read N-Quads document(s)
     - `ttl` -- read Turtle document(s)
     - `trig` -- read TriG document(s)
   - **Options:**
     - `-b, --base, --base-uri` -- sets the starting base URI for the RDF document, [see more here](content.textual#config_read-no-input).
     - `-v, --validate` -- whether or not to perform validation on tokens, [see more here](content.textual#config_read-no-input).
     - `-s, --subject SUBJECT_FILTER` -- filter quads by only allowing those that match the given subject. `SUBJECT_FILTER` must be a [concise-term string](concise#string_c1).
     - `-p, --predicate PREDICATE_FILTER` -- filter quads by only allowing those that match the given predicate. `PREDICATE_FILTER` must be a [concise-term string](concise#string_c1).
     - `-o, --object OBJECT_FILTER` -- filter quads by only allowing those that match the given object. `OBJECT_FILTER` must be a [concise-term string](concise#string_c1).
     - `-g, --graph GRAPH_FILTER` -- filter quads by only allowing those that match the given graph. `GRAPH_FILTER` must be a [concise-term string](concise#string_c1).
     - `-S, --not-subject NOT_SUBJECTS_FILTER+` -- filter quads by allowing any that **do not match** the given subject(s). `NOT_SUBJECTS_FILTER+` must be 1 or more [concise-term strings](concise#string_c1).
     - `-P, --not-predicate NOT_PREDICATE_FILTER+` -- filter quads by allowing any that **do not match** the given predicate(s). `NOT_PREDICATES_FILTER+` must be 1 or more [concise-term strings](concise#string_c1).
     - `-O, --not-object NOT_OBJECT_FILTER+` -- filter quads by allowing any that **do not match** the given object(s). `NOT_OBJECTS_FILTER+` must be 1 or more [concise-term strings](concise#string_c1).
     - `-G, --not-graph NOT_GRAPH_FILTER+` -- filter quads by allowing any that **do not match** the given graph(s). `NOT_GRAPHS_FILTER+` must be 1 or more [concise-term strings](concise#string_c1).
   - _examples:_
     ```bash
     # validate an N-Triples document
     $ graphy content.nt.read --validate < input.nt > /dev/null

     # print line-delimited JSON of quads in N-Quads document
     $ graphy content.nq.read < input.nq

     # validate a Turtle document
     $ graphy content.ttl.read -v < input.ttl > /dev/null

     # print line-delimited JSON of quads in TriG document while validating it
     $ graphy content.trig.read -v < input.trig

     # filter by subject: 'dbr:Banana_split' using prefix mappings embedded in document
     $ curl http://dbpedia.org/data/Banana.ttl | graphy content.ttl.read -s 'dbr:Banana_split'

     # filter by predicate: 'rdf:type' alias
     $ curl http://dbpedia.org/data/Banana.ttl | graphy content.ttl.read -p 'a'

     # select quads that *do not have* the predicate: 'owl:sameAs' nor `dbo:wikiPageRedirects`
     $ curl http://dbpedia.org/data/Banana.ttl | graphy content.ttl.read -P 'owl:sameAs' 'dbo:wikiPageRedirects'

     # filter by object: '"Banana"@en'
     $ curl http://dbpedia.org/data/Banana.ttl | graphy content.ttl.read -o '@en"Banana'

     # filter by graph using absolute IRI ref
     $ curl http://dbpedia.org/data/Banana.ttl | graphy content.ttl.read -g '>http://ex.org/some-absolute-graph-iri'
     ```

<a name="command_content-format-write" />

### [`content.FORMAT.write`](#command_content-format-write)` [OPTIONS]`
   - `N-to-1<`[`WritableDataEventStream`](#class_writable-data-event-stream)`, `[`StringStream`](#class_string-stream)`>` -- maps 1 or more object input streams of [WritableDataEvent](content.textual#interface_writable-data-event) objects into 1 utf8-encoded output stream.
   - **Format:**
     - `nt` -- write an N-Triples document
     - `nq` -- write an N-Quads document
     - `ttl` -- write a Turtle document
     - `trig` -- write a TriG document
   - **Options:**
     - _none_
   - _examples:_
     ```bash
     # convert a Turtle document into N-Triples
     $ cat input.ttl | graphy content.ttl.read \
         --pipe content.nt.write > output.nt

     # convert a TriG document into N-Quads
     $ cat input.trig | graphy content.trig.read \
         --pipe content.nq.write > output.nq

     # convert an N-Triples document into Turtle
     $ cat input.nt | graphy content.nt.read \
         --pipe content.ttl.write > output.ttl

     # convert an N-Quads document into TriG
     $ cat input.nq | graphy content.nq.read \
         --pipe content.trig.write > output.trig
     ```

<a name="command_util-dataset-tree" />

### [`util.dataset.tree`](#command_util-dataset-tree)` [OPTIONS] [SUBCOMMAND]`
   - use the [DatasetTree](util.dataset.tree) package to perform set algebra or simply to remove duplicates from a single data source.
   - **Subcommands:**
     - ` ` -- _(no command)_
       - `N-to-N<`[`QuadStream`](#class_quad-stream)`, `[`AnyDestination`](#class_any-destination)`>` -- maps 1 or more object input streams of [Quad](core.data.factory#class_quad) objects into 1 or more object output streams of [Quad](core.data.factory#class_quad) objects, or [WritableDataEvent](content.textual#interface_writable-data-event) objects, depending on the capabilities of the destination stream(s).
       - This transformation puts each dataset into its own tree, effectively removing duplicate quads and organizing quads into a tree of `graph --> subject --> predicate --> object`. [See example](#example_pretty-print).
     - `-z, --canonicalize`
       - `N-to-N<`[`QuadStream`](#class_quad-stream)`, `[`AnyDestination`](#class_any-destination)`>` -- maps 1 or more object input streams of [Quad](core.data.factory#class_quad) objects into 1 or more object output streams of [Quad](core.data.factory#class_quad) objects, or [WritableDataEvent](content.textual#interface_writable-data-event) objects, depending on the capabilities of the destination stream(s).
       - This transformation puts each dataset into its own tree, effectively removing duplicate quads and organizing quads into a tree of `graph --> subject --> predicate --> object`. [See example](#example_pretty-print).
       - _example:_
         ```bash
         # compute the isomorphic difference between two files
         $ graphy content.ttl.read \
             --pipe util.dataset.tree --canonicalize \  # first canonicalize each input
             --pipe util.dataset.tree --difference \  # then compute their difference
             --pipe content.ttl.write \
             --inputs a.ttl b.ttl \
             > canonical-difference.ttl
         ```
     - `-u, --union`
       - `N-to-1<`[`QuadStream`](#class_quad-stream)`, `[`AnyDestination`](#class_any-destination)`>` -- accepts 1 or more object input streams of [Quad](core.data.factory#class_quad) objects, performs the union of all datasets, and then pipes the result into 1 object output stream of [Quad](core.data.factory#class_quad) objects, or [WritableDataEvent](content.textual#interface_writable-data-event) objects, depending on the capabilities of the destination stream.
       - Performs the union of all inputs.
       - _example:_
         ```bash
         # perform a union on all *.ttl files inside `data/` directory
         $ graphy content.ttl.read \
             --pipe util.dataset.tree --union \
             --pipe content.ttl.write \
             --inputs input/*.ttl \
             > union.ttl
         ```
     - `-i, --intersection`
       - `N-to-1<`[`QuadStream`](#class_quad-stream)`, `[`AnyDestination`](#class_any-destination)`>` -- accepts 1 or more object input streams of [Quad](core.data.factory#class_quad) objects, performs the intersection of all datasets, and then pipes the result into 1 object output stream of [Quad](core.data.factory#class_quad) objects, or [WritableDataEvent](content.textual#interface_writable-data-event) objects, depending on the capabilities of the destination stream.
       - Performs the intersection of all inputs.
       - _example:_
         ```bash
         # perform an intersection on all *.ttl files inside `data/` directory
         $ graphy content.ttl.read \
             --pipe util.dataset.tree --intersection \
             --pipe content.ttl.write \
             --inputs input/*.ttl \
             > intersection.ttl
         ```
     - `-m, --minus, --subtraction`
       - `2-to-1<`[`QuadStream`](#class_quad-stream)`, `[`AnyDestination`](#class_any-destination)`>` -- expects exactly 2 input streams of [Quad](core.data.factory#class_quad) objects, performs the subtraction of the second input from the first, and then pipes the result into 1 object output stream of [Quad](core.data.factory#class_quad) objects, or [WritableDataEvent](content.textual#interface_writable-data-event) objects, depending on the capabilities of the destination stream.
       - Subtracts the second input from the first.
       - _example:_
         ```bash
         # perform an intersection on all *.ttl files inside `data/` directory
         $ graphy content.ttl.read \
             --pipe util.dataset.tree --minus \
             --pipe content.ttl.write \
             --inputs union.ttl input/dead.ttl \
             > leftover.ttl
         ```
     - `-d, --diff, --difference`
       - `2-to-1<`[`QuadStream`](#class_quad-stream)`, `[`AnyDestination`](#class_any-destination)`>` -- expects exactly 2 input streams of [Quad](core.data.factory#class_quad) objects, computes the difference between the two inputs, and then pipes the result into 1 object output stream of [Quad](core.data.factory#class_quad) objects, or [WritableDataEvent](content.textual#interface_writable-data-event) objects, depending on the capabilities of the destination stream.
       - Computes the difference between the two inputs.
       - _example:_
         ```bash
         # compute the difference between `original.ttl` and `modified.ttl`
         $ graphy content.ttl.read \
             --pipe util.dataset.tree --difference \
             --pipe content.ttl.write \
             --inputs original.ttl modified.ttl \
             > difference.ttl
         ```
     - `-e, --equals`
       - `2-to-1<`[`QuadStream`](#class_quad-stream)`, `[`ResultValueStream`](#class_result-value-stream)`<boolean>>` -- expects exactly 2 input streams of [Quad](core.data.factory#class_quad) objects, tests them for strict equality, and then pipes the boolean result value into 1 output stream.
       - Tests for strict equality between the two inputs.
       - _example:_
         ```bash
         # test if `before.ttl` and `after.ttl` are strictly equal
         $ graphy content.ttl.read \
             --pipe util.dataset.tree --equals \
             --inputs before.ttl after.ttl

         # test if `before.ttl` and `after.ttl` are isomorphically equivalent
         $ graphy content.ttl.read \
             --pipe util.dataset.tree --canonicalize \
             --pipe util.dataset.tree --equals \
             --inputs before.ttl after.ttl
         ```
     - `-j, --disjoint`
       - `2-to-1<`[`QuadStream`](#class_quad-stream)`, `[`ResultValueStream`](#class_result-value-stream)`<boolean>>` -- expects exactly 2 input streams of [Quad](core.data.factory#class_quad) objects, tests them for strict disjointess, and then pipes the boolean result value into 1 output stream.
       - Tests for strict disjointess between the two inputs.
       - _example:_
         ```bash
         # test if `apples.ttl` and `oranges.ttl` are strictly disjoint
         $ graphy content.ttl.read \
             --pipe util.dataset.tree --disjoint \
             --inputs apples.ttl oranges.ttl
         ```
     - `-c, --contains`
       - `2-to-1<`[`QuadStream`](#class_quad-stream)`, `[`ResultValueStream`](#class_result-value-stream)`<boolean>>` -- expects exactly 2 input streams of [Quad](core.data.factory#class_quad) objects, tests if the first input strictly contains the second, and then pipes the boolean result value into 1 output stream.
       - Tests if the first input strictly contains the second.
       - _example:_
         ```bash
         # test if `superset.ttl` strictly contains `subset.ttl`
         $ graphy content.ttl.read \
             --pipe util.dataset.tree --contains \
             --inputs superset.ttl subset.ttl
         ```

## Inputs
By default, `graphy` expects a single input stream on `stdin`, which it will forward through the internal pipeline. Some commands may allow for or even expect multiple inputs (e.g., for computing the difference between two datasets).

### `--inputs FILE ...`
If you are simply piping in multiple input files, you can use the `--inputs` options like so:
```bash
$ graphy content.ttl.read \
    --pipe util.dataset.tree --difference \
    --pipe content.ttl.write \
    --inputs original.ttl modified.ttl \
	  > difference.ttl
```

Keep in mind that each command has its own restrictions on the number of inputs it accepts, which may also depend on the operation being performed (e.g., `util.dataset.tree --diff` expects exactly 2 input streams while `util.dataset.tree --union` accepts 1 or more).


### Process Substitution
If you need to execute other commands before passing in multiple inputs, you can use [process substitution](http://www.tldp.org/LDP/abs/html/process-sub.html) (supported in bash) like so:
```bash
$ DBPEDIA_EN_URL="http://downloads.dbpedia.org/2016-10/core-i18n/en"
$ graphy content.ttl.read \
    --pipe util.dataset.tree --union \
    --pipe content.ttl.write \
    --inputs \
      <(curl "$DBPEDIA_EN_URL/topical_concepts_en.ttl.bz2" | bzip2 -d) \
      <(curl "$DBPEDIA_EN_URL/uri_same_as_iri_en.ttl.bz2" | bzip2 -d) \
    > union.ttl
```

<br />

<a name="classes" />

## Classes

<a name="class_string-stream" />

### class [**StringStream**](#class_string-stream)
A stream of utf8-encoded strings. This always applies to `stdin` and `stdout`.


<a name="class_quad-stream" />

### class [**QuadStream**](#class_quad-stream)
A stream of [Quad](core.data.factory#class_quad) objects.


<a name="class_writable-data-event-stream" />

### class [**WritableDataEventStream**](#class_writable-data-event-stream)
A stream of [WritableDataEvent](content.textual#interface_writable-data-event) objects.


<a name="class_any-destination" />

### class [**AnyDestination**](#class_any-destination) _adapts to_ [QuadStream](#class_quad-stream), [WritableDataEventStream](#class_writable-data-event-stream), [StringStream](#class_string-stream)
Automatically determines which mode is best suited for the destination stream. Compatible with [QuadStream](#class_quad-stream), [WritableDataEventStream](#class_writable-data-event-stream) and [StringStream](#class_string-stream). In the case of StringStream, each object is converted to its JSON equivalent on a single line, followed by a newline `'\n'` (i.e., [Line-delimited JSON](https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON)). 

<a name="class_result-value" />

### class [**ResultValueStream**](#class_result-value) _adapts to_ [StringStream](#class_string-stream)
A stream that will emit a single `'data'` event which is the result of some test or computation (e.g., a single `boolean` or `number` value). Compatible with [StringStream](#class_string-stream), in which case the value will be converted to JSON and then terminated by a newline `'\n'`.

