@./* global FORMAT */

@//@
@import '../share/writer.jmacs'

const writer = require('@graphy/writer');

@- 'trig' === FORMAT
	@$ QUADS = true;
	@$ extra_spacing = '\\t';
@:
	@$ extra_spacing = '';
@;

class @{FORMAT}_serializer extends writer.serializer.n3.terse {
	constructor(g_config) {
		super(writer.triples, g_config);

		let k_serializer = this;
		Object.assign(this, {
			new_graph: true,
			new_subject: true,
			new_predicate: true,

			blank_node_nesting: true,
			nest_mask: 0,
			nest_open: n => '[\n@{extra_spacing}'+'\t'.repeat(n+1),
			nest_close: (n) => {
				// reset nest tracker
				this.nest_mask = this.nest_mask & ~(1 << n);

				return '\n@{extra_spacing}'+'\t'.repeat(n)+']'
			},
			indent: '\t@{extra_spacing}',
		});

		// open prefixes
		this.serialize_prefixes();
	}

	get comment() {
		return this.hash_comment;
	}

	blank_line() {
		this.write('\n');
	}

	serialize_pair(s_predicate, s_object, xm_mode, n_nest_level=0) {
		// same predicate
		if(xm_mode & @{XM_MODE_PREDICATE}) {
			return `, ${s_object}`;
		}
		// new/change of predicate
		else {
			// nested
			if(n_nest_level) {
				let s_open = '';

				// reuse ?
				if((this.nest_mask >>> (n_nest_level-1)) & 1) {
					s_open = ` ;\n${this.indent}${'\t'.repeat(n_nest_level)}`;
				}

				this.nest_mask = this.nest_mask | (1 << (n_nest_level-1));

				return s_open+`${s_predicate} ${s_object}`;
			}
			// top scope
			else {
				let s_pair = (this.new_predicate? '': ` ;\n${this.indent}`)+`${s_predicate} ${s_object}`;
				this.new_predicate = false;
				this.nest_mask = 0;
				return s_pair;
			}
		}
	}

	serialize_object(k_leaf, s_object, xm_mode) {
		let s_write = '';

		@- QUADS
			// same graph
			if(xm_mode & @{XM_MODE_GRAPH}) {
		@;

			// same subject
			if(xm_mode & @{XM_MODE_SUBJECT}) {
				// same predicate
				if(xm_mode & @{XM_MODE_PREDICATE}) {
					s_write = `, ${s_object}`;
				}
				// new/change of predicate
				else {
					s_write = this.serialize_pair(k_leaf.term, s_object);
				}
			}
			// change of subject
			else {
				this.new_predicate = true;
				s_write = (this.new_subject? '': ' .\n\n')+`@{extra_spacing}${k_leaf.parent.term} `+this.serialize_pair(k_leaf.term, s_object);
				this.new_subject = false;
			}

		@- QUADS
			}
			// new/change of graph
			else {
				let k_parent = k_leaf.parent;
				this.new_predicate = true;
				let s_new_graph = `${k_parent.parent.term}\n{\n\t${k_parent.term}\n`+this.serialize_pair(k_leaf.term, s_object);

				// change graph
				if(this.count) {
					s_write = '\n}\n\n${s_new_graph}';
				}
				// new graph
				else {
					s_write = s_new_graph;
				}

				this.new_graph = false;
				this.new_subject = true;
			}
		@;

		// write output
		this.write(s_write);
	}

	close() {
		this.write(' .\n');
		this.end();
	}
};

module.exports = function(g_config) {
	return (new @{FORMAT}_serializer(g_config)).writer;
};
