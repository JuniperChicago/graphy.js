@// /* global TRIPLES, QUADS */

@// import parser macros
@import 'general-parser-macros.jmacs'


@// constants for all modes
@> constants()
	@// all modes need to unescape characters inside of string literals and IRIs
	const R_ESCAPES = /(\\[\\])|\\([^tbnrfuU\\])/g;
	const RT_ESCAPES_INVALID = /\\[^"tbnrfuU\\_~.!$&'()*+,;=/?#@%-]|@{UCHAR('^')}/;

	// const R_UNICODE_8 = /\\U(?:0000([0-9A-Fa-f]{4})|([0-9A-Fa-f]{8}))/g;
	// const R_UNICODE_ANY = /\\u([0-9A-Fa-f]{4})|\\U([0-9A-Fa-f]{8})/g;

	// const F_UNICODE_REPLACE = (s_, s_4, s_8) => {
	// 	if(s_4) return String.fromCharCode(parseInt(s_4, 16));

	// 	// produce utf16 be surrogate pair
	// 	let x_cp = parseInt(s_8, 16) - 0x10000;
	// 	return String.fromCharCode(0xD800 + (x_cp >> 10), 0xDC00 + (x_cp & 0x3FF));
	// };

	@- T
		const RT_PREFIXED_NAME_NAMESPACE_VALID = /^(@{PN_PREFIX()})?$/u;
		const RT_PREFIXED_NAME_LOCAL_NAME_VALID = /^@{PN_LOCAL()}$/u;
	@;

	const R_UNICODE_8 = /\\U([0-9A-Fa-f]{8})/g;
	const R_UNICODE_ANY = /\\U([0-9A-Fa-f]{8})|\\u([0-9A-Fa-f]{4})/g;

	const F_UNICODE_REPLACE = (s_, s_8, s_4) => String.fromCodePoint(parseInt(s_8 || s_4, 16));

	// queue data events instead of emitting them
	const F_QUEUE_DATA = function(h_data) {
		@- N
			this.queue_event.push(h_data);
		@:
			this.queue_event.push({
				event: 'restore_data',
				data: h_data,
			});
		@;
	};

	// simply flag that consumer requested pause
	const F_PAUSE_NEGATIZE = function() {
		this.n = -1;
	};
@;

/* whitespace */


@// control variables

@// count how many braces need closing
@$ c_braces = 0;

@// whether or not the method macro is going to account for relative iris
@$ RELATIVE_IRIS = true;


@- TRIPLES
	@$ STATEMENT_TYPE = 'triple';
@+ QUADS
	@$ STATEMENT_TYPE = 'quad';
@;


@// keys for the object that represents the RDF object term
@$ KEY_IRI = 'value';
@$ KEY_LITERAL_VALUE = 'value';
@$ KEY_LITERAL_DATATYPE = 'datatype';
@$ KEY_LITERAL_LANGUAGE = 'language';
@$ KEY_BLANK_NODE_LABEL = 'value';
@$ KEY_DEFAULT_GRAPH_IRI = 'value';

@>> dot(key)
	@//@after-identifier
	.@{key}
@;


@>> iri()
	@{dot(KEY_IRI)}
@;

@>> literal_value()
	@{dot(KEY_LITERAL_VALUE)}
@;

@>> literal_datatype()
	@{dot(KEY_LITERAL_DATATYPE)}
@;

@>> literal_language()
	@{dot(KEY_LITERAL_LANGUAGE)}
@;

@>> blank_node_label()
	@{dot(KEY_BLANK_NODE_LABEL)}
@;



@// save current state to stack
@> push_state(state)
	this.nested.push([this.subject, this.predicate, '@{state}']);
@;

@// restore previous state from stack
@> pop_state()
	let s_resume_state;
	[this.subject, this.predicate, s_resume_state] = this.nested.pop();
	return this[s_resume_state]();
@;

@// save current state to stack
@> push_nest(s_state)
	this.nested.push('@{s_state}');
@;

@// restore previous state from stack
@> pop_nest()
	return this[this.nested.pop()]();
@;


@// change state
@> goto(s_method)
	return this.@{s_method}();
@;


@// declare a parse state
@> method(name, extern)
	// parse state for @{name}
	@- extern
		@{name}: () => {
	@:
		@{name}() {
	@;
		// destruct chunk, length, and index
		let {@{CHUNK}, n, i} = this;

		// start labeled loop, run while there are characters
		@{name}: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
@;


@// end parse state method
@> end_method(name, max_token)
		}

		// ran out of characters
		@{resume_state(name, false, max_token)}
	},
@;


@// set resume state & stop parsing in this stack
@> resume_state(mode, use_field_chunk, max_token)
	// update index value
	this.i = i;

	// not yet eos
	if(i < this.n) {
		// expected token was not found
		if(0 === i) {
			// we've exceeded the maximum token length
			if(this.n > this.@{max_token? max_token: 'max_token_length'}) {
				return this.parse_error('@{mode}');
			}
		}
	}

	// save state before pausing
	this.state = this.@{mode};

	// consumer is pausing
	if(this.n < 0) {
		// go async
		return;
	}

	// store what is unparsed
	this.pre = @{use_field_chunk?'this.':''}@{CHUNK}.slice(i);

	// if we're not parsing a stream, then this is an error
	if(this.eos) this.eos();
	return;
@;



@// test the current character
@> if_char(a, b)
	if(`@{a}` === @{b?'x || `':'x'}@{b?b:''}@{b?'` === x':''}) {
@;

@// else, test the current character
@> else_if_char(a, b)
	} else @{if_char(a, b)}
@;

@// else, test the current character without use of intermediate variable
@> else_if_char_only(a)
	} else if (`@{a}` === s[i]) {
@;


@// test regex
@> if_test(regex, local)
	@// count how many else branches we'll need to close
	@$ c_braces += 0;

	// prepare sticky regex index
	@{regex}.lastIndex = i;

	if(@{regex}.test(s)) {

	// advance index
	@{local? '': 'this.'}i = @{regex}.lastIndex;
@;

@// try next test
@> else_if_test(regex, local)
	@// count how many else branches we'll need to close
	@$ c_braces += 1;

	@// whern previous test fails
	} else {
		@// try next test
		@{if_test(regex, local)}
@;


@// exec regex and store match
@> if_match(regex, match, local)
	@// count how many else branches we'll need to close
	@$ c_braces += 0;

	// prepare sticky regex index
	@{regex}.lastIndex = i;

	@// store the match
	@- match
		// execute regex
		let @{match} = @{regex}.exec(s);

		// regex was a match
		if(@{match}) {
	@// no need to store the match
	@:
		if(@{regex}.exec(s)) {
	@;

	// advance index
	@{local? '': 'this.'}i = @{regex}.lastIndex;
@;

@// try next match
@> else_if_match(regex, match, local)
	@// increment number of else branches we'll need to close
	@$ c_braces += 1;

	// c_braces: @{c_braces}

	@// when previous match fails
	} else {
		@// try next match
		@{if_match(regex, match, local)}
@;

// try something else
@> else_if_call(s_method, s_match, b_local)
	@// increment number of else branches we'll need to close
	@$ c_braces += 1;

	// c_braces: @{c_braces}

	@.let s_no_shadow = s_method.replace(/[^a-z0-9]/gi, '_');

	@// when previous match fails
	} else {
		// try match
		let aw_valid_@{s_no_shadow} = @{s_method}(s, i);

		if(!aw_valid_@{s_no_shadow}) return;

		let [@{s_match}, i@{s_match}] = aw_valid_@{s_no_shadow};

		@// test
		if(@{s_match}) {

			// advance index
			@{b_local? '': 'this.'}i = i@{s_match};
@;


@// close all preceeding else branches
@> end_else()
 	@// end last branch
	}

	@// for all other branches
	@*{
		for(let i_brace=0; i_brace<c_braces; i_brace++) {
			yield `} // brace #${c_braces-i_brace}\n`;
		}
	}

	@// reset match counter
	@$ c_braces = 0;
@;


@// all matches failed, pause parser
@> else_retry()
	// match counter: @{c_braces}
	} else {
		// break loop to retry on next chunk if eos
		break;

	@// close all preceeding else branches
	@{end_else()}
@;



@// emit a statement event to listener using current subject/predicate/object
@> emit_statement()
	this.data(Quad(this));
	// this.operator.emit('data', Quad(this));
@;


@// emit statement and return control to whatever function asked for it
@> end_of_statement()
	// at this point, a new statement has been parsed
	@{emit_statement()}

	// goto next parsing state; bail out of stack
	return this.after_end_of_statement;
@;


@// consume whitespace
@> whitespace(offset, local)
	R_WS.lastIndex = @{offset};
	R_WS.exec(s);
	@{!local? 'this.': ''}i = R_WS.lastIndex;
@;


@// replace unicode escapes; all_ranges will also escape single char code
@> replace_unicode(all_ranges)
	replace(@{all_ranges? 'R_UNICODE_ANY': 'R_UNICODE_8'}, F_UNICODE_REPLACE)
@;

@// extract name from suffix
@> suffix(term)
	// escape local escapes
	let s_suffix = @{term}[2]
		.@{replace_unicode(true)}
		.replace(R_PN_LOCAL_ESCAPES, '$1');
@;


@// extract uri from absolute / relative iri refs
@> iriref(term, match, object, set_base, has_escapes, not_this)
	// ref iri
	let s_iri = @{match}[1]@{has_escapes? `.${replace_unicode(true)}`: ''};

	// absolute iri
	if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set @{term}
		@{not_this? '': 'this.'}@{term} = @{object?'this.named_node(':''}s_iri@{object?')':''};
	}
	// relative iri
	else {
		// make @{term}
		switch(s_iri[0]) {
			case '#':
				@{not_this? '': 'this.'}@{term} = @{object?'this.named_node(':''}this.base_url + s_iri@{object?')':''};
				break;
			case '?':
				@{not_this? '': 'this.'}@{term} = @{object?'this.named_node(':''}this.base_url.replace(/(\?.*)?$/, s_iri)@{object?')':''};
				break;
			case '/':
				// relative to scheme
				if('/' === s_iri[1]) {
					@{not_this? '': 'this.'}@{term} = @{object?'this.named_node(':''}this.base_url_scheme + F_DOT_SEGMENTS(s_iri.substr(1))@{object?')':''};
				}
				// relative to root
				else {
					@{not_this? '': 'this.'}@{term} = @{object?'this.named_node(':''}this.base_url_root + F_DOT_SEGMENTS(s_iri)@{object?')':''};
				}
				break;
			// empty
			case undefined:  // eslint-disable-line no-undefined
				// identity
				@{not_this? '': 'this.'}@{term} = @{object?'this.named_node(':''}this.base_url@{object?')':''};
				break;
			// dot segment
			case '.':
				// prepend so it is relative to root
				s_iri = '/'+s_iri;
			// fallthrough: relative to path
			default:
				@{not_this? '': 'this.'}@{term} = @{object?'this.named_node(':''}this.base_url_root + F_DOT_SEGMENTS(this.base_url_path + s_iri)@{object?')':''};
		}
	}

	@// update the base iri
	@- set_base
		let m_base_iri = R_BASE_IRI.exec(this.base_url);
		this.@{term} = m_base_iri[1];
		this.@{term}_root = m_base_iri[2] || '';
		this.@{term}_scheme = m_base_iri[3] || '';
		this.@{term}_path = m_base_iri[4] || ''; 
	@;
@;


@// set object value and datatype for numeric literal
@> numeric_literal()
	// it has exponent term, xsd:double
	if(m_numeric_literal[4]) {
		this.object = factory.double(m_numeric_literal[1]);
	}
	// contains decimal point, xsd:decimal
	else if(m_numeric_literal[2] || m_numeric_literal[3]) {
		this.object = factory.decimal(m_numeric_literal[1]);
	}
	// otherwise, it is an integer
	else {
		this.object = factory.integer(m_numeric_literal[1]);
	}
@;


@// set object value and datatype for boolean literal
@> boolean_literal()
	// make literal
	this.object = factory.boolean(m_boolean_literal[1]? true: false);
@;


@// unescape a string literal
@> unescape(version)
	return JSON.parse('"'
		+s_literal
			.@{replace_unicode()}
			.replace(R_ESCAPES, '$1$2') // no need to escape anything other than reserved characters
			@- 'long' === version
				.replace(/[\t\n"\r\f\u0008]/g, (s) => {
					return H_SPECIAL_ESCAPES[s];
				})
			@:
				.replace(/"/g, '\\"') // escape all quotes ;)
			@;
		+'"');
@;

@// set the object value of a string literal
@> set_string_literal(match, version)
	// set literal value
	h_literal@{literal_value()} = 
	@- 'no-escape' === version
		@{match}[1];
	@:
		this.unescape_literal_@{'long'===version? 'long': 'short'}(@{match}[1]);
	@;
@;


@// assert the prefix found in prefixed name is valid
@> valid_prefix(match)
	// check valid prefix
	let s_prefix_id = @{match}[1] || '';

	// invalid prefix
	if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this._error(`no such prefix "${s_prefix_id}"`);
@;


@// 
@> full_stop()
	if(this.expect_full_stop) {
		// change state
		@{goto('full_stop')}
	}
@;


@> this_defer_errors()
	@//@object-literal
	// error event
	_error: g_config.error || ((e_parse) => {
		if(this.grace) {
			this.grace(e_parse);
		}

		throw new Error(`parse error: ${e_parse}`);
	}),

	// parse_error (not meant to be an event callback)
	parse_error(s_expected, b_eof) {
		@- T
			let i = this.i;
			let i_off = Math.min(i, Math.abs(i-15));
		@:
			let i = 0;
			let i_off = 0;
		@;
		let s = this.s;
		this._error(`\n\`${s.substr(i_off, i_off+90).replace(/[\n\t]/g, ' ')}\`\n`
			+` ${' '.repeat(i-i_off)}^\n`
			+`expected ${s_expected} ${b_eof? 'but encountered <<EOF>>': ''}.  failed to parse a valid token starting at ${s[i]? '"'+s[i]+'"': '<<EOF>>'}`);
	},
@;
