@// /* global BINARY */

@// control variables

@// whether or not the method macro is going to account for relative iris
@$ RELATIVE_IRIS = true;

@- BINARY
	@$ CHUNK = 'a';
@:
	@$ CHUNK = 's';
@;



@// make stream controls
@> stream_control(stream, transform)
	// pause the parser (& stream if applicable)
	this.pause = this.restore_pause = function() {
		// already paused
		if(this.n < 0) {
			debugger;
			return;
		}

		// set length too low so execution will hault
		this.n = -1;

		@// parser is streaming input
		@- stream
			// pause readable input stream
			@{stream}.pause();
		@;

		// make sure we are not currently emptying queue
		if(this.data !== F_QUEUE_DATA) {
			// save original data event callback
			this.restore_data = this.data;

			// set up callback to capture data events that happen while pausing
			this.data = F_QUEUE_DATA;
		}

		@// for Turtle and TriG
		@- T
			// save original prefix event callback
			this.restore_prefix = this.prefix;

			// set up callback to capture prefix events that happen while pausing
			this.prefix = F_QUEUE_PREFIX;
		@;
	};

	// hault the parser (& close stream if applicable/possible)
	this.stop = function() {
		// cause parser to break asap
		this.n = -1;

		// safely remove event callbacks and user functions
		this.pause = this.restore_pause =
		this.resume = this.stop =
		this.error = this.end = this.parse_error =
		this.data = this.restore_data =
		@- T
			this.restore_prefix = this.prefix =
			this.base =
		@;
			function(){};

		@// for transforms
		@- transform
			// empty event queue in case user paused and accumulated events
			this.queue_event.length = 0;
		@;

		@// for streams
		@- stream
			// attempt to destroy the readable stream
			if('function' === typeof @{stream}.destroy) {
				@{stream}.destroy();
			}
		@;
	};

	// resume the parser (& stream if applicable)
	this.resume = function() {
		// not even paused
		if(this.n >= 0) return;

		// enter pseudo-"flowing" mode
		this.n = 0;

		// temporarily re-route calls to pause
		this.pause = F_PAUSE_NEGATIZE;

		// now back in "flowing", drain event queue
		while(this.queue_event.length) {
			// remove event from front of queue
			let h_event = this.queue_event.shift();

			// make event callback
			@- N
				this.restore_data(h_event@{transform? ', ds_output': ''});
			@:
				this[h_event.event](h_event.data@{transform? ', ds_output': ''});
			@;

			// callback paused stream
			if(this.n < 0) {
				// stop emptying event queue and go async immediately
				return;
			}
		}

		// restore pause function
		this.pause = this.restore_pause;

		// restore data event
		this.data = this.restore_data;

		// eof'ed
		if(null === this.s) return;

		@// for Turtle and TriG
		@- T
			// restore actual length
			this.n = this.s.length;

			// restore prefix event
			if(this.prefix) {
				this.prefix = this.restore_prefix;
			}

			// parse remainder
			if(this.i < this.n) {
				this.safe_parse();

				// user paused!
				if(this.n < 0) {
					// slice current
					if(this.i) {
						this.pre = this.s.slice(this.i);
					}

					// do not turn stream back on
					return;
				}
			}

			// slice current
			if(this.i) {
				this.pre = this.s.slice(this.i);
			}
		@;

		@// for streams only
		@- stream
			// now that event queue is empty, resume readable input stream
			@{stream}.resume();
		@;
	};
@;



@// ensure there are no conflicting blank node labels
@> no_label_conflict()
	// not first time use of label
	let z_label_state = this.labels[s_label];
	if(z_label_state) {
		// label was used previously by document and has no conflict
		if(1 === z_label_state) {}  // eslint-disable-line no-empty
		// label is in use by invention, this would cause a conflict
		else if(2 === z_label_state) {
			// so create a redirect mapping for this actual label & use it instead
			s_label = this.labels[s_label] = this.next_label();
		}
		// label already has a redirect mapping
		else {
			// use redirected label
			s_label = this.labels[s_label];
		}
	}
	// first time use of label
	else {
		// store label in hash so we avoid future collisions
		this.labels[s_label] = 1;
	}
@;

@>> PN_CHARS_BASE()
	@//@regex
	A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u{02ff}\u{0370}-\u{037d}\u{037f}-\u{1fff}\u{200c}-\u{200d}\u{2070}-\u{218f}\u{2c00}-\u{2fef}\u{3001}-\u{d7ff}\u{f900}-\u{fdcf}\u{fdf0}-\u{fffd}\u{10000}-\u{effff}
@;

@>> PN_CHARS_U()
	@//@regex
	@{PN_CHARS_BASE()}_
@;

@>> PN_CHARS()
	@//@regex
	@{PN_CHARS_U()}\-0-9\xb7\u{0300}-\u{036f}\u{203f}-\u{2040}
@;

@>> PN_CHARS_FS()
	@//@regex
	([@{PN_CHARS()}.]*[@{PN_CHARS()}])?
@;

@>> PN_PREFIX()
	@//@regex
	[@{PN_CHARS_BASE()}]@{PN_CHARS_FS()}
@;

@>> PLX()
	@//@regex
	%[A-Fa-f0-9]{2}|\\[_~.\-!$&'()*+,;=/?#@%]
@;

@>> PN_LOCAL()
	@//@regex
	([@{PN_CHARS_U()}:0-9]|@{PLX()})(([@{PN_CHARS()}.:]|@{PLX()})*([@{PN_CHARS()}:]|@{PLX()}))?
@;

@>> UCHAR(s_ins='')
	@//@regex
	\\u[@{s_ins}A-Fa-f0-9]{4}|\\U[@{s_ins}A-Fa-f0-9]{8}
@;

@> validators()
	@//@object-literal
	{
		blank_node(s_value) {
			if(!RT_BLANK_NODE_VALID.test(s_value)) return this._error(`invalid blank node label: "${s_value}"`);
			return factory.blankNode(s_value);
		},

		named_node(s_iri) {
			if(!RT_NAMED_NODE_VALID.test(s_iri)) return this._error(`invalid IRI: "${s_iri}"`);
			return factory.namedNode(s_iri);
		},

		unescape_literal_long(s_literal) {
			if(RT_ESCAPES_INVALID.test(s_literal)) return this._error(`invalid literal: "${s_literal}"`);
			try {
				return unescape_literal_long(s_literal);
			}
			catch(e_parse) {
				return this._error(`invalid string literal: "${s_literal}"`);
			}
		},

		unescape_literal_short(s_literal) {
			if(RT_ESCAPES_INVALID.test(s_literal)) return this._error(`invalid literal: "${s_literal}"`);
			try {
				return unescape_literal_short(s_literal);
			}
			catch(e_parse) {
				return this._error(`invalid string literal: "${s_literal}"`);
			}
		},

		match_prefixed_name_escapeless(s, i) {
			let [m_prefixed_name_e, im_prefixed_name_e] = match_prefixed_name_escapeless(s, i);
			if(m_prefixed_name_e) {
				// invalid namespace
				if(!RT_PREFIXED_NAME_NAMESPACE_VALID.test(m_prefixed_name_e[1])) {
					this._error(`invalid prefixed name namespace: "${m_prefixed_name_e[1]}:"`);
					return;
				}
				// invalid local name
				else if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name_e[2])) {
					this._error(`invalid prefixed name local name: "${m_prefixed_name_e[2]}:"`);
					return;
				}
			}

			return [m_prefixed_name_e, im_prefixed_name_e];
		},

		match_prefixed_name(s, i) {
			let [m_prefixed_name, im_prefixed_name] = match_prefixed_name(s, i);
			if(m_prefixed_name) {
				// invalid namespace
				if(!RT_PREFIXED_NAME_NAMESPACE_VALID.test(m_prefixed_name[1])) {
					this._error(`invalid prefixed name namespace: "${m_prefixed_name[1]}:"`);
					return;
				}
				// invalid local name
				else if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name[2])) {
					this._error(`invalid prefixed name local name: "${m_prefixed_name[2]}:"`);
					return;
				}
			}

			return [m_prefixed_name, im_prefixed_name];
		},
	}
@;


@// create a class for each of the term types that the object of a triple can be
@> term_types(from_this)
	const factory = require('@graphy/factory').unfiltered;

	@// make Quad constructor
	@- T
		// creates a new Quad by copying the current terms from the parser state
		const Quad = (k_from) => {
			return factory.quad(k_from.subject, k_from.predicate, k_from.object, k_from.graph);
		};
	@:
		// creates the quad from components
		const Quad = factory.quad;
	@;

	@// @{factory('NamedNode')}
	@// @{factory('BlankNode')}
	@// @{factory('Literal')}
	@// @{factory('Literal_Integer', 'integer')}
	@// @{factory('Literal_Double', 'double')}
	@// @{factory('Literal_Decimal', 'decimal')}
	@// @{factory('Literal_Boolean', 'boolean')}
	@// @{factory('DefaultGraph')}

	const RT_BLANK_NODE_VALID = /^[@{PN_CHARS_U()}0-9]@{PN_CHARS_FS()}$/u;
	const RT_NAMED_NODE_VALID = /^([^\0- <>"{}|^`\\]|@{UCHAR()})*$/;

@;

@> factory(s_class, s_method)
	const @{s_class} = factory.@{s_method || s_class.substr(0, 1).toLowerCase()+s_class.substr(1)};
@;

@> export_module()
	module.exports = function(...a_args) {
		let g_config = {};

		// at least one argument
		if(a_args.length) {
			let z_arg_0 = a_args[0];

			// config struct
			if(z_arg_0 && 'object' === typeof z_arg_0 && Object === z_arg_0.constructor) {
				g_config = z_arg_0;

				// more args; invalid
				if(a_args.length > 1) {
					throw new TypeError(`unexpected argument(s) after config struct: ${a_args.slice(1)}`);
				}
			}
			// input arg
			else {
				g_config.input = z_arg_0;

				// more args
				if(a_args.length > 1) {
					// copy onto struct
					Object.assign(g_config, a_args[1]);

					// more args
					if(a_args.length > 2) {
						throw new TypeError(`unexpected argument(s) after input and config struct: ${a_args.slice(2)}`);
					}
				}
			}
		}

		// create parser, return output stream
		return (new Parser(g_config)).output;
	};
@;
