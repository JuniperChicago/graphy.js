@import '../../constants.jmacs'

const assert = require('assert');

const bkit = require('bkit');
const worker = require('worker');
// const performance_now = require('performance-now');

const encoder_chapter = require('../encoders/chapter-difcc.js');

const F_SORT_BUFFER = (ab_a, ab_b) => {
	let nl_a = ab_a.length;
	let nl_b = ab_b.length;

	let n_chars = Math.min(nl_a, nl_b);
	for(let i_char=0; i_char<n_chars; i_char++) {
		let x_a = ab_a[i_char];
		let x_b = ab_b[i_char];
		if(x_a < x_b) return -1;
		else if(x_a > x_b) return 1;
	}

	// one is substring of other; shorter length means win
	return (nl_a < nl_b)? -1: 1;
};

const F_SORT_VALUE = (h_a, h_b) => {
	return h_a.value < h_b.value? -1: 1;
};

const FM_SORT_BUFFER_FAST = (av_src) => {
	return (h_a, h_b) => {
		let {i:i_a, nl:nl_a} = h_a;
		let {i:i_b, nl:nl_b} = h_b;

		let i_char = 0;
		let n_chars = Math.min(nl_a, nl_b);

		let n_chars_4 = (n_chars / 4) | 0;
		for(; i_char<n_chars_4; i_char+=4) {
			let x_a = av_src.getUint32(i_a+i_char);
			let x_b = av_src.getUint32(i_b+i_char);
			if(x_a < x_b) return -1;
			else if(x_a > x_b) return 1;
		}

		for(; i_char<n_chars; i_char++) {
			let x_a = av_src.getUint8(i_a+i_char);
			let x_b = av_src.getUint8(i_b+i_char);
			if(x_a < x_b) return -1;
			else if(x_a > x_b) return 1;
		}

		// one is substring of other; shorter length means win
		return (nl_a < nl_b)? -1: 1;
	};
};

// TODO: check endianess of machine
const FM_COMPARE_BUFFER_DUAL_FAST = (av_src_a, av_src_b) => {
	return (i_a, nl_a, i_b, nl_b) => {
		let i_char = 0;
		let n_chars = Math.min(nl_a, nl_b);

		let n_chars_4 = ((n_chars / 4) | 0) << 2;
		for(; i_char<n_chars_4; i_char+=4) {
			let x_a = av_src_a.getUint32(i_a+i_char);
			let x_b = av_src_b.getUint32(i_b+i_char);
			if(x_a < x_b) return -1;
			else if(x_a > x_b) return 1;
		}

		for(; i_char<n_chars; i_char++) {
			let x_a = av_src_a.getUint8(i_a+i_char);
			let x_b = av_src_b.getUint8(i_b+i_char);
			if(x_a < x_b) return -1;
			else if(x_a > x_b) return 1;
		}

		// one is substring of other; shorter length means win
		return (nl_a < nl_b)? -1: 1;
	};
};

// classify nodes into hops, subjects, predicates, objects, and datatypes
const classify_nodes_list = (a_nodes) => {
	let a_nodes_h = [];
	let a_nodes_s = [];
	let a_nodes_p = [];
	let a_nodes_o = [];

	// separate nodes into categories
	for(let i_node=0, n_nodes=a_nodes.length; i_node<n_nodes; i_node++) {
		let {
			value: s_value,
			id: i_uni,
			type: x_node_type,
		} = a_nodes[i_node];

		// classified item
		let h_item = {
			value: s_value,
			id: i_uni,
		};

		// a subject
		if(x_node_type & @{XM_NODE_SUBJECT}) {
			// an object too
			if(x_node_type & @{XM_NODE_OBJECT}) {
				// it's a hop
				a_nodes_h.push(h_item);

				// also a predicate
				if(x_node_type & @{XM_NODE_PREDICATE}) {
					a_nodes_p.push(h_item);
				}
			}
			// not an object
			else {
				// its a subject
				a_nodes_s.push(h_item);

				// also a predicate
				if(x_node_type & @{XM_NODE_PREDICATE}) {
					a_nodes_p.push(h_item);
				}
			}
		}
		// not a subject
		else {
			// an object
			if(x_node_type & @{XM_NODE_OBJECT}) {
				a_nodes_o.push(h_item);
			}
			// a predicate
			if(x_node_type & @{XM_NODE_PREDICATE}) {
				a_nodes_p.push(h_item);
			}
		}
	}

	return {
		h: a_nodes_h.sort(F_SORT_VALUE),
		s: a_nodes_s.sort(F_SORT_VALUE),
		p: a_nodes_p.sort(F_SORT_VALUE),
		o: a_nodes_o.sort(F_SORT_VALUE),
	};
};



worker.dedicated({

	// front code a null-terminated word list
	encode_chapter(a_buffers) {
		assert(1 === a_buffers.length);

		let h_buffer = a_buffers[0];

		// start front coder off at the right offset
		let k_chapter = new encoder_chapter({
			offset: h_buffer.offset,
			block_size_k: h_buffer.block_size_k,
		});

		// front code fragment
		k_chapter.add_nt_word_list(h_buffer.contents, h_buffer.word_count);

		// results
		return k_chapter.export();
	},


	classify_sort_concat_encode(a_words, i_uli_max, s_wtf) {
		// let t_sort_last = performance_now();
		let h_types = classify_nodes_list(a_words);

		return {
			h: this.tasks.concat_encode(h_types.h, i_uli_max),
			s: this.tasks.concat_encode(h_types.s, i_uli_max),
			p: this.tasks.concat_encode(h_types.p, i_uli_max),
			o: this.tasks.concat_encode(h_types.o, i_uli_max),
		};
	},

	merge_classified_word_buffers(h_a, h_b, i_uli_max) {
		return {
			h: this.tasks.merge_word_buffers(h_a.h, h_b.h, i_uli_max),
			s: this.tasks.merge_word_buffers(h_a.s, h_b.s, i_uli_max),
			p: this.tasks.merge_word_buffers(h_a.p, h_b.p, i_uli_max),
			o: this.tasks.merge_word_buffers(h_a.o, h_b.o, i_uli_max),
		};
	},

	concat_encode(a_words, i_uli_max) {
		let nl_words = a_words.length;

		// console.time('encode each');
		// let k_buffer_writer = new bat.buffer_writer({grow:1024*1024});
		// for(let i_literal=0; i_literal<nl_literals; i_literal++) {
		// 	k_buffer_writer.append(bkit.encode_utf_8(a_literals[i_literal]));
		// }
		// let at_contents = k_buffer_writer.close();
		// console.timeEnd('encode each');
		// console.log('encode each contents length: '+at_contents.length);

		// k_buffer_writer = null;
		// at_contents = null;
// debugger;
		// console.time('concat-encode');
		let s_super = '';

		let at_ids = bkit.new_uint_array(i_uli_max, nl_words);

		// each word
		for(let i_word=0; i_word<nl_words; i_word++) {
			let h_word = a_words[i_word];

			// concat its value
			s_super += h_word.value+'\0';

			if(!h_word.value) debugger;

			// push its id
			at_ids[i_word] = h_word.id;
		}

		// encode all at once
		let at_contents = bkit.encode_utf_8(s_super);
		// console.timeEnd('concat-encode');

		return {
			contents: at_contents,
			ids: at_ids,
		};
	},

	sort_concat_encode(a_words, i_uli_max, b_debug=false) {
		a_words.sort(F_SORT_VALUE);

		return this.tasks.concat_encode(a_words, i_uli_max);
	},

	merge_word_buffers(h_a, h_b, i_uli_max, b_debug=false) {
		console.time('merge word buffers');

		let {
			contents: at_a,
			ids: at_ids_a,
		} = h_a;

		let {
			contents: at_b,
			ids: at_ids_b,
		} = h_b;

		if(!at_a) debugger;

		let nl_a = at_a.length;
		let nl_b = at_b.length;

		// one of the buffers is empty
		if(!nl_a) return h_b;
		else if(!nl_b) return h_a;

		let nl_c = nl_a + nl_b;
		let at_c = new Uint8Array(nl_c);
		let at_ids_c = bkit.new_uint_array(i_uli_max, at_ids_a.length+at_ids_b.length);

		let av_src_a = new DataView(at_a.buffer, at_a.byteOffset, at_a.byteLength);
		let av_src_b = new DataView(at_b.buffer, at_b.byteOffset, at_b.byteLength);
		let f_compare = FM_COMPARE_BUFFER_DUAL_FAST(av_src_a, av_src_b);

		let i_word_a = 0;
		let i_word_b = 0;
		let i_word_c = 0;

		let i_read_a = 0;
		let i_read_b = 0;

		let i_end_a = at_a.indexOf(0, i_read_a) + 1;
		let i_end_b = at_b.indexOf(0, i_read_b) + 1;

		let nl_word_a = i_end_a - i_read_a;
		let nl_word_b = i_end_b - i_read_b;

		let i_write_c = 0;
		while(i_write_c<nl_c) {
			// a wins
			if(f_compare(i_read_a, nl_word_a, i_read_b, nl_word_b) < 0) {
				// add word to buffer
				at_c.set(at_a.subarray(i_read_a, i_end_a), i_write_c);

				// put id in right spot
				at_ids_c[i_word_c++] = at_ids_a[i_word_a++];

				// advance write index
				i_write_c += nl_word_a;

				// advance pointers; check end of input buffer
				i_read_a = i_end_a;
				i_end_a = at_a.indexOf(0, i_read_a) + 1;
				if(0 === i_end_a) break;
				nl_word_a = i_end_a - i_read_a;
			}
			// b wins
			else {
				// add word to buffer
				at_c.set(at_b.subarray(i_read_b, i_end_b), i_write_c);

				// put id in right spot
				at_ids_c[i_word_c++] = at_ids_b[i_word_b++];

				// advance write index
				i_write_c += nl_word_b;

				// advance pointers; check end of input buffer
				i_read_b = i_end_b;
				i_end_b = at_b.indexOf(0, i_read_b) + 1;
				if(0 === i_end_b) break;
				nl_word_b = i_end_b - i_read_b;
			}
		}

		// a is empty; append rest of b
		if(i_read_a === nl_a) {
			at_c.set(at_b.subarray(i_read_b), i_write_c);
			at_ids_c.set(at_ids_b.subarray(i_word_b), i_word_c);
			i_write_c += nl_b - i_read_b;
		}
		// b is empty; append rest of a
		else if(i_read_b === nl_b) {
			at_c.set(at_a.subarray(i_read_a), i_write_c);
			at_ids_c.set(at_ids_a.subarray(i_word_a), i_word_c);
			i_write_c += nl_a - i_read_a;
		}

		// sanity check
		console.assert(i_write_c === nl_c, 'bug alert: sorted null-terminated word buffers were not thoroughly merged');

		console.timeEnd('merge word buffers');

		// if(b_debug) debugger;
		return {
			contents: at_c,
			ids: at_ids_c,
		};
	},

});

