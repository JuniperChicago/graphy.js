@import '../../share/channel.jmacs'

const bkit = require('bkit');

const factory = require('@{channel('api.data.factory')}');
const HVT_SCHEMA_DEFAULT = require('@{channel('schema.bat.default')}');

const p_base = 'https://bat-rdf.link/v1.0/';
const H_PREFIXES = {
	bat: `${p_base}ontology/`,
	bre: `${p_base}encoding/`,
	brdt: `${p_base}datatype/`,
	bri: `${p_base}interface/`,
	brp: `${p_base}protocol/`,
	rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
	rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
};

const expand = (sct, h_prefixes=H_PREFIXES) => {
	let k_term = factory.ct(sct, h_prefixes);
	if(k_term.isNamedNode) {
		return k_term.value;
	}
	else {
		return k_term.verbose();
	}
};

const expand_ct_object = (z_object, h_prefixes, b_list=false) => {
	// coerce into a list
	let a_objects = Array.isArray(z_object)? z_object: [z_object];

	// return cleaned up
	return a_objects.map((z_item) => {
		// concise-term string
		if('string' === typeof z_item) return expand(z_item, h_prefixes);

		// rdf:List
		if(Array.isArray(z_item)) {
			if(b_list) throw new TypeError(`cannot use Array as member of an rdf:List`);
			return z_item.map(z_element => expand_ct_object(z_element, h_prefixes, true));
		}

		// blank node
		return expand_ct_pairs(z_item, h_prefixes);
	});
};

const expand_ct_pairs = (hct_pairs, h_prefixes) => {
	let hvt_pairs = {};
	for(let sct_predicate in hct_pairs) {
		hvt_pairs[expand(sct_predicate, h_prefixes)] = expand_ct_object(hct_pairs[sct_predicate], h_prefixes);
	}
	return hvt_pairs;
};

const expand_ct_triples = (hct_triples, h_prefixes) => {
	let hvt_triples = {};
	for(let sct_subject in hct_triples) {
		hvt_triples[expand(sct_subject, h_prefixes)] = expand_ct_pairs(hct_triples[sct_subject], h_prefixes);
	}
	return hvt_triples;
};

let pp_type = expand('rdf:type');
let pi_datset = expand('bri:dataset.concise-term');
let pp_implements = expand('bat:implements');
let pp_datatype = expand('bat:datatype');
let pp_member = expand('bat:member');
let pp_method = expand('bat:method');
let pp_encoding = expand('bat:encoding');
let pp_extends = expand('bat:extends');
let pc_protocol = expand('bat:Protocol');
let pc_datatype = expand('bat:Datatype');


class schema {
	constructor(hvt_defs) {
		Object.assign(this, {
			defs: hvt_defs,
			cache: {},
		});
	}

	select(dc_type, p_subject, pi_select=null) {
		// distinct subject/select id
		let si_distinct = p_subject+'>'+pi_select;

		// already loaded this subject
		if(this.cache[si_distinct]) return this.cache[si_distinct];

		// ref defs
		let hvt_defs = this.defs;

		// no such definition
		if(!(p_subject in hvt_defs)) {
			debugger;
			throw new Error(`<${p_subject}> was not found in schema descriptor.`);
		}

		// fetch def
		let g_subject = this.defs[p_subject];

		// create instance and save to cache
		return this.cache[si_distinct] = new dc_type(g_subject, this, pi_select);
	}

	satisfy(pi_select) {
		// make decision based on schema
		for(let [svt_subject, g_def] of Object.entries(this.defs)) {
			// just give the first match
			if(pc_protocol === g_def[pp_type] && pi_select === g_def[pp_implements]) {
				return svt_subject;
			}
		}

		return null;
	}
}

class implementation {
	constructor(g_exports, k_schema, pc_type=null) {
		let {
			prefixes: h_prefixes,
			subject: sct_subject,
			properties: hct_properties,
		} = g_exports;

		// missing prefixes hash
		if(!h_prefixes) throw new Error('protocol descriptor missing required key "prefixes".');

		// invalid subject type
		if('object' !== typeof h_prefixes) throw new TypeError(`protocol descriptor has invalid type for "prefixes"; expected hash instead found: ${typeof h_prefixes}`);

		// missing subject
		if(!sct_subject) throw new Error('protocol descriptor missing required key "subject".');

		// invalid subject type
		if('string' !== typeof sct_subject) throw new TypeError(`protocol descriptor has invalid type for "subject"; expected string instead found: ${typeof sct_subject}`);

		// expand subject iri
		let p_subject = expand(sct_subject, h_prefixes);

		// missing properties
		if(!hct_properties) throw new Error(`protocol descriptor for <${p_subject}> missing required key "properties".`);

		// invalid properties type
		if('object' !== typeof hct_properties) throw new TypeError(`protocol descriptor for <${p_subject}> has invalid type for "properties"; expected struct instead found: ${typeof g_properties}`);

		// save fields
		Object.assign(this, {
			schema: k_schema,
			subject: p_subject,
			prefixes: h_prefixes,
			properties: expand_ct_pairs(hct_properties, h_prefixes),
			type: null,
		});

		// assert type
		if(pc_type) {
			this.assert_type(pc_type);
		}
	}

	assert_type(pc_type) {
		let {
			subject: p_subject,
			properties: hvt_properties,
		} = this;

		// no type defined
		if(!hvt_properties[pp_type]) throw new Error(`<${p_subject}> does not have any 'rdf:type' triples.`);

		// is not of proper type
		if(!hvt_properties[pp_type].includes(pc_type)) throw new Error(`<${p_subject}> is not of type <${pc_type}>.`);

		// save type association
		this.type = pc_type;
	}

	load_datatypes() {
		let {
			schema: k_schema,
			properties: hvt_properties,
		} = this;

		// hash of datatypes
		let h_datatypes = this.datatypes = {};

		// descriptor has datatypes
		if(hvt_properties[pp_datatype]) {
			// each datatype; load instance and save to hash
			for(let hvt_datatype of hvt_properties[pp_datatype]) {
				h_datatypes[hvt_datatype[pp_method][0].slice(1, -1)] = k_schema.select(datatype, hvt_datatype[pp_encoding][0]);
			}
		}
	}
}

class protocol extends implementation {
	constructor(g_protocol, k_schema, pi_select) {
		// assert type is protocol
		super(g_protocol, k_schema, pc_protocol);

		// destructure super's fields
		let {
			subject: p_subject,
			properties: hvt_properties,
		} = this;

		// destructure protocol config
		let {
			class: f_class,
		} = g_protocol;

		// missing class
		if(!f_class) throw new Error(`protocol descriptor for <${p_subject}> missing required key "class".`);

		// invalid class type
		if('function' !== typeof f_class) throw new TypeError(`protocol descriptor for <${p_subject}> has invalid type for "class"; expected mix-in (a function that returns a class) instead found: ${typeof f_class}`);

		// fetch set of interfaces it implements
		let a_implements = hvt_properties[pp_implements];
		
		// select not found in set of interfaces it implements
		if(!a_implements.includes(pi_select)) throw new Error(`<${p_subject}> does not implement <${pi_select}>.`);

		// the superclass to extend (default)
		let dc_super = frame;

		// it extends some protocol(s)
		if(hvt_properties[pp_extends]) {
			// ref the protocol(s) it extends
			let a_extends = hvt_properties[pp_extends];

			// too many
			if(a_extends.length > 1) throw new Error(`<${p_subject}> extends multiple protocols, cannot choose one to use for implementation`);

			// fetch super
			dc_super = k_schema.select(protocol, a_extends[0]);
		}

		// load datatypes
		this.load_datatypes();

		// hash of members
		let h_members = this.members = {};

		// descriptor has members
		if(hvt_properties[pp_member]) {
			// each member; save interface iri to hash
			for(let hvt_member of hvt_properties[pp_member]) {
				h_members[hvt_member[pp_method][0].slice(1, -1)] = hvt_member[pp_encoding][0];
			}
		}

		// create class
		this.class = f_class(dc_super);
	}

	load(at_payload, g_config) {
		let {
			schema: k_schema,
		} = this;

		// create buffer decoder for contents
		let kbd = new bkit.buffer_decoder(at_payload);

		// create decoder for datatypes
		let kd_datatypes = Object.create(kbd);

		// apply each decoder method
		for(let [si_method, k_datatype] of Object.entries(this.datatypes)) {
			kd_datatypes[si_method] = (...a_args) => k_datatype.decode(kd_datatypes, ...a_args);
		}

		// create decoder for members
		let kd_members = new decoder_member(kd_datatypes);

		// apply each decoder method
		for(let [si_method, pi_member] of Object.entries(this.members)) {
			kd_members[si_method] = (...g_member_config) => {
				// fetch encoding of member
				let p_member = kd_datatypes.ntu8_string();

				// fetch payload size in bytes
				let nb_payload = kd_datatypes.vuint();

				// load instance to satisfy interface requirement
				let k_member = k_schema.select(protocol, p_member, pi_member);

				// load payload contents into member
				return k_member.load(kd_datatypes.grab(nb_payload), g_member_config);
			};
		}

		// create frame
		return new this.class(kd_datatypes, kd_members);
	}
}

class datatype extends implementation {
	constructor(g_datatype, k_schema) {
		// assert type is datatype
		super(g_datatype, k_schema, pc_datatype);

		// destructure super's fields
		let {
			subject: p_subject,
			properties: hvt_properties,
		} = this;

		// destructure datatype config
		let {
			decode: f_decode,
		} = g_datatype;

		// missing decode function
		if(!f_decode) throw new Error(`datatype descriptor for <${p_subject}> missing required key "decode".`);

		// invalid decode type
		if('function' !== typeof f_decode) throw new TypeError(`datatype descriptor for <${p_subject}> has invalid type for "decode"; expected function, instead found: ${typeof f_decode}`);

		// load datatypes
		this.load_datatypes();

		// save fields
		Object.assign(this, {
			decode_method: f_decode,
		});
	}

	decode(k_self, ...a_args) {
		// create buffer decoder for contents
		let kbd = new bkit.buffer_decoder(k_self.contents);

		// create decoder for datatypes
		let kd_datatypes = Object.create(kbd);

		// apply each decoder method
		for(let [si_method, k_datatype] of Object.entries(this.datatypes)) {
			kd_datatypes[si_method] = (...a_args_sub) => k_datatype.decode(kd_datatypes, ...a_args_sub);
		}

		// okay
		return this.decode_method.apply(k_self, [k_self, ...a_args]);
	}
}

class decoder_member {
	constructor(kbd) {
		this.kbd = kbd;
	}
}

class frame {}


module.exports = function(at_data, hvt_schema=HVT_SCHEMA_DEFAULT) {
	// create schema instance from descriptor
	let k_schema = new schema(hvt_schema);

	// create buffer decoder to read serialized data
	let kbd = new bkit.buffer_decoder(at_data);

	// fetch the root encoding
	let p_root = kbd.ntu8_string();

	// fetch payload size in bytes
	let nb_payload = kbd.vuint();

	// load root protocol as dataset
	let kp_dataset = k_schema.select(protocol, p_root, pi_datset);

	// load dataset
	let k_dataset = kp_dataset.load(kbd.grab(nb_payload));

	return k_dataset;
};
