@import '../../../share/iris.jmacs'
@import '../../../share/channel.jmacs'

@./* global FORMAT */
@//@

@$ NT = 'nt' === FORMAT;
@$ NQ = 'nq' === FORMAT;
@$ QUADS = NQ;

@$ S_LABEL = NT? 'NTriples': 'NQuads';

@$ B_OPTIMIZE_UNESCAPE = true;
@$ B_UPGRADE_FACTORY = true;
@.{
	let SJ_DEFAULT_GRAPH;

	if(B_UPGRADE_FACTORY) {
		SJ_DEFAULT_GRAPH = /* syntax: js */ `kt_default_graph`;
	}
	else {
		SJ_DEFAULT_GRAPH = /* syntax: js */ `KT_DEFAULT_GRAPH`;
	}
}

@// import parser macros
@import '../../text.read.jmacs'

const stream = require('@{channel('core.iso.stream')}');
const factory = require('@{channel('core.data.factory')}')@{B_UPGRADE_FACTORY? '': '.raw'};

@- !B_UPGRADE_FACTORY
	const KT_DEFAULT_GRAPH = factory.defaultGraph();
	const KT_RDFS_LANG_STRING = factory.namedNode('@{P_IRI_RDFS}langString');
@;

const H_ESCAPES_JSON = @{H_ESCAPES_JSON()};

const R_ESCAPES = /@{R_ESCAPES()}/g;
const R_UNICODE_8 = /@{R_UNICODE_8()}/g;
const R_UNICODE_ANY = /@{R_UNICODE_4()}|@{R_UNICODE_8()}/g;

const F_REPLACE_UNICODE_ANY = @{F_REPLACE_UNICODE_ANY()};

@- B_OPTIMIZE_UNESCAPE
	const unescape_literal = s => @{unescape_literal('s')};
@;

const R_CLEAN = /\s*(?:#[^\n]*\n\s*)*\s*/y;
const R_CLEAN_COMMENTS = /\s*(#[^\n]*\n\s*)*\s*/y;
const R_LITERAL_ESCAPELESS = /^"([^\\"]*)"(?:\^\^<([^\\>]*)>|@([^ \t.]+)|)?$/;
const R_LITERAL = /^"(.*)"(?:\^\^<(.*)>|@([^ \t.]+)|)?$/;
const RT_HAS_ESCAPES = /[\\]/;
const R_EOL = /[^\n]+\n/y;

const RT_ABSOLUTE_IRI_VALID = /^[a-z][a-z0-9+\-.]*:([^\0-\x20<>"{}|^`\\]|@{UCHAR()})*$/;
// eslint-disable-next-line no-misleading-character-class
const RT_BLANK_NODE_LABEL_VALID = /^(?:[@{RANGE_PN_CHARS_U()}0-9])(?:(?:[@{RANGE_PN_CHARS()}.])*[@{RANGE_PN_CHARS()}])?$/u;
const RT_ESCAPES_INVALID = /@{RT_ESCAPES_INVALID()}/;
const RT_LITERAL_CONTENTS_VALID = /@{RT_LITERAL_CONTENTS_VALID('\\n\\r')}/;
const RT_LANGUAGE_VALID = /^[a-z]+(-[a-z0-9]+)*$/;

@>> R_NAMED_NODE(b_escapeless=false, b_open_cap=false)
	@//@regex
	@{b_open_cap? '(<': '<('}[^@{b_escapeless? '\\\\': ''}>]*)>
@;

@>> R_BLANK_NODE()
	@//@regex
	_:([^\x20\t<]+)
@;

@>> R_NODE(b_escapeless=false, b_open_cap=false)
	@//@regex
	@{R_NAMED_NODE(b_escapeless, b_open_cap)}
	| @{R_BLANK_NODE()}
@;

@>> R_LITERAL(b_escapeless=false)
	@//@regex
	"(@{b_escapeless? '[^"\\\\]': '(?:[^"\\\\]|\\\\.)'}*)"(?:\^\^@{R_NAMED_NODE(b_escapeless)}|@([^\x20\t.]+)|)
@;

@>> R_OBJECT(b_escapeless=false)
	@//@regex
	@{R_NODE(b_escapeless, true)}
	| @{R_LITERAL(b_escapeless)}
@;

@>> R_COMMENT()
	@//@regex
	\.\s*(#[^\n]*\n\s*|\n\s*)+
@;

@>> R_TRIPLE(b_escapeless=false)
	@//@regex
	(?:@{R_NODE(b_escapeless)})
	[\x20\t]* @{R_NAMED_NODE(b_escapeless)}
	[\x20\t]* (?:@{R_OBJECT(b_escapeless)})
	[\x20\t]* @{R_COMMENT()}
@;

@>> R_QUAD(b_escapeless=false)
	@//@regex
	(?:@{R_NODE(b_escapeless)})
	[\x20\t]* @{R_NAMED_NODE(b_escapeless)}
	[\x20\t]* (?:@{R_OBJECT(b_escapeless)})
	[\x20\t]* (?:@{R_NODE(b_escapeless)}|)
	[\x20\t]* @{R_COMMENT()}
@;

@- QUADS
	@$ STATEMENT_REGEX = 'R_QUAD';

	const R_QUAD_ESCAPELESS_SP = /@{R_QUAD(true)}/y;
	const R_QUAD = /@{R_QUAD()}/y;
@:
	@$ STATEMENT_REGEX = 'R_TRIPLE';

	const R_TRIPLE_ESCAPELESS_SP = /@{R_TRIPLE(true)}/y;
	const R_TRIPLE = /@{R_TRIPLE()}/y;
@;


@> unescape_iri(term)
	RT_HAS_ESCAPES.test(@{term})? @{term}.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY): @{term}
@;

@> clean()
	// remove whitespace & comments from beginning
	R_CLEAN.lastIndex = 0;
	let m_clean = R_CLEAN.exec(s);

	// comments
	if(this.emit_comments) {
		this.emit_comments(m_clean[1]);
	}

	// update index and prepare to match statement
	let i = R_CLEAN.lastIndex;
@;

@.{
	const ue_iri = (sv_iri, b_unescape=false) => b_unescape? unescape_iri(sv_iri): sv_iri;
}

@> match_body(sv_match, b_unescape=false)
	// prep object term
	let kt_object;

	// object term type is named node
	if(@{sv_match}[4]) {
		let p_object = @{sv_match}[4].slice(1);
		kt_object = namedNode(@{ue_iri('p_object', b_unescape)});
	}
	// object term type is blank node
	else if(@{sv_match}[5]) {
		kt_object = blankNode(@{ue_iri(sv_match+'[5]', b_unescape)});
	}
	// object term type is literal
	else {
		@- B_UPGRADE_FACTORY
			// contents
			let s_contents = @{sv_match}[6];
		@:
			kt_object = literal(@{sv_match}[6], @{b_unescape});
		@;

		// set datatype if present
		if(@{sv_match}[7]) {
			@- B_UPGRADE_FACTORY
				kt_object = datatypedLiteral@{b_unescape? 'E': ''}(s_contents, @{ue_iri(sv_match+'[7]')});
			@:
				kt_object.datatype = namedNode(@{ue_iri(sv_match+'[7]', b_unescape)});
			@;
		}
		// otherwise, set language tag if present
		else if(@{sv_match}[8]) {
			@- B_UPGRADE_FACTORY
				kt_object = languagedLiteral@{b_unescape? 'E': ''}(s_contents, @{sv_match}[8].toLowerCase());
			@:
				let s_language = kt_object.language = @{sv_match}[8].toLowerCase();
				
				if(!b_relax && !RT_LANGUAGE_VALID.test(s_language)) return this._error(`invalid literal language tag: ${s_language}`);
				
				kt_object.datatype = KT_RDFS_LANG_STRING;
			@;
		}
		@- B_UPGRADE_FACTORY
			// simple literal
			else {
				kt_object = simpleLiteral@{b_unescape? 'E': ''}(s_contents);
			}
		@;
	}

	// emit data event
	fk_data(
		@{B_UPGRADE_FACTORY? 'f_quad': 'factory.quad'}(
			@{sv_match}[2]
				? blankNode(@{sv_match}[2])
				: namedNode(@{ue_iri(sv_match+'[1]', b_unescape)}),
			namedNode(@{ue_iri(sv_match+'[3]', b_unescape)}),
			kt_object,
			@- QUADS
				@{sv_match}[9]
					? namedNode(@{ue_iri(sv_match+'[9]', b_unescape)})
					: (@{sv_match}[10]
						? blankNode(@{sv_match}[10])
						: ('string' === typeof @{sv_match}[9]
							? namedNode(@{ue_iri(sv_match+'[9]', b_unescape)})
							: @{SJ_DEFAULT_GRAPH}))
			@:
				@//@
				@{SJ_DEFAULT_GRAPH}
			@;
			@//@arguments
		)
		@//@arguments
	);

	// comments
	if(this.emit_comments) {
		this.emit_comments(@{sv_match}[@{QUADS? 11: 9}]);
	}
@;



@> parse_n({
	local: b_local=false,
}={})
	// match triples/quads
	for(;;) {
		@{if_match(STATEMENT_REGEX+'_ESCAPELESS_SP', 'm_statement_e_sp', true)}
			@{match_body('m_statement_e_sp')}
			
		@{else_if_match(STATEMENT_REGEX, 'm_statement', true)}
			@{match_body('m_statement', true)}

		@{else_if_match('R_EOL')}
			this._error(`Failed to read statement:\n\`${this.s.substr(i, 80).replace(/\n/g, '\u23CE')} [...]\`\n ^ starting here`);

		@{else_retry()}
	} // end of while

	// update unparsed data string
	@{b_local? 's': 'this.s'} = s.substr(i);
@;

class @{S_LABEL}_Reader extends stream.Transform {
	constructor(g_impls) {
		super({
			// do not decode strings into buffers
			decodeStrings: false,

			// accept strings as input on writable side
			writableObjectMode: false,

			// output quad objects on readable side
			readableObjectMode: true,

			// implementations
			flush: g_impls.flush,
			transform: g_impls.transform,
		});

		// when the writable side is piped into
		this.on('pipe', (ds_input) => {
			// input stream has encoding option; ensure stream encoding is utf8
			if('function' === typeof ds_input.setEncoding) {
				ds_input.setEncoding('utf8');
			}
		});
	}

	// intercept pipe
	pipe(ds_out) {
		let ds_dst = ds_out;

		// non-object mode
		if(!ds_dst._writableState.objectMode) {
			// transform to JSON
			ds_out = stream.quads_to_json();
		}
		// yet object mode and graphy writable
		else if(ds_out.isGraphyWritable) {
			// transform to quad-stream
			ds_out = stream.quads_to_writable();
		}

		// interim stream created
		if(ds_out !== ds_dst) {
			// forward output to super
			super.pipe(ds_out);

			// pipe outpu to destination
			return ds_out.pipe(ds_dst);
		}
		// forward as-is to super
		else {
			return super.pipe(ds_dst);
		}
	}
}

@> try_unescape_literal(sj_var, s_type)
	try {
		@{sj_var} = @{B_OPTIMIZE_UNESCAPE? `unescape_literal(${sj_var})`: unescape_literal(sj_var)};
	}
	catch(e_parse) {
		return this._error(`Invalid escaping within @{s_type}-literal contents: "${s_contents}"`);
	}
@;

class Reader {
	constructor(g_config) {
		let {
			// input medium
			input: g_input=null,

			// relax validation
			relax: b_relax=false,

			// debug
			debug: b_debug=false,
		} = g_config;

		@- B_UPGRADE_FACTORY
			// adopt factory
			let dc_factory = this._dc_factory = factory.adopt(g_config.dataFactory || g_config.data_factory || factory.unfiltered);

			this._f_quad = dc_factory.quad;
		@:
			let dc_factory = factory;
		@;

		// fields
		Object.assign(this, {
			// string buffer, accept left-over string from previous data chunk
			s: g_config.prepend || '',

			// string buffer length
			n: 0,

			_b_debug: b_debug,

			_b_relax: b_relax,

			_b_destroyed: false,
		});

		@- B_UPGRADE_FACTORY
			this._kt_default_graph = dc_factory.defaultGraph();
			this._kt_rdfs_lang_string = dc_factory.namedNode('@{P_IRI_RDFS}langString');
		@;

		// clean regex
		let r_clean = R_CLEAN;

		if(g_config.relaxed) {
			console.warn((new Error(`no such option 'relaxed'; did you mean 'relax' ?`)).stack.replace(/^Error:/, 'Warning:'));
		}
		if('validate' in g_config) {
			console.warn((new Error(`option 'validate' has been removed and validation is now on by default. Use 'relax' option if you wish to disable validation.`)).stack.replace(/^Error:/, 'Warning:'));
		}

		// validation
		let k_self = this;
		Object.assign(this, !b_relax
			? {
				namedNode(s_iri) {
					if(!RT_ABSOLUTE_IRI_VALID.test(s_iri)) return k_self._error(`Invalid absolute IRI: "${s_iri}"`);
					return dc_factory.namedNode(s_iri);
				},

				blankNode(s_label) {
					if(!RT_BLANK_NODE_LABEL_VALID.test(s_label)) return k_self._error(`Invalid blank node label: "${s_label}"`);
					return dc_factory.blankNode(s_label);
				},

				@- !B_UPGRADE_FACTORY
					literal(s_literal, b_unescape=false) {
						if(!RT_LITERAL_CONTENTS_VALID.test(s_literal)) return k_self._error(`Invalid literal: "${s_literal}"`);
						try {
							return dc_factory.literal(b_unescape? @{unescape_literal('s_literal')}: s_literal);
						}
						catch(e_parse) {
							return k_self._error(`Invalid literal contents: "${s_literal}"`);
						}
					},
				@;


				@*{
					for(let b_escape of [false, true]) {
						for(let s_type of ['simple', 'languaged', 'datatyped']) {
							let sj_extra = '';
							let sj_test = '';
							let sj_thru = '';

							if('languaged' === s_type) {
								sj_extra = sj_thru = ', s_language';
								sj_test = /* syntax: js */ `
									if(!RT_LANGUAGE_VALID.test(s_language)) {
										return k_self._error(\`Invalid literal language tag: \${s_language}\`);
									}
								`;
							}
							else if('datatyped' === s_type) {
								sj_extra = ', p_datatype';
								sj_thru = /* syntax: js */ `, k_self.namedNode(p_datatype)`;
							}

							yield /* syntax: js.object-literal */ `
								${s_type}Literal${b_escape? 'E': ''}(s_contents${sj_extra}) {
									if(!RT_LITERAL_CONTENTS_VALID.test(s_contents)) {
										return k_self._error(\`Invalid ${s_type}-literal contents: "\${s_contents}"\`);
									}

									${sj_test}

									${b_escape? try_unescape_literal('s_contents', s_type): ''}

									return dc_factory.${s_type}Literal(s_contents${sj_thru});
								},
							`;
						}
					}
				}
			}
			: {
				namedNode: dc_factory.namedNode,

				blankNode: dc_factory.blankNode,

				@- !B_UPGRADE_FACTORY
					literal: (s_literal, b_unescape) => dc_factory.literal(b_unescape? @{unescape_literal('s_literal')}: s_literal),
				@;

				simpleLiteral: dc_factory.simpleLiteral,

				languagedLiteral: dc_factory.languagedLiteral,

				datatypedLiteral: (s_contents, p_datatype) => dc_factory.datatypedLiteral(s_contents, dc_factory.namedNode(p_datatype)),

				@*{
					for(let s_type of ['simple', 'languaged', 'datatyped']) {
						let sj_extra = '';
						let sj_thru = '';

						if('languaged' === s_type) {
							sj_extra = sj_thru = ', s_language';
						}
						else if('datatyped' === s_type) {
							sj_extra = ', p_datatype';
							sj_thru = /* syntax: js */ `, dc_factory.namedNode(p_datatype)`;
						}

						yield /* syntax: js.object-literal */ `
							${s_type}LiteralE(s_contents${sj_extra}) {
								${try_unescape_literal('s_contents', s_type)}

								return dc_factory.${s_type}Literal(s_contents${sj_thru});
							},
						`;
					}
				}
			});

		// transform stream
		let ds_transform;

		// whether or not data has been received before
		let b_init = false;

		// create transform
		ds_transform = this.transform = new @{S_LABEL}_Reader({
			// on data event
			transform: (s_chunk, s_encoding, fk_chunk) => {
				// first transform
				if(!b_init) {
					// notify that data will begin
					ds_transform.emit('ready');

					// do not emit 'ready' event again
					b_init = false;
				}

				// concatenate current chunk to previous chunk
				let s = this.s += s_chunk;

				// remove whitespace & comments from beginning
				r_clean.lastIndex = 0;
				let m_clean = r_clean.exec(s);
				if(this.emit_comments) {
					this.emit_comments(m_clean[1]);
				}

				// update index and prepare to match statement
				this.i = r_clean.lastIndex;

				// cache chunk length
				this.n = s.length;

				// resume parsing
				try {
					this.safe_parse(true);
				}
				// read error occurred; emit and destroy stream
				catch(e_read) {
					return ds_transform.destroy(e_read);
				}

				// emit progress event updates
				ds_transform.emit('progress', s_chunk.length);

				// done transforming this chunk
				fk_chunk();
			},

			// once there's no more data to consume, invoke eof
			flush: (fk_flush) => {
				// there is still unparsed data
				if(this.s.length) {
					// append newline to end so we can match token
					this.s += '\n';

					// parse safely
					try {
						this.safe_parse();
					}
					// read error occurred; pass to flush errback and exit method
					catch(e_read) {
						// destroying during flush means overriding push
						return ds_transform.demolish(e_read);
					}

					// still unparsed characters; pass to flush errback and exit method
					if(this.s.length) {
						return ds_transform.demolish(new Error(`parsing error occurred in state: statement\n  ${this.s.substr(0, 50)}\n  ^ starting here`));
					}
				}

				// make buffer's alloc eligible for gc
				this.s = null;

				// final progress update: no additional bytes were read
				ds_transform.emit('progress', 0);

				// call end event listener
				ds_transform.emit('eof');

				// done flushing, close read stream
				fk_flush();
			},
		});
		
		// data event
		this.data = g_quad => ds_transform.push(g_quad);

		// new listener added
		ds_transform.on('newListener', (s_event) => {
			// comment
			if('comment' === s_event) {
				r_clean = R_CLEAN_COMMENTS;
				this.emit_comments = (s_captured) => {
					if(!s_captured) return;
					let a_comments = s_captured.slice(1).replace(/\n\s+$/, '').split(/\n+\s*#/g);

					for(let s_comment of a_comments) {
						ds_transform.emit('comment', s_comment);
					}
				};
			}
		});

		// bind events to transform stream
		this.bind(g_config);

		// input given
		if(g_input) {
			// input is stream
			if(g_input.stream) {
				let ds_input = g_input.stream;

				// go async so caller has chance to bind event listeners
				setTimeout(() => {
					ds_input.pipe(ds_transform);
				}, 0);
			}
			// string
			else if('string' === typeof g_input.string) {
				let s_input = g_input.string;

				// go async so caller has chance to bind event listeners
				setTimeout(() => {
					ds_transform.end(s_input, 'utf8');
				}, 0);
			}
			// invalid arg
			else {
				throw new TypeError(`Invalid argument for input parameter: ${'object' === typeof g_input? JSON.stringify(g_input): g_input}`);
			}
		}

		ds_transform._graphy_reader = this;
	}

	_error(s_message) {
		this._b_destroyed = true;
		throw new Error(s_message);
	}


@$ H_PARSE_EVENTS = {
	error: {},
	comment: {},
	read: {once:true},
	progress: {},
	eof: {once:true},
	end: {once:true},
	finish: {once:true},
	data: {},  // attach data listener last
};

	bind(g_config) {
		let ds_transform = this.transform;
		@*{
			for(let [s_event, g_event] of Object.entries(H_PARSE_EVENTS)) {
				yield /* syntax: js */ `
					if(g_config.${s_event}) ds_transform.${g_event.once? 'once': 'on'}('${s_event}', g_config.${s_event});
					`.trim()+'\n';
			}
		}
	}

	safe_parse() {
		let s = this.s;
		let n = this.n;
		let i = this.i;
		let fk_data = this.data;
		let f_quad = this._f_quad;
		let namedNode = this.namedNode;
		let blankNode = this.blankNode;
		@- B_UPGRADE_FACTORY
			let simpleLiteral = this.simpleLiteral;
			let languagedLiteral = this.languagedLiteral;
			let datatypedLiteral = this.datatypedLiteral;
			let simpleLiteralE = this.simpleLiteralE;
			let languagedLiteralE = this.languagedLiteralE;
			let datatypedLiteralE = this.datatypedLiteralE;
			let kt_default_graph = this._kt_default_graph;
		@:
			let literal = this.literal;
			let b_relax = this._b_relax;
		@;

		@// parse chunk
		@{parse_n()};
	}
}


module.exports = function(...a_args) {
	let g_config = {};

	@{normalize_reader_config('g_config')}

	// create reader, return transform stream
	return (new Reader(g_config)).transform;
};
