@./* global FORMAT */
@//@

@import '../../../share/polyfills.jmacs'

@{polyfill.queueMicrotask()}

@$ S_LABEL = 'nt' === FORMAT? 'NTriples': 'NQuads';

const path = require('path');
const stream = require('@graphy/core.iso.stream');
const reader = require('@graphy/content.@{FORMAT}.read');
const wt = require('worker_threads');
const H_PRESET_TASKS = require('./task-presets.js');

// fast 4 byte writer from bkit
const f_writer_uintle32 = (at, ib, x) => {
	at[ib] = x & 0xff;
	at[ib+1] = (x >>> 8) & 0xff;
	at[ib+2] = (x >>> 16) & 0xff;
	at[ib+3] = (x / 0x1000000) & 0xff;
	return at;
};

const N_DEFAULT_SLOTS_PER_WORKER = 3;

@$ XC_SLOT_OWNER_MASTER = 0x00;
@$ XC_SLOT_OWNER_NONE = 0xff;

@$ XC_SLOT_AVAILABLE = 0x00;
@$ XC_SLOT_TRANSACTING = 0x01;

@$ XC_INDICATOR_EOF = -1;

// adapted from https://www.npmjs.com/package/physical-cpu-count
let NL_WORKERS_ADVISE = (() => {
	const cp = require('child_process');
	const os = require('os');

	const exec = s_cmd => cp.execSync(s_cmd, {encoding:'utf8'});

	switch(os.platform()) {
		case 'linux': {
			let s_out = exec('lscpu -p | egrep -v "^#" | sort -u -t, -k 2,4 | wc -l');
			return parseInt(s_out.trim(), 10);
		}

		case 'darwin': {
			let s_out = exec('sysctl -n hw.physicalcpu_max');
			return parseInt(s_out.trim(), 10);
		}

		case 'windows': {
			let s_out = exec('WMIC CPU Get NumberOfCores');
			return s_out.split(os.EOL)
				.map(s => parseInt(s))
				.filter(n => !isNaN(n))
				.reduce((c_out, n) => c_out + n, 0);
		}

		default: {
			return os.cpus().filter((g_cpu, i_cpu) => {
				let b_hyperthreading = g_cpu.model.includes('Intel');
				let b_odd = 1 === (i_cpu % 2);
				return !b_hyperthreading || b_odd;
			}).length;
		}
	}
})() - 1;

@$ H_SCAN_EVENTS = {
	error: {},
	update: {},
	report: {once:true},
	// comment: {},
	// progress: {},
	eof: {once:true},
	end: {once:true},
	// finish: {once:true},
	// data: {},  // attach data listener last
};


function Scanner$kill(k_self, e_reason) {
	// kill all workers
	Promise.all(k_self._a_workers.map(d => d.terminate()))
		.then(() => queueMicrotask(() => {
			k_self.emit('error', e_reason);
		}));
}

function Scanner$handle_worker_message(k_self, i_worker) {
	return (g_msg) => {
		switch(g_msg.type) {
			// update
			case 'update': {
				k_self._update(g_msg.value, i_worker);
				break;
			}

			// report
			case 'report': {
				// console.log(`received result from worker ${i_worker}: ${g_msg.value}; ${a_reports.length+1} results`);

				// reduce
				k_self._w_reduced = k_self._f_reduce(k_self._w_reduced, g_msg.value);

				// all results have been collected
				if(k_self._nl_workers === ++k_self._c_reports) {
					if(k_self._b_eofed) {
						k_self._f_report(k_self._w_reduced);
					}
					else {
						k_self._b_collected = true;
					}
				}

				break;
			}

			// error
			case 'error': {
				// error struct
				let g_error = g_msg.value;

				// reconstruct error
				let e_throw = new Error(g_error.message);
				e_throw.stack = g_error.stack;

				// kill workers and throw error
				return Scanner$kill(k_self, e_throw);
			}

			// throw
			case 'throw': {
				// ref error struct
				let z_throw = g_msg.value;

				// issue warning
				console.warn(`WARNING: Your code (or some library) on the worker is throwing an object which is not an instance of Error. I am going to put it into an Error for you now, but please fix this. The object.toString() is: "${z_throw}"`);

				// construct error
				let e_wrap = new Error(z_throw+'');

				// kill workers and throw error
				return Scanner$kill(k_self, e_wrap);
			}

			// clone error
			case 'clone-error': {
				// ref error struct
				let g_clone = g_msg.value;

				// construct error
				let e_clone = new Error(`You are trying to call '${g_clone.info}' on some object from within one of the workers, but that object is not serializable using the structured clone algorithm. The object.toString() is: "${g_clone.obejct}"... the error about the worker failing to send the original error to the master thread is:\n${g_clone.error}`);

				// kill workers and throw error
				return Scanner$kill(k_self, e_clone);
			}


			// other
			default: {
				console.assert(`invalid worker message type: ${g_msg.type}`);
			}
		}
	};
}


// fill open slots with next chunk from input stream
function Scanner$fill_slots(k_self) {
	let ds_input = k_self._ds_input;
	let a_slots_open = k_self._a_slots_open;
	let nb_high_water_mark = k_self._nb_high_water_mark;
	let nb_slot = k_self._nb_slot;
	let atu8_data = k_self._atu8_data;
	let atu8_slot_owners = k_self._atu8_slot_owners;
	let at32_indicators = k_self._at32_indicators;
	let a_slot_states = k_self._a_slot_states;
	let ab_prev = k_self._ab_prev;
	let ds_reader = k_self._ds_reader;

	if(!ds_input.readable) {
		throw new Error(`input should not read readable...`);
	}

	let ab_chunk;

	// while there are open slots
	while(a_slots_open.length) {
		// read chunk from input stream
		ab_chunk = ds_input.read();

		// info(`read: ${null === ab_chunk? 'null': ab_chunk.length+' bytes'}`);

		// buffer is drained
		if(null === ab_chunk) {
			break;
		}

		// chunk size exceeds high water mark
		if(ab_chunk.length > nb_high_water_mark) {
			throw new Error(`chunk exceeded high water mark: ${ab_chunk.length} bytes > ${nb_high_water_mark} bytes`);
		}

		// read head/tail
		let ib_head = ab_chunk.indexOf(0x0a) + 1;
		let ib_tail = ab_chunk.lastIndexOf(0x0a) + 1;

		// take next open slot
		let i_slot = a_slots_open.shift();

		// slot position
		let ib_slot = i_slot * nb_slot;

		// payload size
		let nb_payload = ib_tail - ib_head;
		f_writer_uintle32(atu8_data, ib_slot, nb_payload);

		// fill it
		ab_chunk.copy(atu8_data, ib_slot+4, ib_head, ib_tail);

		// mark slot ready
		atu8_slot_owners[i_slot] = @{XC_SLOT_OWNER_NONE};
		// a_slot_owners_internal[i_slot] = XC_SLOT_OWNER_NONE;
		// Atomics.store(atu8_slot_owners, i_slot, XC_SLOT_OWNER_NONE);

		// info(`(slot_owner[${i_slot}] = NONE) === ${slot_owner(i_slot)}; payload size === ${f_reader_uintle32(atu8_data, ib_slot)}`);

		// set indicator & notice
		// at32_indicator[0] += 1;
		Atomics.add(at32_indicators, 0, 1);
		// log(`(indicator += 1) === ${at32_indicators[0]}`);
		let n_awoke = Atomics.notify(at32_indicators, 0);
		// log(`woke ${n_awoke} sleeping threads}`);


		// // save to expected queue
		// a_expected.push(i_slot);

		// set slot state
		a_slot_states[i_slot] = @{XC_SLOT_TRANSACTING};

		// log(`(slot_states[${i_slot}] = AWAITING(${XC_SLOT_TRANSACTING})) === ${slot_state(i_slot)}`);
		// log(`slot_owner[${i_slot}] === ${slot_owner(i_slot)}`);

		// // store association
		// a_slots_order[i_slot] = i_chunk;

		// join head with prev
		let ab_head = ab_chunk.slice(0, ib_head);
		let ab_write = Buffer.concat([ab_prev, ab_head], ab_prev.length+ab_head.length);

		let s_write = ab_write.toString('utf8');

		// write to reader
		ds_reader.write(s_write);

		// info(`wrote: """${s_write}"""`);

		// save tail to prev
		ab_prev = ab_chunk.slice(ib_tail-1);
	}

	// update prev chunk value
	k_self._ab_prev = ab_prev;

	// buffer is drained
	if(0 === ds_input.readableLength) {
		// but did not reach null
		if(null !== ab_chunk) {
			// trigger
			let z_read = ds_input.read();

			// assert null
			if(null !== z_read) {
				throw new Error(`expected to reach null in paused stream readable but received ${z_read? 'chunk data instad': 'skipped event'}`);
			}
		}

		// await readable
		return true;
	}

	// // whether or not to await readable
	// return 0 === ds_input.readableLength;

	// have not consumed everything
	return false;
}

// drain returned slots
function Scanner$drain_slots(k_self) {
	let nl_slots = k_self._nl_slots;
	let atu8_slot_owners = k_self._atu8_slot_owners;
	let a_slot_states = k_self._a_slot_states;
	let a_slots_open = k_self._a_slots_open;

	let c_drained = 0;

	// read results
	for(let i_slot=0; i_slot<nl_slots; i_slot++) {
		// log(`read // slot_owner[${i_slot}] === ${slot_owner(i_slot)} (internal
		//   => ${a_slot_owners_internal[i_slot]}) / slot_states[${i_slot}] ===
		//     ${slot_state(i_slot)}`);

		// slot returned
		if(@{XC_SLOT_OWNER_MASTER} === atu8_slot_owners[i_slot] && @{XC_SLOT_TRANSACTING} === a_slot_states[i_slot]) {
			// green(`master reclaiming slot ${i_slot}`);

			// update slot state
			a_slot_states[i_slot] = @{XC_SLOT_AVAILABLE};

			// mark slot as open
			a_slots_open.push(i_slot);

			// number of slots drained
			c_drained += 1;
		}
	}

	return c_drained;
}



function Scanner$on_pipe(k_self, ds_input) {
	k_self._ds_input = ds_input;

	// byte size ofhigh water mark
	let nb_high_water_mark = k_self._nb_high_water_mark = Math.max(0x10000, ds_input.readableHighWaterMark);

	let nl_workers = k_self._nl_workers;

	let nl_slots = k_self._nl_slots = k_self._n_slots_per_worker * nl_workers;

	let nb_slot = k_self._nb_slot = 4 + nb_high_water_mark;

	let nl_indicators = 2;
	let nb_indicators = nl_indicators * 4;

	let nb_slot_owners = nl_slots * 1;
	let nb_region = (nb_indicators)  // indicators
		+ (nb_slot_owners)  // slot owners
		+ (nb_slot * nl_slots);  // slot data

	// create shared memory region
	let ab_share = new SharedArrayBuffer(nb_region);

	// indicators
	let at32_indicators = k_self._at32_indicators = new Int32Array(ab_share, 0, nl_indicators);

	// slot owner and data byte positions
	let ib_slots = 0 + nb_indicators;
	let ib_data = ib_slots + (nb_slot_owners);

	// slot owners
	let atu8_slot_owners = k_self._atu8_slot_owners = new Uint8Array(ab_share, ib_slots, nl_slots);

	// slot data
	let atu8_data = k_self._atu8_data = new Uint8Array(ab_share, ib_data);


	// initially, all slots are claimed by master thread
	for(let i_slot=0; i_slot<nl_slots; i_slot++) {
		// set slot owner to master thread
		atu8_slot_owners[i_slot] = @{XC_SLOT_OWNER_MASTER};
		// a_slot_owners_internal.push(XC_SLOT_OWNER_MASTER);

		// push open slot to queue
		k_self._a_slots_open.push(i_slot);

		// set initial slot state
		k_self._a_slot_states.push(@{XC_SLOT_AVAILABLE});
	}


	// spawn workers
	{
		let a_workers = k_self._a_workers;

		let g_worker_data = {
			sjx_map: k_self._sjx_map,
			// ab_share,
			nl_workers,
			nl_slots,
			nb_slot,
			at32_indicators,
			// nb_region,
			atu8_slot_owners,
			atu8_data,
		};

		// each worker
		for(let i_worker=1; i_worker<=nl_workers; i_worker++) {
			// spawn
			let d_worker = new wt.Worker(path.join(__dirname, 'worker.js'), {
				workerData: {
					...g_worker_data,
					i_worker,
				},
			});

			// on message event
			d_worker.on('message', Scanner$handle_worker_message(k_self, i_worker));

			// push to worker list
			a_workers.push(d_worker);
		}
	}

	// remove pipe dest; switching to paused mode
	ds_input.unpipe(k_self);

	// each time the input stream emits readable (this switches to paused mode)
	ds_input.on('readable', () => {
		k_self._tick();
	});

	// end
	ds_input.on('end', () => {
		// set indicator and notify
		Atomics.store(at32_indicators, 0, @{XC_INDICATOR_EOF});
		let c_notified = Atomics.notify(at32_indicators, 0);

		// reassign tick function
		k_self._tick = () => {};

		// end writable side of content reader
		k_self._ds_reader.end();
	});
}

class @{S_LABEL}_Scanner extends stream.Writable {
	constructor(gc_scanner) {
		super();

		// flags
		this._b_eofed = false;
		this._b_collected = false;

		// worker and slot settings
		this._nl_workers = gc_scanner.workers || NL_WORKERS_ADVISE;
		this._n_slots_per_worker = gc_scanner.slots_per_worker || gc_scanner.slotsPerWorker || N_DEFAULT_SLOTS_PER_WORKER;

		// report count
		this._c_reports = 0;

		// list of workers
		this._a_workers = [];

		// queue of open slots
		this._a_slots_open = [];

		// slot states
		this._a_slot_states = [];

		// previous chunk fragment
		this._ab_prev = Buffer.allocUnsafe(0);

		@*{
			for(let [s_event, g_event] of Object.entries(H_SCAN_EVENTS)) {
				yield /* syntax: js */ `
					if(gc_scanner.${s_event}) this.${g_event.once? 'once': 'on'}('${s_event}', gc_scanner.${s_event});
					`.trim()+'\n';
			}
		}

		// once input is piped in
		this.on('pipe', (ds_input) => {
			Scanner$on_pipe(this, ds_input);
		});

		// default preset config
		let g_preset = {};

		// preset given
		if(gc_scanner.preset) {
			let si_preset = gc_scanner.preset;

			// no such preset name
			if(!H_PRESET_TASKS[si_preset]) {
				throw new Error(`No such @{S_LABEL}_Scanner preset named '${si_preset}'`);
			}

			// generate preset config
			g_preset = H_PRESET_TASKS[gc_scanner.preset](gc_scanner);
		}
		
		// task config
		let g_task = {
			...g_preset,
			...(gc_scanner.task || {}),
			...gc_scanner,
		};

		// map function
		let sjx_map = this._sjx_map = g_task.map;

		// missing map function
		if('string' !== typeof sjx_map || !sjx_map) {
			throw new TypeError('Invalid \'.map\' property supplied to @{S_LABEL}_Scanner constructor; must be a non-empty string.');
		}

		// try creating map function
		let f_map;
		try {
			f_map = (new Function(`return (${sjx_map})`))();  // eslint-disable-line no-new-func
		}
		catch(e_eval) {
			throw new Error(`Failed to evaluate the '.map' property supplied to @{S_LABEL}_Scanner constructor as JavaScript code:\n${e_eval.stack || e_eval}`);
		}

		// reduce property supplied
		if(g_task.reduce) {
			let sjx_reduce = g_task.reduce;

			// invalid reduce property
			if('string' !== typeof sjx_reduce) {
				throw new TypeError('Invalid \'.reduce\' property supplied to @{S_LABEL}_Scanner constructor; if present, it must be a non-empty string.');
			}

			// try creating reduce function
			try {
				this._f_reduce = (new Function(`return (${g_task.reduce})`))();  // eslint-disable-line no-new-func
			}
			catch(e_eval) {
				throw new Error(`Failed to evaluate the '.reduce' property supplied to @{S_LABEL}_Scanner constructor as JavaScript code:\n${e_eval.stack || e_eval}`);
			}
		}

		let k_self = this;

		// create content reader
		let ds_reader = this._ds_reader = f_map(reader, ...[
			// 'report' results
			function report(w_value) {
				k_self._w_reduced = w_value;
			},

			// 'update' with some info
			function update(w_msg) {
				k_self._f_update(w_msg, 0);
			},

			// handle errors
			function err(z_what) {
				// proper error instance
				if(z_what instanceof Error) {
					// kill workers and handle error
					Scanner$kill(k_self, z_what);
				}
				// invalid error type
				else {
					// issue warning
					console.warn(`WARNING: Your code (or some library) on the main thread is throwing an object which is not an instance of Error. I am going to put it into an Error for you now, but please fix this. The object.toString() is: "${z_what}"`);

					// construct error
					let e_wrap = new Error(z_what+'');

					// kill workers and throw error
					Scanner$kill(k_self, e_wrap);
				}
			},
		]);

		// once main thread content reader has finished
		ds_reader.once('eof', () => {
			// all results collected from workers
			if(this._b_collected) {
				this._f_report(this._w_reduced);
			}
			// set flag that we eof'd
			else {
				this._b_eofed = true;
			}
		});
	}

	_tick(b_softlock) {
		let at32_indicators = this._at32_indicators;

		// log(`---------- ${b_retick? '(re)': ''}tick ---------`);

		// grab indicator
		let xc_indicator_reclaim = Atomics.load(at32_indicators, 1);

		// fill slots, return value indicates exitting due to slots being full
		let b_await_readable = Scanner$fill_slots(this);

		// drain slots
		let n_drained = Scanner$drain_slots(this);

		// need to explicitly recall tick
		if(!b_await_readable) {
			// something drained
			if(n_drained) {
				// log(`drained ${n_drained} slots`);

				// retick, avoiding recursion
				queueMicrotask(() => {
					this._tick();
				});
			}
			// nothing drained
			else {
				// log(`awaiting indicator ${xc_indicator_reclaim}....`);

				// avoid recursion; use setImmediate
				setImmediate(() => {
					// await change
					let s_status = Atomics.wait(at32_indicators, 1, xc_indicator_reclaim, 2000);

					// awaiting lock timed out
					if('timed-out' === s_status) {
						// this could be a softlock
						if(b_softlock) {
							console.warn(`WARNING: @{S_LABEL}_Scanner main thread waited more than 2000ms for a response from one of its ${this._nl_workers} worker(s); now escaping potential softlock`);
						}

						// set indicator and notify
						Atomics.add(at32_indicators, 0, 1);
						Atomics.notify(at32_indicators, 0);

						// tick next
						return this._tick(true);
					}
					// else if('not-equal' === s_status) {
					// 	log(`awaited indicator: ${s_status}; ${Atomics.load(at32_indicators, 1)}`);
					// }

					// log(`awaited indicator: ${s_status}; ${at32_indicators[1]}`);

					// retick
					this._tick();
				});
			}
		}
	}
}

Object.assign(@{S_LABEL}_Scanner.prototype, {
	// default reduce function
	_f_reduce() {},

	// update handler
	_f_update(w_report) {
		if(!this.emit('update', w_report)) {
			console.warn(`WARNING: @{S_LABEL}_Scanner emitted an 'update' event but no listener function is attached`);
		}
	},

	// report handler
	_f_report(w_report) {
		if(!this.emit('report', w_report)) {
			console.warn(`WARNING: @{S_LABEL}_Scanner emitted a 'report' event but no listener function is attached`);
		}
	},
});



module.exports = function(...a_args) {
	// create reader, return transform stream
	return (new @{S_LABEL}_Scanner(...a_args));
};

