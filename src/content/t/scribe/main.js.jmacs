@./* global FORMAT */

@//@
@import '../../../share/channel.jmacs'
@import '../../../share/writer.jmacs'

@$ B_TTL = 'ttl' === FORMAT;
@$ B_TRIG = 'trig' === FORMAT;

@$ B_QUADS = B_TRIG;

@$ S_LABEL = B_TTL? 'Turtle': 'TriG';

const factory = require('@{channel('core.data.factory')}');
const Scribable = require('@{channel('core.class.scribable')}');

const {
	terse,
	c1_to_terse,
} = factory;

@- B_QUADS
	const KT_DEFAULT_GRAPH = factory.defaultGraph();
@;

@$ B_OPTIMIZE_BUFFER = true;

function terse_s(yt_subject, h_prefixes) {
	if('NamedNode' === yt_subject.termType) {
		return terse(yt_subject.value, h_prefixes);
	}
	else {
		return '_:'+yt_subject.value;
	}
}


@- B_QUADS
	function terse_g(yt_subject, h_prefixes) {
		switch(yt_subject.termType) {
			// default graph
			case 'DefaultGraph': return '';

			// named node
			case 'NamedNode': return terse(yt_subject.value, h_prefixes);

			// blank node
			default: return '_:'+yt_subject.value;
		}
	}
@;


const terse_p = (yt_predicate, h_prefixes) => terse(yt_predicate.value, h_prefixes);

const P_IRI_XSD_STRING = 'http://www.w3.org/2001/XMLSchema#';
function terse_o(yt_object, h_prefixes) {
	switch(yt_object.termType) {
		// named node
		case 'NamedNode': return terse(yt_object.value, h_prefixes);

		// literal
		case 'Literal': {
			let s_contents = JSON.stringify(yt_object.value);

			if(yt_object.language) {
				return s_contents+'@'+yt_object.language;
			}
			else if(P_IRI_XSD_STRING === yt_object.datatype.value) {
				return s_contents;
			}
			else {
				return s_contents+'^^'+terse(yt_object.datatype.value, h_prefixes);
			}
		}

		// blank node
		default: return '_:'+yt_object.value;
	}
}



class @{S_LABEL}_Scriber extends Scribable {
	constructor(gc_scriber={}) {
		super(gc_scriber);

		@- B_QUADS
			this._yt_graph = KT_DEFAULT_GRAPH;
		@;
		this._yt_subject = null;
		this._yt_predicate = null;

		// update prefixes and push to output
		this.push(this._update_prefixes(gc_scriber.prefixes));
	}

	_update_prefixes(h_prefixes_in) {
		// cache prefixes
		let h_prefixes = this._h_prefixes = factory.cache_prefixes(h_prefixes_in || {}, true);

		// serialize prefixes
		let st_prefixes = '';
		for(let si_prefix in h_prefixes) {
			st_prefixes += `@prefix ${si_prefix}: ${factory.namedNode(h_prefixes[si_prefix]).verbose()} .\n`;
		}

		// write prefixes
		return st_prefixes+'\n';
	}

	_serialize_c3x(hc3x_triples) {
		// ref prefixes
		let h_prefixes = this._h_prefixes;

		// string building
		let st_build = '';

		let b_subjects = false;

		for(let sc1_subject in hc3x_triples) {
			// quick convert subject from concise term to terse
			let st1_subject = c1_to_terse(sc1_subject, h_prefixes);

			// not a term; skip
			if(!st1_subject) continue;

			if(b_subjects) st_build += ' .\n\n';
			b_subjects = true;

			// 
			st_build += st1_subject+' ';

			let b_predicates = false;

			// each predicate
			let hc2x_pairs = hc3x_triples[sc1_subject];
			for(let sc1_predicate in hc2x_pairs) {
				// quick convert predicate from concise term to terse
				let st1_predicate = c1_to_terse(sc1_predicate, h_prefixes);

				// not a term; skip
				if(!st1_predicate) continue;

				// 
				if(b_predicates) st_build += ' ;\n\t';
				b_predicates = true;

				st_build += st1_predicate+' ';

				let b_objects = false;

				// each object
				for(let sc1_object of hc2x_pairs[sc1_predicate]) {
					// quick convert object from concise term to terse
					let st1_object = c1_to_terse(sc1_object, h_prefixes);

					// not a term; skip
					if(!st1_object) continue;

					if(b_objects) st_build += ', ';
					b_objects = true;

					st_build += st1_object;
				}
			}
		}

		if(b_subjects) st_build += ' .\n\n';

		// reset all markers
		@- B_QUADS
			this._yt_graph = KT_DEFAULT_GRAPH;
		@;
		this._yt_subject = null;
		this._yt_predicate = null;

		@- B_OPTIMIZE_BUFFER
			this._st_buffer = '';
		@;

		return st_build;
	}

	@- B_OPTIMIZE_BUFFER
		_serialize_quad(g_quad) {
			let h_prefixes = this._h_prefixes;

			let {
				subject: yt_subject,
				predicate: yt_predicate,
				object: yt_object,
				@- B_QUADS
					graph: yt_graph,
				@;
			} = g_quad;

			@- B_QUADS
				// same graph
				if(yt_graph.equals(this._yt_graph)) {
			@;

			// same subject
			if(yt_subject.equals(this._yt_subject)) {
				// same prediate
				if(yt_predicate.equals(this._yt_predicate)) {
					// write object
					this._st_buffer += ', '+terse_o(yt_object, h_prefixes);
				}
				// different predicate
				else {
					// write pair
					this._st_buffer += ' ;\n\t'+terse_p(yt_predicate, h_prefixes)+' '+terse_o(yt_object, h_prefixes);

					// update prediate
					this._yt_predicate = yt_predicate;
				}
			}
			// subject not identical to previous
			else {
				let st_line = terse_s(yt_subject, h_prefixes)+' '+terse_p(yt_predicate, h_prefixes)+' '+terse_o(yt_object, h_prefixes);

				// different subject
				if(this._yt_subject) {
					// write triple
					this._st_buffer += ' .\n\n'+st_line;
				}
				// first subject
				else {
					this._st_buffer += st_line;
				}

				// save subject and predicate
				this._yt_subject = yt_subject;
				this._yt_predicate = yt_predicate;
			}

			@- B_QUADS
				}
				// graph not identical to previous
				else {
					// what to write this call
					let s_write = '';

					// different graph
					if(this._yt_graph) {
						// close graph
						s_write = ' .\n}\n\n';
					}

					// write graph
					this._st_buffer += s_write+terse_g(yt_graph, h_prefixes)+' {\n';

					// save graph
					this._yt_graph = yt_graph;
					this._yt_subject = yt_subject;
					this._yt_predicate = yt_predicate;
				}
			@;

			// internal buffer high water mark
			if(this._s_buffer.length > this._n_max_buffer) {
				@{S_LABEL}_Scriber._flush_buffer(this);
			}
			else {
				// do not worry about clearing timeouts
				setTimeout(@{S_LABEL}_Scriber._flush_buffer, 0, this);
			}
		}
	@:
		_serialize_quad(g_quad) {
			let h_prefixes = this._h_prefixes;

			let {
				subject: yt_subject,
				predicate: yt_predicate,
				object: yt_object,
				@- B_QUADS
					graph: yt_graph,
				@;
			} = g_quad;

			@- B_QUADS
				// same graph
				if(yt_graph.equals(this._yt_graph)) {
			@;

			// same subject
			if(yt_subject.equals(this._yt_subject)) {
				// same prediate
				if(yt_predicate.equals(this._yt_predicate)) {
					// write object
					this.push(', '+terse_o(yt_object, h_prefixes));
				}
				// different predicate
				else {
					// write pair
					this.push(' ;\n\t'+terse_p(yt_predicate, h_prefixes)+' '+terse_o(yt_object, h_prefixes));

					// update prediate
					this._yt_predicate = yt_predicate;
				}
			}
			// subject not identical to previous
			else {
				let st_line = terse_s(yt_subject, h_prefixes)+' '+terse_p(yt_predicate, h_prefixes)+' '+terse_o(yt_object, h_prefixes);

				// different subject
				if(this._yt_subject) {
					// write triple
					this.push(' .\n\n'+st_line);
				}
				// first subject
				else {
					this.push(st_line);
				}

				// save subject and predicate
				this._yt_subject = yt_subject;
				this._yt_predicate = yt_predicate;
			}

			@- B_QUADS
				}
				// graph not identical to previous
				else {
					// what to write this call
					let s_write = '';

					// different graph
					if(this._yt_graph) {
						// close graph
						s_write = ' .\n}\n\n';
					}

					// write graph
					this.push(s_write+terse_g(yt_graph, h_prefixes)+' {\n');

					// save graph
					this._yt_graph = yt_graph;
					this._yt_subject = yt_subject;
					this._yt_predicate = yt_predicate;
				}
			@;
		}
	@;

	_flush() {
		@- B_OPTIMIZE_BUFFER
			// flush buffer
			@{S_LABEL}_Scriber._flush_buffer(this);
		@;

		// triple needs closing
		if(this._yt_subject) {
			this.push(' .\n');
		}

		// eof
		this.push(null);
	}
};

module.exports = function(g_config) {
	return new @{S_LABEL}_Scriber(g_config);
};
