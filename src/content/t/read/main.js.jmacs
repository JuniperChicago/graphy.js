@import '../../../share/channel.jmacs'
@import '../../../share/iris.jmacs'
@./* global FORMAT */
@//@

@$ TTL = 'ttl' === FORMAT;
@$ TRIG = 'trig' === FORMAT;
@$ QUADS = TRIG;


@// import parser macros
@import '../../common.parse.textual.jmacs'


const stream = require('@@@{S_GRAPHY_CHANNEL}/api.iso.stream');
const factory = require('@@@{S_GRAPHY_CHANNEL}/api.data.factory').raw;
const quad = (k) => factory.quad(k.subject, k.predicate, k.object, k.graph);


const RT_ESCAPES_INVALID = /\\[^"tbnrfuU\\_~.!$&'()*+,;=/?#@%-]|@{UCHAR('^')}/;
const RT_PREFIXED_NAME_NAMESPACE_VALID = /^(@{PN_PREFIX()})?$/u;
const RT_PREFIXED_NAME_LOCAL_NAME_VALID = /^@{PN_LOCAL()}$/u;

const RT_BLANK_NODE_VALID = /^[@{PN_CHARS_U()}0-9]@{PN_CHARS_FS()}$/u;
const RT_NAMED_NODE_VALID = /@{RT_NAMED_NODE_VALID()}/;

const R_ESCAPES = /@{R_ESCAPES()}/g;
const R_UNICODE_8 = /@{R_UNICODE_8()}/g;
const R_UNICODE_ANY = /@{R_UNICODE_4()}|@{R_UNICODE_8()}/g;

const F_REPLACE_UNICODE_ANY = @{F_REPLACE_UNICODE_ANY()};


const R_IRIREF_ESCAPELESS = /<([^\\>]*)>\s*/y;
const R_IRIREF = /<([^>]*)>\s*/y;


const H_ESCAPES_JSON = {
	'\t': '\\t',
	'\u0008': '\\b',
	'\n': '\\n',
	'\r': '\\r',
	'\f': '\\f',
	'"': '\\"',
};


@$ H_LOOKAHEADS = {
	string: {
		sub: 'terminal',
		chars: ''
			+'@'  // langtag
			+'^'  // datatype
			,
	},
	terminal: {
		sub: 'object',
		chars: '.',
	},
	blank_node: {
		sub: 'object',
		chars: '<',
	},
	blank_node_graph: {
		sub: 'blank_node',
		chars: '}',
	},
	object: {
		sub: 'comment',
		chars: ''
			+','  // object list
			+';'  // predicate-object list
			+'\\]'  // blank node property list
			+')'  // collection
			,
	},
	predicate: {
		sub: 'tree',
		chars: ''
			+'['  // blank node property list
			+'('  // collection
			+'"\''  // string
			,
	},
	tree: {
		sub: 'comment',
		chars: '<',  // node
	},
	comment: {
		chars: '#',
	},
};

@>> lookahead(s_key)
	@//@regex
	(?:\s+|(?=[@*{
		let h_node;
		do {
			h_node = H_LOOKAHEADS[s_key];
			yield h_node.chars;
		} while(h_node.sub && (s_key=h_node.sub));
	}]))
@;


@>> R_CHAR(s_delims='')
	@//@regex
	[^\s#<[("'@{s_delims}]
@;

@>> R_CHAR_NO_CLOSERS(s_puncts='.;,')
	@//@regex
	[^\s#<[("'@{s_puncts})\]\\]
@;

@>> R_PREFIX_ID()
	@//@regex
	@{R_CHAR(':_')}@{R_CHAR(':')}*
@;

@>> R_ESCAPE_SEQUENCE()
	@//@regex
	\\ (?:
		%[0-9A-Fa-f][0-9A-Fa-f]
		| [^\s"]
	)
@;

@>> R_CONTENT_LOOKAHEAD()
	@//@regex
	(?=
		\.[<[("';,)\]#\s\0]
		| [<[("';,)\]#]
	)
@;

@>> R_PREFIXED_NAME_ESCAPELESS()
	@//@regex
	(@{R_PREFIX_ID()})? :
	(
		(?:
			@{R_CHAR_NO_CLOSERS()}
			(?:
				@{R_CHAR_NO_CLOSERS(';,')}*
				@{R_CHAR_NO_CLOSERS()}
			)?
		)?
	)
	(?:
		\s+
		| @{R_CONTENT_LOOKAHEAD()}
	)
@;

const R_PREFIXED_NAME_ESCAPELESS = /@{R_PREFIXED_NAME_ESCAPELESS()}/y;

//										/([^\s#:<[("'_][^\s#:<[("']*)?:([^\s#<[("'.;,)\]\\]*)(?:\s+|(?=[<[("';,)\]#]))/y;
// const R_PREFIXED_NAME_ESCAPELESS_WITH_STOPS = /([^#:<[("'_][^\s#:<[("']*)?:((?:[^\s#<[("'.;,)\]\\]*[^\s#<[("';,)\]\\])?)(?:\s+|(?=[<[("'.;,)\]#]))/y;

@>> R_PREFIXED_NAME()
	@//@regex
	(@{R_PREFIX_ID()})? :				@// 1: prefix id
	(											@// 2: prefix iri
		(?:
			(?:									@// firt name char
				@{R_CHAR_NO_CLOSERS()}			@// not invalid name char
				| @{R_ESCAPE_SEQUENCE()}		@// or an escape sequence
			)
			(?:									@// middle name chars
				(?:
					@{R_CHAR_NO_CLOSERS(';,')}	@// not invalid name chars
					| @{R_ESCAPE_SEQUENCE()}	@// or an escape sequence
				)*
				(?:								@// last name char
					@{R_CHAR_NO_CLOSERS()}		@// not invalid name char
					| @{R_ESCAPE_SEQUENCE()}	@// or an escape sequence
				)
			)?
		)?
	)
	(?:											@// consume trailing whitespace
		\s+
		| @{R_CONTENT_LOOKAHEAD()}
	)
@;

const R_PREFIXED_NAME = /@{R_PREFIXED_NAME()}/y;

const R_PN_LOCAL_ESCAPES = /\\(.)/g;

@// blank node labels have different lookahead characters
@- TTL
	const R_BLANK_NODE_LABEL = /_:(.(?:[^\s:<;,)\]#]*[^\s:<.;,)\]#])?)@{lookahead('blank_node')}/y;
@:
	const R_BLANK_NODE_LABEL = /_:(.(?:[^\s:<;,)\]#}]*[^\s:<;,)\]#}])?)@{lookahead('blank_node_graph')}/y;
@;


const R_STRING_LITERAL_QUOTE = /"((?:[^"\\]|\\.)*)"@{lookahead('string')}/y;
const R_STRING_LITERAL_QUOTE_ESCAPELESS = /"([^"\\]*)"@{lookahead('string')}/y;
const R_STRING_LITERAL_SINGLE_QUOTE = /'((?:[^'\\]|\\.)*)'@{lookahead('string')}/y;
const R_STRING_LITERAL_SINGLE_QUOTE_ESCAPELESS = /'([^'\\]*)'@{lookahead('string')}/y;
const R_STRING_LITERAL_LONG_QUOTE = /"""((?:(?:""?)?(?:[^"\\]|\\.))*)"""\s*/y;
const R_STRING_LITERAL_LONG_SINGLE_QUOTE = /'''((?:(?:''?)?(?:[^'\\]|\\.))*)'''\s*/y;

const R_NUMERIC_LITERAL = /([+-]?(?:[0-9]+(\.[0-9]+)?|(\.[0-9]+))(\.?[eE][+-]?[0-9]+)?)(?:\s+|(?=\.[^eE0-9]|[;,)\]]))/y;
// const R_NUMERIC_LITERAL_EOF = /([+\-]?(?:[0-9]+([.]?[0-9]*)|([.][0-9]+))([eE][+\-]?[0-9]+)?)(?:\s*\.\s*)/y;
const R_BOOLEAN_LITERAL = /(?:(true|TRUE)|false|FALSE)\s*/y;
const R_A = /a@{lookahead('predicate')}/y;

const R_DOUBLE_CARET = /\^\^/y;
const R_WS = /\s*/y;
const R_LANGTAG = /@([A-Za-z]+(?:-[A-Za-z0-9-]+)*)@{lookahead('object')}/y;

// const R_PREFIX = /@?prefix\s*([^#:]*):\s*<([^>]+)>\s*\.?\s*/iy;
const R_PREFIX_KEYWORD = /(?:(@prefix)|[pP][rR][eE][fF][iI][xX])\s*/y;
const R_PREFIX_ID = /([^#:]*):\s*/iy;
// const R_BASE = /(?:@base|BASE)\s*<([^>]+)>\s*\.?\s*/iy;
const R_BASE_KEYWORD = /(?:(@base)|[bB][aA][sS][eE])\s*/y;

@- TRIG
	const R_GRAPH_IRI_ESCAPELESS = /(?:graph)?\s*<([^\\>]*)>\s*\{\s*/y;
	const R_GRAPH_PREFIXED_NAME = /(?:graph)?\s*([^\s:_][^\s:]*)?:([^\s\{]*)\s*\{\s*/y;
	const R_GRAPH_LABELED_BLANK_NODE = /(?:graph)?\s*_:([^\s{#]+)\s*\{\s*/y;
	const R_GRAPH_ANONYMOUS_BLANK_NODE = /(?:graph)?\s*\[\]\s*\{\s*/y;
	const R_GRAPH_IRI = /(?:graph)?\s*<([^>]*)>\s*\{\s*/y;
@;

const R_COMMENT = /(#[^\n]*\n\s*)+/y;

const RT_IRI_ABSOLUTE = /^[A-Za-z][A-Za-z0-9.\-+]*:/;
const R_URI = /^(\/[^?#]+#?)/;
@>> R_BASE_IRI()
	@//@regex
	^(								@// 1: uri
		(							@// 2: root
			([A-Za-z0-9.\-+]*:\/)?	@// 3: scheme
			\/[^/>]*				@// [authority]
		)?
		(							@// 4: path
			\/(?:[^/>]*\/)*
		)?
		[^>]*						@// [rest]
	)$
@;
const R_BASE_IRI = /@{R_BASE_IRI()}/;
const R_QUERYSTRING = /(\/[^/?#]*[?#].*)$/;

const R_ANONYMOUS_BLANK_NODE = /\[\]\s*/y;
const R_CHAR_BLANK_NODE = /\[(?:\s+|(?=[^\]]))/y;
const R_CHAR_COLLECTION = /\(\s*/y;

@- NEEDED
	const R_CHAR_COMMA = /,\s*/y;
	const R_CHAR_SEMI = /;\s*/y;
	const R_CHAR_BRA = /\[\s*/y;
	const R_CHAR_WAX = /\(\s*/y;
	const R_CHAR_WANE = /\)\s*/y;
@;

const R_CHAR_KET = /\]\s*/y

@- TRIG
	const R_CHAR_OPEN = /\{\s*/y;
	const R_CHAR_CLOSE = /\}\s*/y;
@;

const R_CHAR_STOP = /\.\s*/y;

const KT_RDF_LANG_STRING = factory.namedNode('@{P_IRI_RDF}langString');
const KT_RDF_TYPE = factory.namedNode('@{P_IRI_RDF}type');
const KT_RDF_FIRST = factory.namedNode('@{P_IRI_RDF}first');
const KT_RDF_REST = factory.namedNode('@{P_IRI_RDF}rest');
const KT_RDF_NIL = factory.namedNode('@{P_IRI_RDF}nil');


const H_DEFAULT_GRAPH = factory.defaultGraph();

const unescape_literal_short = s_literal => @{unescape_literal('s_literal', false)};
const unescape_literal_long = s_literal => @{unescape_literal('s_literal', true)};

const match_prefixed_name_escapeless = (s, i) => {
	R_PREFIXED_NAME_ESCAPELESS.lastIndex = i;
	return [R_PREFIXED_NAME_ESCAPELESS.exec(s), R_PREFIXED_NAME_ESCAPELESS.lastIndex];
};

const match_prefixed_name = (s, i) => {
	R_PREFIXED_NAME.lastIndex = i;
	return [R_PREFIXED_NAME.exec(s), R_PREFIXED_NAME.lastIndex];
};

@// will only be used by TriG
@> emit_graph_open()
	if(this.graph_open) this.graph_open(this.graph);
@;

@// will only be used by TriG
@> emit_graph_close()
	if(this.graph_close) this.graph_close(this.graph);
@;


@// consume whitespace
@> whitespace(s_offset='0', b_local=false)
	// consume whitespace (and incidentally reset index)
	R_WS.lastIndex = @{s_offset};
	R_WS.exec(s);
	@{b_local? '': 'this.'}i = R_WS.lastIndex;
@;


@// assert the prefix found in prefixed name is valid
@> valid_prefix(match)
	// check valid prefix
	let s_prefix_id = @{match}[1] || '';

	// invalid prefix
	if(!this.prefixes.hasOwnProperty(s_prefix_id)) return this.error(`no such prefix "${s_prefix_id}"`);
@;


@// extract uri from absolute / relative iri refs
@> iriref(sv_term, sv_match, b_object, b_set_base, b_has_escapes, b_not_this=false)
	@.{
		let sv_set = (b_not_this? '': 'this.')+sv_term;
		let set = b_object
			? s => `${sv_set} = this.named_node(${s});`
			: s => `${sv_set} = ${s};`;
	}
	// ref iri
	let s_iri = @{sv_match}[1]@{b_has_escapes? `.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)`: ''};

	// absolute iri
	if(!this.base_url || RT_IRI_ABSOLUTE.test(s_iri)) {
		// set @{sv_term}
		@{set(/* syntax: js */ `s_iri`)}
	}
	// relative iri
	else {
		// make @{sv_term}
		switch(s_iri[0]) {
			case '#':
				@{set(/* syntax: js */ `this.base_url + s_iri`)}
				break;
			case '?':
				@{set(/* syntax: js */ `this.base_url.replace(/(\\?.*)?$/, s_iri)`)}
				break;
			case '/':
				// relative to scheme
				if('/' === s_iri[1]) {
					@{set(/* syntax: js */ `this.base_url_scheme + F_DOT_SEGMENTS(s_iri.substr(1))`)}
				}
				// relative to root
				else {
					@{set(/* syntax: js */ `this.base_url_root + F_DOT_SEGMENTS(s_iri)`)}
				}
				break;
			// empty
			case undefined:  // eslint-disable-line no-undefined
				// identity
				@{set(/* syntax: js */ `this.base_url`)}
				break;
			// dot segment
			case '.':
				// prepend so it is relative to root
				s_iri = '/'+s_iri;
			// fallthrough: relative to path
			default:
				@{set(/* syntax: js */ `this.base_url_root + F_DOT_SEGMENTS(this.base_url_path + s_iri)`)}
		}
	}

	@// update the base iri
	@- b_set_base
		let m_base_iri = R_BASE_IRI.exec(this.base_url);
		this.@{sv_term} = m_base_iri[1];
		this.@{sv_term}_root = m_base_iri[2] || '';
		this.@{sv_term}_scheme = m_base_iri[3] || '';
		this.@{sv_term}_path = m_base_iri[4] || ''; 
	@;
@;


@// set object value and datatype for numeric literal
@> numeric_literal()
	// it has exponent term, xsd:double
	if(m_numeric_literal[4]) {
		this.object = factory.double(m_numeric_literal[1]);
	}
	// contains decimal point, xsd:decimal
	else if(m_numeric_literal[2] || m_numeric_literal[3]) {
		this.object = factory.decimal(m_numeric_literal[1]);
	}
	// otherwise, it is an integer
	else {
		this.object = factory.integer(m_numeric_literal[1]);
	}
@;

@// set object value and datatype for boolean literal
@> boolean_literal()
	// make literal
	this.object = factory.boolean(m_boolean_literal[1]? true: false);
@;


@// save current state to stack
@> push_state(state)
	this.nested.push([this.subject, this.predicate, '@{state}']);
@;

@// restore previous state from stack
@> pop_state()
	let s_resume_state;
	[this.subject, this.predicate, s_resume_state] = this.nested.pop();
	return this[s_resume_state]();
@;

@// change state
@> goto(s_method)
	return this.@{s_method}();
@;

@// declare a parse state
@> method(name, extern)
	// parse state for @{name}
	@- extern
		@{name}: () => {
	@:
		@{name}() {
	@;
		// destruct chunk, length, and index
		let {s, n, i} = this;

		// start labeled loop, run while there are characters
		@{name}: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition
@;

@// end parse state method
@> end_method(name, max_token)
		}

		// ran out of characters
		@{resume_state(name, false, max_token)}
	}
@;

@// set resume state & stop parsing in this stack
@> resume_state(s_state, b_use_field_chunk=false, s_max_token=null)
	// update index value
	this.i = i;

	// not yet eos
	if(i < this.n) {
		// expected token was not found
		if(0 === i) {
			// we've exceeded the maximum token length
			if(this.n > this.@{s_max_token || 'max_token_length'}) {
				return this.parse_error('@{s_state}');
			}
		}
	}

	// save state before pausing
	this.state = this.@{s_state};

	// consumer is pausing
	if(this.n < 0) {
		// go async
		return;
	}

	// store what is unparsed
	this.pre = @{b_use_field_chunk? 'this.' :''}s.slice(i);

	// if we're not parsing a stream, then this is an error
	if(this.eos) this.eos();
	return;
@;

@// emit a statement event to listener using current subject/predicate/object
@> emit_statement()
	this.data(quad(this));
@;

@// extract name from suffix
@> suffix(term)
	// escape local escapes
	let s_suffix = @{term}[2]
		.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)
		.replace(R_PN_LOCAL_ESCAPES, '$1');
@;


@// set the object value of a string literal
@> set_string_literal(match, version)
	// set literal value
	h_literal.value = 
	@- 'no-escape' === version
		@{match}[1];
	@:
		this.unescape_literal_@{'long'===version? 'long': 'short'}(@{match}[1]);
	@;
@;

@> full_stop()
	if(this.expecting_full_stop) {
		// change state
		@{goto('full_stop')}
	}
@;

@// emit statement and return control to whatever function asked for it
@> end_of_statement()
	// at this point, a new statement has been parsed
	@{emit_statement()}

	// goto next parsing state; bail out of stack
	return this.after_end_of_statement;
@;

// instead of putting this in a macro to be unrolled at every IRI resolution,
// ... spare the monstrosity from the source and make it a function
const F_DOT_SEGMENTS = (s_rel_iri) => {
	let m_uri = R_URI.exec(s_rel_iri);
	if(!m_uri) return s_rel_iri;
	let s_iri = m_uri[1];

	//
	let m_qs_hash = R_QUERYSTRING.exec(s_iri);
	let s_qs_hash = '';
	if(m_qs_hash) {
		s_qs_hash = m_qs_hash[1];
		s_iri = s_iri.slice(0, -s_qs_hash.length);
	}

	let a_segments = s_iri.split('/');
	let a_output = [];
	let b_empty = true;

	for(let i=0; i<a_segments.length; i++) {
		let s_segment = a_segments[i];
		b_empty = false;

		// up a hierarchical level
		if('..' === s_segment) {
			if(a_output.length > 1) a_output.pop();
		}
		// down a level level
		else if('.' !== s_segment && (s_segment || !i || i === a_segments.length-1)) {
			a_output.push(s_segment);
		}
	}

	return a_output.join('/')+s_qs_hash;
};


@- TTL
	@$ S_STATE_PRIMARY = 'statement';
@:
	@$ S_STATE_PRIMARY = 'block';
@;

class reader {
	constructor(g_config={}) {
		// impl-specific configs
		let {
			// input medium
			input: g_input=null,

			// a state to inherit
			state: g_state={},
		} = g_config;

		// inherit state from creator
		let {
			// index for anonymous blank node labels
			blank_node_index: i_anon=0,

			// prefix map
			prefixes: h_prefixes={},

			// blank node label map
			labels: h_labels={},
		} = g_state;


		// fields
		Object.assign(this, {
			// read index
			i: 0,

			// string buffer
			s: '',

			// string buffer length
			n: 0,

			// left-over string from previous data chunk
			pre: g_config.prepend || '',

			// debug state
			debug: g_config.debug || false,

			// current reader state
			state: this.@{S_STATE_PRIMARY},

			// map of current prefix ids => iris
			prefixes: h_prefixes,

			// current @base url
			base_url: '',
			base_url_scheme: '',
			base_url_root: '',
			base_url_path: '',

			// current data
			subject: null,
			predicate: KT_RDF_FIRST,
			object: null,
			graph: H_DEFAULT_GRAPH,

			// queue of nested subject, predicate, state for blanknodes and collections
			nested: [],

			// hash to keep track of all blank node labels in use
			labels: h_labels,

			// whether or not eof has been fired already
			eofed: false,

			// event routing
			event: this.emit,
			data: this.emit_data,

			// for restoring the original event callback when resuming paused stream
			restore_data: this.emit_data,

			// keep a queue of data events to hold onto until stream resumes (only happens in rare conditions)
			queue_event: [],


			// finds the next non-conflicting blank node label
			next_label() {
				let s_label = '';
				do {
					s_label = 'g'+(i_anon++);
				} while(this.labels[s_label]);

				// claim this label, and remember that we invented it
				this.labels[s_label] = 2;

				// return the label
				return s_label;
			},

			// what to do when reach eos
			eos: null,

			// which state to go to after end of statement
			after_end_of_statement: this.post_object,

			// maximum length of a token: defaults to 2048 => http://stackoverflow.com/a/417184/1641160
			max_token_length: g_config.max_token_length || 2048,

			// maximum length of a string (overrides max_token_length): defaults to 64 kibibytes
			max_string_length: g_config.max_string_length || 65536,
		});


@// ensure there are no conflicting blank node labels
@> no_label_conflict()
	// not first time use of label
	let z_label_state = this.labels[s_label];
	if(z_label_state) {
		// label was used previously by document and has no conflict
		if(1 === z_label_state) {}  // eslint-disable-line no-empty
		// label is in use by invention, this would cause a conflict
		else if(2 === z_label_state) {
			// so create a redirect mapping for this actual label & use it instead
			s_label = this.labels[s_label] = this.next_label();
		}
		// label already has a redirect mapping
		else {
			// use redirected label
			s_label = this.labels[s_label];
		}
	}
	// first time use of label
	else {
		// store label in hash so we avoid future collisions
		this.labels[s_label] = 1;
	}
@;

		// term constructors
		Object.assign(this, g_config.validate
			? {
				blank_node(s_label) {
					// test valid blank node label
					if(!RT_BLANK_NODE_VALID.test(s_label)) return this.error(`invalid blank node label: "${s_label}"`);

					@// check for conflicts
					@{no_label_conflict()}

					// make term
					return factory.blankNode(s_label);
				},

				named_node(s_iri) {
					if(!RT_NAMED_NODE_VALID.test(s_iri)) return this.error(`invalid IRI: "${s_iri}"`);
					return factory.namedNode(s_iri);
				},

				unescape_literal_long(s_literal) {
					if(RT_ESCAPES_INVALID.test(s_literal)) return this.error(`invalid literal: "${s_literal}"`);
					try {
						return unescape_literal_long(s_literal);
					}
					catch(e_parse) {
						return this.error(`invalid string literal: "${s_literal}"`);
					}
				},

				unescape_literal_short(s_literal) {
					if(RT_ESCAPES_INVALID.test(s_literal)) return this.error(`invalid literal: "${s_literal}"`);
					try {
						return unescape_literal_short(s_literal);
					}
					catch(e_parse) {
						return this.error(`invalid string literal: "${s_literal}"`);
					}
				},

				match_prefixed_name_escapeless(s, i) {
					let [m_prefixed_name_e, im_prefixed_name_e] = match_prefixed_name_escapeless(s, i);
					if(m_prefixed_name_e) {
						// invalid namespace
						if(!RT_PREFIXED_NAME_NAMESPACE_VALID.test(m_prefixed_name_e[1])) {
							this.error(`invalid prefixed name namespace: "${m_prefixed_name_e[1]}:"`);
							return;
						}
						// invalid local name
						else if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name_e[2])) {
							this.error(`invalid prefixed name local name: "${m_prefixed_name_e[2]}:"`);
							return;
						}
					}

					return [m_prefixed_name_e, im_prefixed_name_e];
				},

				match_prefixed_name(s, i) {
					let [m_prefixed_name, im_prefixed_name] = match_prefixed_name(s, i);
					if(m_prefixed_name) {
						// invalid namespace
						if(!RT_PREFIXED_NAME_NAMESPACE_VALID.test(m_prefixed_name[1])) {
							this.error(`invalid prefixed name namespace: "${m_prefixed_name[1]}:"`);
							return;
						}
						// invalid local name
						else if(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name[2])) {
							this.error(`invalid prefixed name local name: "${m_prefixed_name[2]}:"`);
							return;
						}
					}

					return [m_prefixed_name, im_prefixed_name];
				},
			}
			: {
				// term constructors
				blank_node(s_label) {
					@// check for conflicts
					@{no_label_conflict()}

					// make term
					return factory.blankNode(s_label);
				},
				anonymous_blank_node: s_label => factory.blankNode(s_label, true),
				named_node: s_iri => factory.namedNode(s_iri),

				unescape_literal_short: unescape_literal_short,
				// (s_literal){
				// 	// try {
				// 		return unescape_literal_short(s_literal);
				// 	// }
				// 	// catch(e_parse) {
				// 	// 	return this._error(`invalid string literal: "${s_literal}"`);
				// 	// }
				// },
				unescape_literal_long: unescape_literal_long,
				// (s_literal) {
				// 	// try {
				// 		return unescape_literal_long(s_literal);
				// 	// }
				// 	// catch(e_parse) {
				// 	// 	return this._error(`invalid string literal: "${s_literal}"`);
				// 	// }
				// },

				match_prefixed_name_escapeless,
				match_prefixed_name,
			});

		// oops -- user passed string into `base`
		if('string' === typeof g_config.base) {
			throw new TypeError(`invalid type 'string' was given for 'base' event listener: '${g_config.base}'\n`
				+`did you mean to use the 'base_uri' key instead?`)
		}

		// base uri
		let p_set_base_uri = g_config.base_uri || g_config.baseUri || g_config.baseURI;
		if(p_set_base_uri) {
			let m_base_iri = R_BASE_IRI.exec(p_set_base_uri);
			this.base_url = m_base_iri[1];
			this.base_url_root = m_base_iri[2] || '';
			this.base_url_scheme = m_base_iri[3] || '';
			this.base_url_path = m_base_iri[4] || ''; 
		}

		// output stream
		let ds_output;

		// no input given, it will be written/piped in later
		if(null === g_input) {
			// whether or not data has been received before
			let b_init = false;

			// create transform
			ds_output = this.output = new stream.Transform({
				// do not decode strings into buffers
				decodeStrings: false,

				// output quad objects on readable side
				readableObjectMode: true,

				// once there's no more data to consume, invoke eof
				flush: (fk_flush) => {
					// now that stream has ended, clean up remainder
					this.eof(1);

					// done flushing, close read stream
					fk_flush();
				},

				// on data event
				transform: (s_chunk, s_encoding, fk_chunk) => {
					// first transform
					if(!b_init) {
						// notify that data will begin
						ds_output.emit('ready');

						// do not emit 'ready' event again
						b_init = false;
					}

					// stream is paused
					if(this.n < 0) {
						return this.error('stream received new data while it was supposed to be paused!');
					}

					// concatenate current chunk to previous chunk
					let s = this.s = this.pre + s_chunk;

					// cache chunk length
					this.n = s.length;

					@// eat whitespace before token and reset index
					@{whitespace()}

					// resume parsing
					this.safe_parse(true);

					// emit progress event updates
					ds_output.emit('progress', s_chunk.length);

					// done transforming this chunk
					fk_chunk();
				},
			});

			// bind events to output stream
			this.bind(g_config);

			// notify once and never again
			ds_output.once('pipe', (ds_input) => {
				// input stream has encoding option
				if(ds_input.setEncoding) {
					// ensure stream is encoding in utf8
					ds_input.setEncoding('utf8');
				}
			});
		}
		// input is stream
		else if(g_input.stream) {
			let ds_input = g_input.stream;

			// whether or not data has been received before
			let b_init = false;

			// begin flowing mode on output stream
			const begin_flow = () => {
				// switch input to flowing mode
				ds_input.on('data', (s_chunk) => {
					// // stream is paused
					// if(this.n < 0) {
					// 	return this.error('stream received new data while it was supposed to be paused!');
					// }

					// // notify that data will begin
					// if(!b_init) {
					// 	ds_output.emit('ready');

					// 	// do not notify again
					// 	b_init = true;
					// }

					// concatenate current chunk to previous chunk
					let s = this.s = this.pre + s_chunk;

					// cache chunk length
					this.n = s.length;

					@// eat whitespace before token and reset index
					@{whitespace()}

					// resume parsing
					this.safe_parse(true);

					// // progress updates
					// ds_output.emit('progress', s_chunk.length);
				});
			};

			// manual read mode
			const read_manual = (nb_read) => {
				// rather than emitting data/other events, queue them
				// this.data = F_QUEUE_DATA;
				this.event = this.queue;

				// subscribe to readable events on input
				ds_input.on('readable', () => {
					// read chunk from input stream while there is data to read
					let s_chunk = ds_input.read();

					// notify that data will begin
					if(!b_init) {
						ds_output.emit('ready');

						// do not notify again
						b_init = true;
					}

					// concatenate current chunk to previous chunk
					let s = this.s = this.pre + s_chunk;

					// cache chunk length
					this.n = s.length;

					@// eat whitespace before token and reset index
					@{whitespace()}

					// resume parsing
					this.safe_parse(true);

					// progress updates
					ds_output.emit('progress', s_chunk.length);

					// return ...?
				});
			};

			// create readable output
			ds_output = this.output = new stream.Readable({
				// outputs quad objets
				objectMode: true,

				// this will only happen if consumer uses stream in non-folowing mode
				read(nb_read) {
					// which flowing mode
					switch(ds_output.readableFlowing) {
						// in flowing mode (#pipe, #'data', or #resume)
						case true: {
							// ignore read requests
							ds_output._read = () => {};

							// begin flowing
							begin_flow();
							break;
						}

						// manual reads
						case false:
						case null: {
							// switch to manual read mode
							ds_output._read = read_manual;

							// forward request to handler
							return ds_output._read(nb_read);
						}

						// no mechanism for consuming
						default: {
							debugger;
							// do not start reading input, do not parse, do not emit
						}
					}
				},
			});

			// bind events to output stream
			this.bind(g_config);

			// set encoding on input stream
			ds_input.setEncoding('utf8');

			// once stream closes, invoke eof
			ds_input.on('end', () => this.eof());

			// capture error on input
			ds_input.on('error', (e_input) => {
				ds_output.emit('error', `error on input stream: ${e_input.message}\n${e_input.stack}`);
			});
		}
		// string
		else if('string' === typeof g_input.string) {
			let s_input = g_input.string;

			// create readable output
			ds_output = this.output = new stream.Readable({
				// outputs quad objets
				objectMode: true,

				// once data event is attached
				read: () => {
					// consume entire string
					this.safe_parse(true);

					// remove this handler
					ds_output._read = () => {};
				},
			});

			// concatenate previous chunk
			let s = this.s = this.pre+s_input;

			// eos means we've reached eof
			if(g_config.async) {
				this.eos = function() {
					setTimeout(() => this.eof(), 0);
				};
			}
			else {
				this.eos = this.eof;
			}

			// compute chunk length
			this.n = s.length;

			@// eat whitespace before token and reset index
			@{whitespace()}

			// bind events to output stream
			this.bind(g_config);

			// ready to parse
			ds_output.emit('ready');
		}
		// invalid arg
		else {
			throw new TypeError('invalid argument for input parameter: '+g_input);
		}
	}

	// begin parsing, keep applying until no more stack bail-outs
	safe_parse() {
		let f_sync = this.state();
		while('function' === typeof f_sync) {
			f_sync = f_sync.apply(this);
		}

		return f_sync;
	}

	emit_data(g_quad) {
		this.output.push(g_quad);
	}

	emit(s_event, ...a_args) {
		this.output.emit(s_event, ...a_args);
	}

	queue(s_event, ...a_args) {
		this.queue_event.push({
			event: s_event,
			args: a_args,
		});
	}

	error(s_message) {
		this.output.emit('error', new Error(s_message));
	}

	// parse_error (not meant to be an event callback)
	parse_error(s_expected, b_eof) {
		@- T
			let i = this.i;
			let i_off = Math.min(i, Math.abs(i-15));
		@:
			let i = 0;
			let i_off = 0;
		@;
		let s = this.s;
		this.error(`\n\`${s.substr(i_off, i_off+90).replace(/[\n\t]/g, ' ')}\`\n`
			+` ${' '.repeat(i-i_off)}^\n`
			+`expected ${s_expected} ${b_eof? 'but encountered <<EOF>>': ''}.  failed to parse a valid token starting at ${s[i]? '"'+s[i]+'"': '<<EOF>>'}`);
	}

	// end of file
	eof(b_no_callback) {
		// paused
		if(this.n < 0) {
			// resume here later
			this.queue_event.push({
				event: 'eof',
				data: null,
			});

			// resume later
			return;
		}

		// there are events queued
		if(this.queue_event.length) {
			let a_queue = this.queue_event;

			// drain event queue
			while(a_queue.length) {
				// remove event from front of queue
				let h_event = a_queue.shift();

				// make event callback
				this[h_event.event](h_event.data);

				// callback paused stream
				if(this.n < 0) {
					// resume here later
					this.queue_event.push({
						event: 'eof',
						data: null,
					});

					// stop emptying event queue and go async immediately
					return;
				}
			}
		}

		// invalid parsing state
		if(this.@{S_STATE_PRIMARY} !== this.state) {
			// already eof'ed
			if(this.eofed) return this.parse_error(this.state.name, true);

			// now we have
			this.eofed = true;

			// append EOF char
			this.s += '\0';

			// exit "flowing" mode
			this.n = this.s.length;

			// resume parsing
			this.safe_parse();
			
			// eof has occurred under safe parse
			if(null === this.s) return;

			// callback paused stream
			if(this.n < 0) {
				debugger;

				// resume here later
				this.queue_event.push({
					event: 'eof',
					data: null,
				});

				// stop emptying event queue and go async immediately
				return;
			}

			// still invalid parsing state
			if(this.@{S_STATE_PRIMARY} !== this.state) {
				return this.parse_error(this.state.name, true);
			}
		}

		// there are still unparsed characters
		if(this.i < this.n) {
			// consume whitespace and comments
			let s = this.s;
			let i = this.i;
			@{whitespace('i', true)}
			R_COMMENT.lastIndex = i;
			R_COMMENT.exec(s);

			// advance beyond comment
			if(R_COMMENT.lastIndex > i) {
				this.i = i = R_COMMENT.lastIndex;
			}

			// still unparsed characters
			if(i < this.n) {
				// not EOF
				if(!(i === this.n - 1 && '\0' === s[i])) {
					// bad input; parse error
					return this.parse_error(this.state.name);
				}
			}
		}

		// make buffer's alloc eligible for gc
		this.s = null;

		// output stream
		let ds_output = this.output;

		// final progress update: no additional bytes were read
		ds_output.emit('progress', 0);

		// call end event listener
		ds_output.emit('eof', this.prefixes);

		// close write stream (EOF-signaling)
		ds_output.push(null);
	};



@$ H_PARSE_EVENTS = {
	base: {},
	prefix: {},
	...(QUADS
		? {
			graph_open: {},
			graph_close: {},
		}
		: {}),
	error: {},
	read: {once:true},
	progress: {},
	eof: {once:true},
	end: {once:true},
	data: {},  // attach data listener last
};

	// bind event listeners to output stream
	bind(g_config) {
		let ds_output = this.output;
		@*{
			for(let [s_event, g_event] of Object.entries(H_PARSE_EVENTS)) {
				yield /* syntax: js */ `
					if(g_config.${s_event}) ds_output.${g_event.once? 'once': 'on'}('${s_event}', g_config.${s_event});
					`.trim()+'\n';
			}
		}
	}

	// a resume-only state to handle eos interupting ';'
	post_pair() {
		let s = this.s;
		let x = s[this.i];
		if('.' === x || ']' === x) {
			@{whitespace('this.i+1')}
		}
		@{goto('pairs')}
	}

	// after a blank node subject (either property-list or colleciton)
	post_blank_subject() {
		let s = this.s;
		if('.' === s[this.i]) {
			@{whitespace('this.i+1')}
			@{goto('statement')}
		}
		@{goto('pairs')}
	}

	@// regexes are faster than character[0] switching in this context
	@{method('statement')}
		@//@

		// iriref
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_subject')}
			@{iriref('subject', 'm_iriref_e_subject', true)}

			// predicate-object pairs state
			@{goto('pairs')}

		@// sub-macro for reusing statement productions
		@def triples(directives)
			// prefixed name
			@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_subject')}

				@{valid_prefix('m_prefixed_named_e_subject')}

				// make subject key
				this.subject = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_subject[2]);

				// predicate-object pairs state
				@{goto('pairs')}

			// blank node label
			@{else_if_match('R_BLANK_NODE_LABEL', 'm_blank_node_label_subject')}
				// extract label
				let s_label = m_blank_node_label_subject[1];

				// make subject key
				this.subject = this.blank_node(s_label);

				// predicate-object pairs state
				@{goto('pairs')}

			// anonymous blank node subject
			@{else_if_match('R_ANONYMOUS_BLANK_NODE')}
				// set new blank node as subject
				this.subject = this.anonymous_blank_node(this.next_label());

				// goto pairs state for inside property list
				@{goto('pairs')}

			// anonymous blank node property list subject
			@{else_if_match('R_CHAR_BLANK_NODE')}
				// enter blank node
				this.subject = this.anonymous_blank_node(this.next_label());

				// how to resume when we pop state
				@{push_state('post_blank_subject')}

				// goto pairs state for inside property list
				@{goto('pairs')}

			// rdf collection
			@{else_if_match('R_CHAR_COLLECTION')}
				// indicate that collection subject should emit an initial statement
				this.subject = null;
				
				// (don't push state, we don't have a subject yet)

				// goto collection-subject state
				@{goto('collection_subject')}

			@- TTL || directives
				// prefix with interupt (e.g., a comment)
				@{else_if_match('R_PREFIX_KEYWORD', 'm_prefix_keyword')}
					// save whether or not to expect a full stop
					this.expecting_full_stop = m_prefix_keyword[1]? true: false;

					// goto prefix state
					@{goto('prefix_id')}

				// base with interupt (e.g., a comment)
				@{else_if_match('R_BASE_KEYWORD', 'm_base_keyword')}
					// save whether or not to expect a full stop
					this.expecting_full_stop = m_base_keyword[1]? true: false;

					// goto base state
					@{goto('base_iri')}
			@;

			@- TRIG && !directives
				// closing graph '}'
				@{else_if_match('R_CHAR_CLOSE')}
					// emit graph_close event
					@{emit_graph_close()}

					// reset graph
					this.graph = H_DEFAULT_GRAPH;

					// goto block state
					@{goto('block')}
			@;

			// iriref
			@{else_if_match('R_IRIREF', 'm_iriref_subject')}
				@{iriref('subject', 'm_iriref_subject', true, false, true)}

				// predicate-object pairs state
				@{goto('pairs')}

			// prefixed name
			@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_subject')}
				@{valid_prefix('m_prefixed_named_subject')}

				@{suffix('m_prefixed_named_subject')}

				// make subject key
				this.subject = this.named_node(this.prefixes[s_prefix_id] + s_suffix);

				// predicate-object pairs state
				@{goto('pairs')}
		@;

		@{triples()}

		@// for trig only
		@- TRIG
			@{else_if_match('R_CHAR_CLOSE')}
				this.graph = H_DEFAULT_GRAPH;
				@{goto('block')}
		@;

		// comment
		@{else_if_match('R_COMMENT', false, true)}
			continue;

		// not iriref, not prefixed name, not blank node label, not prefix id, not base
		@{else_retry()}

	@{end_method('statement')}

	@- TRIG
		@{method('block')}

			@{if_match('R_GRAPH_IRI_ESCAPELESS', 'm_graph_iriref_e_graph')}
				@{iriref('graph', 'm_graph_iriref_e_graph', true)}

				@{emit_graph_open()}

				// statement state
				@{goto('statement')}

			@{else_if_match('R_GRAPH_PREFIXED_NAME', 'm_graph_prefixed_name')}
				@{valid_prefix('m_graph_prefixed_name')}

				// make subject key
				this.graph = this.named_node(this.prefixes[s_prefix_id] + m_graph_prefixed_name[2]);

				@{emit_graph_open()}

				// statement state
				@{goto('statement')}

			@{else_if_match('R_CHAR_OPEN')}
				// make new default graph
				this.graph = factory.defaultGraph();

				@{emit_graph_open()}

				// goto statement state
				@{goto('statement')}

			@{else_if_match('R_GRAPH_ANONYMOUS_BLANK_NODE', 'm_graph_anonymous_blank_node')}
				// make new label & set graph to blank node
				this.graph = this.anonymous_blank_node(this.next_label());

				@{emit_graph_open()}

				// statement state
				@{goto('statement')}

			@{else_if_match('R_GRAPH_LABELED_BLANK_NODE', 'm_graph_labeled_blank_node')}
				let s_label = m_graph_labeled_blank_node[1];

				this.graph = this.blank_node(s_label);

				@{emit_graph_open()}

				// statement state
				@{goto('statement')}

			// iriref
			@{else_if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_subject')}
				@{iriref('subject', 'm_iriref_e_subject', true)}

				// predicate-object pairs state
				@{goto('pairs')}

			@// try triples productions
			@{triples(true)}

			@// then try other graph keywords
			@{else_if_match('R_GRAPH_IRI', 'm_graph_iriref_graph')}
				@{iriref('graph', 'm_graph_iriref_graph', true)}

				@{emit_graph_open()}

				// statement state
				@{goto('statement')}

			// comment
			@{else_if_match('R_COMMENT', false, true)}
				continue;

			// not iriref, not prefixed name, not blank node label, not prefix id, not base
			@{else_retry()}

		@{end_method('block')}
	@;


	@{method('pairs')}
		// benchmarks indicate: regex for end of blank node property list faster than ch

		// iriref
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_predicate')}
			@{iriref('predicate', 'm_iriref_e_predicate', true)}

			// object-list state
			@{goto('object_list')}

		// prefixed name
		@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_predicate')}
			@{valid_prefix('m_prefixed_named_e_predicate')}

			// make predicate key
			this.predicate = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_predicate[2]);

			// object-list state
			@{goto('object_list')}

		// 'a'
		@{else_if_match('R_A')}
			// make predicate key
			this.predicate = KT_RDF_TYPE;

			// object-list state
			@{goto('object_list')}

		// ']' end of blank node property list
		@{else_if_match('R_CHAR_KET')}
			@{pop_state()}

		// iriref
		@{else_if_match('R_IRIREF', 'm_iriref_predicate')}
			@{iriref('predicate', 'm_iriref_predicate', true, false, true)}

			// object-list state
			@{goto('object_list')}

		// prefixed name
		@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_predicate')}
			@{valid_prefix('m_prefixed_named_predicate')}

			@{suffix('m_prefixed_named_predicate')}

			// make predicate key
			this.predicate = this.named_node(this.prefixes[s_prefix_id] + s_suffix);

			// object-list state
			@{goto('object_list')}


		@{else_if_match('R_COMMENT', false, true)}
			continue;

		// not iriref, not prefixed name, not 'a'
		@{else_retry()}

	@{end_method('pairs')}


	@{method('object_list')}
		// ref char
		let x = s[i];

		// iriref
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_object')}
			@{iriref('object', 'm_iriref_e_object', true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_object')}
			@{valid_prefix('m_prefixed_named_e_object')}

			// commit object iri from resolve prefixed name
			this.object = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_object[2]);

		// string literal
		@{else_if_char('"', "'")}
			@{goto('string_literal')}

		// numeric literal
		@{else_if_match('R_NUMERIC_LITERAL', 'm_numeric_literal')}
			@{numeric_literal()}

		// boolean literal
		@{else_if_match('R_BOOLEAN_LITERAL', 'm_boolean_literal')}
			@{boolean_literal()}

		// blank node property list
		@{else_if_char('[')}
			// advance index to next token
			@{whitespace('i+1')}

			// make object
			let kt_blank_node = this.object = this.anonymous_blank_node(this.next_label());

			// emit statement event
			@{emit_statement()}

			// push state to stack
			@{push_state('post_object')}

			// set new subject
			this.subject = kt_blank_node;

			// goto parsing pairs state
			@{goto('pairs')}

		// labeled blank node
		@{else_if_match('R_BLANK_NODE_LABEL', 'm_blank_node_label_object')}
			// ref blank node label
			let s_label = m_blank_node_label_object[1];

			// make object
			this.object = this.blank_node(s_label);

		// collection
		@{else_if_char('(')}
			// advance index to next token
			@{whitespace('i+1')}

			// state to resume after collection ends
			@{push_state('post_object')}

			// goto collection-object state
			@{goto('collection_object')}

		// iriref
		@{else_if_match('R_IRIREF', 'm_iriref_object')}
			@{iriref('object', 'm_iriref_object', true, false, true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_object')}
			@{valid_prefix('m_prefixed_named_object')}

			@{suffix('m_prefixed_named_object')}

			// commit object iri from resolve prefixed name
			this.object = this.named_node(this.prefixes[s_prefix_id] + s_suffix);

		@{else_if_match('R_COMMENT', false, true)}
			continue;

		// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
		@{else_retry()}

		// fall through for cases that did not change state on their own
		@{end_of_statement()}
	@{end_method('object_list')}


	@{method('string_literal')}
		// we know this is going to be a literal
		let h_literal = this.object = factory.literal();

		// ref character
		let x = s[i];

		// string literal quote / string literal long quote
		@{if_char('"')}
			// `"""` string literal long quote
			@{if_match('R_STRING_LITERAL_LONG_QUOTE', 'm_string_literal_long_quote')}
				@{set_string_literal('m_string_literal_long_quote', 'long')}

			// `"` string literal quote escapeless
			@{else_if_match('R_STRING_LITERAL_QUOTE_ESCAPELESS', 'm_string_literal_quote_escapeless')}
				@{set_string_literal('m_string_literal_quote_escapeless', 'no-escape')}

			// `"` string literal quote w/ escapes
			@{else_if_match('R_STRING_LITERAL_QUOTE', 'm_string_literal_quote')}
				@{set_string_literal('m_string_literal_quote', 'single-dirk')}

			// not string long literal quote, not string literal quote
			@{else_retry()}

		// `'''` string literal long single quote
		@{else_if_match('R_STRING_LITERAL_LONG_SINGLE_QUOTE', 'm_string_literal_long_single_quote')}
			@{set_string_literal('m_string_literal_long_single_quote', 'long')}

		// `'` string literal quote escapeless
		@{else_if_match('R_STRING_LITERAL_SINGLE_QUOTE_ESCAPELESS', 'm_string_literal_single_quote_escapeless')}
			@{set_string_literal('m_string_literal_single_quote_escapeless', 'no-escape')}

		// `'` string literal single quote w/ escapes
		@{else_if_match('R_STRING_LITERAL_SINGLE_QUOTE', 'm_string_literal_single_quote')}
			@{set_string_literal('m_string_literal_single_quote', 'single-irk')}

		// not string literal long single quote, not string literal single quote
		@{else_retry()}

		// complete literal
		@{goto('datatype_or_langtag')}
	@{end_method('string_literal', 'max_string_length')}


	@{method('datatype_or_langtag')}
		// ref character
		let x = s[i];

		// next token indicates datatype or langtag
		@{if_char('^', '@')}
			// '^^' datatype
			@{if_match('R_DOUBLE_CARET')}
				@{goto('datatype')}

			// '@' language tag
			@{else_if_match('R_LANGTAG', 'm_langtag')}
				// set literal language type
				this.object.language = m_langtag[1].toLowerCase();
				this.object.datatype = KT_RDF_LANG_STRING;

			// next token definitely datatype or langtag, we are just being interrupted by eos
			@{else_retry()}

		@{else_if_match('R_COMMENT', false, true)}
			continue;

		// not datatype, not language tag => that's okay! those are optional
		@{end_else()}

		// goto end of statement state
		@{end_of_statement()}
	@{end_method('datatype_or_langtag')}


	@{method('datatype')}
		// iriref
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_datatype')}
			let p_datatype;
			@{iriref('p_datatype', 'm_iriref_e_datatype', false, false, false, true)}

			// set literal datatype
			this.object.datatype = this.named_node(p_datatype);

		// prefixed name
		@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_datatype')}
			@{valid_prefix('m_prefixed_named_e_datatype')}

			// set literal datatype
			this.object.datatype = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_datatype[2]);

		// iriref
		@{else_if_match('R_IRIREF', 'm_iriref_datatype')}
			@{iriref('object["datatype"]', 'm_iriref_datatype', false, false, true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_datatype')}
			@{valid_prefix('m_prefixed_named_datatype')}

			@{suffix('m_prefixed_named_datatype')}

			// set literal datatype
			this.object.datatype = this.named_node(this.prefixes[s_prefix_id] + s_suffix);

		// not iriref, not prefixed name
		@{else_retry()}

		// goto end of statement state
		@{end_of_statement()}
	@{end_method('datatype')}


	@{method('post_object')}
		// benchmarks confirm: character ref faster than regexes in this context
		let x = s[i];

		// advance index to next token beyond delimiter
		@{whitespace('i+1')}

		// ',' more objects
		@{if_char(',')}
			@{goto('object_list')};

		// ';' more predicate-object pairs
		@{else_if_char(';')}
			// next token is end of statement or end of blank node property list
			let x1 = s[this.i];
			if('.' === x1 || ']' === x1 || ';' === x1) {
				// goto post-object state
				@{goto('post_object')}
			}
			// eos
			else if(this.i === n) {
				// go to post-pair state
				@{goto('post_pair')}
			}
			@{goto('pairs')}

		// '.' end of statement
		@{else_if_char('.')}
			// assert not nested
			if(this.nested.length) {
				// reset index to that character
				this.i = i;

				// emit parse error
				return this.parse_error('end_of_property_list');
			}
			@- TTL
				@{goto(S_STATE_PRIMARY)}
			@:
				return (H_DEFAULT_GRAPH === this.graph)? this.@{S_STATE_PRIMARY}(): this.statement();
			@;

		// ']' end of property-object pairs
		@{else_if_char(']')}
			@{pop_state()}

		// ')' end of collection
		@{else_if_char(')')}
			// should not be here
			return this.parse_error('unexpected end of collection');

		// comment
		@{else_if_match('R_COMMENT', false, true)}
			// do not change state
			continue;

		// comment interrupted by eos?
		@{else_retry()}

	@{end_method('post_object')}


	@{method('base_iri')}
		// prefix id
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_base')}
			@// set base url
			@{iriref('base_url', 'm_iriref_e_base', false, true)}

			// emit base event
			if(this.base) this.base(this.base_url);

			@// handle full stop
			@{full_stop()}

			// goto prefix iri state
			@{goto(S_STATE_PRIMARY)}

		// prefix id
		@{else_if_match('R_IRIREF', 'm_iriref_base')}
			@// set base iri
			@{iriref('base_url', 'm_iriref_base', false, true, true)}

			// emit base event
			if(this.base) this.base(this.base_url);

			@// handle full stop
			@{full_stop()}

			// goto prefix iri state
			@{goto(S_STATE_PRIMARY)}

		// for poorly-placed comments
		@{else_if_match('R_COMMENT', false, true)}
			// do not change state
			continue;

		@{else_retry()}
	@{end_method('base_iri')}


	@{method('prefix_id')}
		// prefix id
		@{if_match('R_PREFIX_ID', 'm_prefix_id')}
			// set temp prefix id
			this.temp_prefix_id = m_prefix_id[1];

			// goto prefix iri state
			@{goto('prefix_iri')}

		// for poorly-placed comments
		@{else_if_match('R_COMMENT', false, true)}
			// do not change state
			continue;

		@{else_retry()}

	@{end_method('prefix_id')}


	@{method('prefix_iri')}
		let h_prefixes = this.prefixes;
		let s_prefix_id = this.temp_prefix_id;
		let p_prefix_iri;

		// prefix iri
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_prefix')}
			@// set prefix mapping
			@{iriref('p_prefix_iri', 'm_iriref_e_prefix', false, false, false, true)}

			// existing mapping
			if(s_prefix_id in h_prefixes) {
				// doesn't match existing
				if(p_prefix_iri !== h_prefixes[s_prefix_id]) {
					// emit change event
					if(this.prefix_change) {
						this.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);
					}

					// update prefix
					h_prefixes[s_prefix_id] = p_prefix_iri;
				}
			}
			// first mapping; set prrefix
			else {
				h_prefixes[s_prefix_id] = p_prefix_iri;
			}

			// emit prefix event
			this.event('prefix', s_prefix_id, p_prefix_iri);

			@// handle full stop
			@{full_stop()}

			// goto statement state
			@{goto(S_STATE_PRIMARY)}

		// prefix iri
		@{else_if_match('R_IRIREF', 'm_iriref_prefix')}
			@// set prefix mapping
			@{iriref('p_prefix_iri', 'm_iriref_prefix', false, false, true, true)}

			// existing mapping
			if(s_prefix_id in h_prefixes) {
				// doesn't match existing
				if(p_prefix_iri !== h_prefixes[s_prefix_id]) {
					// emit change event
					if(this.prefix_change) {
						this.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);
					}

					// update prefix
					h_prefixes[s_prefix_id] = p_prefix_iri;
				}
			}
			// first mapping; set prrefix
			else {
				h_prefixes[s_prefix_id] = p_prefix_iri;
			}

			// emit prefix event
			this.event('prefix', s_prefix_id, p_prefix_iri);

			@// handle full stop
			@{full_stop()}

			// goto statement state
			@{goto(S_STATE_PRIMARY)}

		// for poorly-placed comments
		@{else_if_match('R_COMMENT', false, true)}
			// do not change state
			continue;

		@{else_retry()}
	@{end_method('prefix_iri')}


	// in case eos happens twice during prefix / base (extremely unlikely)
	@{method('full_stop')}
		@{if_match('R_CHAR_STOP')}
			// resume statement
			@{goto(S_STATE_PRIMARY)}

		// poorly-placed comment
		@{else_if_match('R_COMMENT', false, true)}
			// try again
			continue;
		
		// possibly interrupted by eos
		@{else_retry()}

	@{end_method('full_stop')}


	@{method('collection_subject')}
		// ref char
		let x = s[i];

		// end of collection
		@{if_char(')')}
			@{whitespace('i+1')}

			// no items in collection subject
			if(null === this.subject) {
				// prepare subject
				this.subject = KT_RDF_NIL;

				// state was never pushed to stack, jump to post_subject state
				@{goto('post_blank_subject')}
			}
			// otherwise, there must be items in collection

			// commit collection end
			this.object = KT_RDF_NIL;
			@{emit_statement()}

			// restore state from stack
			@{pop_state()}
		@{end_else()}


		// otherwise, pre-emptively secure the next blank node label
		let s_pointer_label = this.next_label();

		// very first collection object
		let b_pushed = false;
		if(null === this.subject) {
			// set quasi subject (really for resume state)
			this.subject = this.anonymous_blank_node(s_pointer_label);
			@{push_state('pairs')}
			// reset subject for later conditional branch
			this.subject = null;
			b_pushed = true;
		}

		// iriref
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_object', true)}
			@// commit object iri as is
			@{iriref('object', 'm_iriref_e_object', true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_object', true)}
			@{valid_prefix('m_prefixed_named_e_object')}

			// commit object iri from resolve prefixed name
			this.object = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_object[2]);

		// string literal
		@{else_if_char('"', "'")}
			// first item in list
			if(null === this.subject) {
				this.subject = this.anonymous_blank_node(s_pointer_label);
				this.predicate = KT_RDF_FIRST;
			}
			// not first item in list
			else {
				// make nest list item
				let kt_blank_node = this.object = this.anonymous_blank_node(s_pointer_label);
				@{emit_statement()}

				// setup for object literal
				this.subject = kt_blank_node;
				this.predicate = KT_RDF_FIRST;
			}

			// how to resume collection subject state after object literal
			this.after_end_of_statement = function() {
				this.predicate = KT_RDF_REST;
				this.after_end_of_statement = this.post_object;
				return this.collection_subject();
			};
			@{goto('string_literal')}

		// numeric literal
		@{else_if_match('R_NUMERIC_LITERAL', 'm_numeric_literal', true)}
			@{numeric_literal()}

		// boolean literal
		@{else_if_match('R_BOOLEAN_LITERAL', 'm_boolean_literal', true)}
			// make literal
			this.object = factory.literal(m_boolean_literal[1]? true: false);

		// blank node property list
		@{else_if_char('[')}
			// advance index to next token
			@{whitespace('i+1')}

			// this blank node is just the next item in the list
			let kt_blank_node;
			if(null !== this.subject) {
				kt_blank_node = this.object = this.anonymous_blank_node(s_pointer_label);
				@{emit_statement()}
			}

			// subject needs to be set
			this.subject = kt_blank_node || this.anonymous_blank_node(s_pointer_label);
			this.predicate = KT_RDF_FIRST;
			let s_label = this.next_label();
			kt_blank_node = this.object = this.anonymous_blank_node(s_label);
			@{emit_statement()}

			// when resume
			this.predicate = KT_RDF_REST;

			// push state
			@{push_state('collection_subject')}

			// prepare next triple
			this.subject = kt_blank_node;

			// goto parsing pairs state
			@{goto('pairs')}

		// new collection
		@{else_if_char('(')}
			@{whitespace('i+1', true)}

			// commit list item pointer
			let kt_blank_node = this.object = this.anonymous_blank_node(s_pointer_label);
			@{emit_statement()}

			// add this list as an item to the outer list
			this.subject = kt_blank_node;
			this.predicate = KT_RDF_REST;
			@{push_state('collection_object')}

			// prepare next triple
			this.predicate = KT_RDF_FIRST;

			// flowing
			continue;

		// labeled blank node
		@{else_if_match('R_BLANK_NODE_LABEL', 'm_blank_node_label_object', true)}
			// ref blank node label
			let s_label = m_blank_node_label_object[1];

			// make object
			this.object = this.blank_node(s_label);

		// iriref
		@{else_if_match('R_IRIREF', 'm_iriref_object', true)}
			@// commit object iri as is
			@{iriref('object', 'm_iriref_object', true, false, true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_object', true)}
			@{valid_prefix('m_prefixed_named_object')}

			@{suffix('m_prefixed_named_object')}

			// commit object iri from resolve prefixed name
			this.object = this.named_node(this.prefixes[s_prefix_id] + s_suffix);

		@{else_if_match('R_COMMENT', false, true)}
			continue;

		// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
		@{else_retry(/* syntax: js */ `
			// ran out of characters after pushing state, pop it
			if(b_pushed) this.nested.pop();
		`)}

		let kt_blank_node_outer;

		// not the very first item of collection subject
		if(this.subject !== null) {
			// ref object
			let w_object = this.object;

			// create blanknode to embed list
			kt_blank_node_outer = this.object = this.anonymous_blank_node(s_pointer_label);

			// emit statement that functions as collection's head "pointer"
			@{emit_statement()}

			// swap back object
			this.object = w_object;
		}

		// emit statement that is item
		this.subject = kt_blank_node_outer || this.anonymous_blank_node(s_pointer_label);
		this.predicate = KT_RDF_FIRST;
		@{emit_statement()}

		// prepare next predicate
		this.predicate = KT_RDF_REST;

	@{end_method('collection_subject')}



	@{method('collection_object')}

		// ref char
		let x = s[i];

		// end of collection
		@{if_char(')')}
			@{whitespace('i+1')}

			// make & emit collection's tail "pointer"
			this.object = KT_RDF_NIL;
			@{emit_statement()}

			// restore previous state
			@{pop_state()}
		@{end_else()}


		// otherwise, pre-emptively secure the next blank node label
		let s_pointer_label = this.next_label();

		// iriref
		@{if_match('R_IRIREF_ESCAPELESS', 'm_iriref_e_object', true)}
			// commit object iri as is
			@{iriref('object', 'm_iriref_e_object', true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name_escapeless', 'm_prefixed_named_e_object', true)}
			@{valid_prefix('m_prefixed_named_e_object')}

			// commit object iri from resolve prefixed name
			this.object = this.named_node(this.prefixes[s_prefix_id] + m_prefixed_named_e_object[2]);

		// string literal
		@{else_if_char('"', "'")}
			// update index before changing states
			this.i = i;

			// create blanknode to embed list
			let kt_blank_node = this.object = this.anonymous_blank_node(s_pointer_label);

			// emit statement that functions as collection's head "pointer"
			@{emit_statement()}

			// prepare statement that is item
			this.subject = kt_blank_node;
			this.predicate = KT_RDF_FIRST;

			this.after_end_of_statement = function() {
				this.predicate = KT_RDF_REST;
				this.after_end_of_statement = this.post_object;
				return this.collection_object();
			};
			@{goto('string_literal')}

		// numeric literal
		@{else_if_match('R_NUMERIC_LITERAL', 'm_numeric_literal', true)}
			@{numeric_literal()}

		// boolean literal
		@{else_if_match('R_BOOLEAN_LITERAL', 'm_boolean_literal', true)}
			// make literal
			this.object = factory.literal(m_boolean_literal[1]? true: false);

		// blank node property list
		@{else_if_char('[')}
			// advance index to next token
			@{whitespace('i+1')}

			// commit head of list pointer
			let kt_blank_node = this.object = this.anonymous_blank_node(s_pointer_label);
			@{emit_statement()}

			// setup state to resume and push
			this.subject = kt_blank_node;
			this.predicate = KT_RDF_REST;
			@{push_state('collection_object')}

			// enter blank node
			this.predicate = KT_RDF_FIRST;
			let s_label = this.next_label();
			kt_blank_node = this.object = this.anonymous_blank_node(s_label);
			@{emit_statement()}

			// prepare next triple
			this.subject = kt_blank_node;
			this.predicate = KT_RDF_FIRST;

			// goto parsing pairs state
			@{goto('pairs')}

		// new collection
		@{else_if_char('(')}
			@{whitespace('i+1', true)}

			// commit list item pointer
			let kt_blank_node = this.object = this.anonymous_blank_node(s_pointer_label);
			if(null === this.subject) {
				let a_recent = this.nested[this.nested.length-1];
				this.subject = a_recent[0];
				this.predicate = a_recent[1];
			}
			@{emit_statement()}

			// add this list as an item to the outer list
			this.subject = kt_blank_node;
			this.predicate = KT_RDF_REST;
			@{push_state('collection_object')}

			// prepare next triple
			this.predicate = KT_RDF_FIRST;

			// flowing
			continue;

		// labeled blank node
		@{else_if_match('R_BLANK_NODE_LABEL', 'm_blank_node_label_object', true)}
			// ref blank node label
			let s_label = m_blank_node_label_object[1];

			// make object
			this.object = this.blank_node(s_label);

		// iriref
		@{else_if_match('R_IRIREF', 'm_iriref_object', true)}
			// commit object iri as is
			@{iriref('object', 'm_iriref_object', true, false, true)}

		// prefixed name
		@{else_if_call('this.match_prefixed_name', 'm_prefixed_named_object', true)}
			@{valid_prefix('m_prefixed_named_object')}

			@{suffix('m_prefixed_named_object')}

			// commit object iri from resolve prefixed name
			this.object = this.named_node(this.prefixes[s_prefix_id] + s_suffix);

		@{else_if_match('R_COMMENT', false, true)}
			continue;

		// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection
		@{else_retry()}


		// ref object
		let w_object = this.object;

		// create blanknode to embed list
		let kt_blank_node_outer = this.object = this.anonymous_blank_node(s_pointer_label);

		// emit statement that functions as collection's head "pointer"
		@{emit_statement()}

		// emit statement that is item
		this.subject = kt_blank_node_outer;
		this.predicate = KT_RDF_FIRST;
		this.object = w_object;
		@{emit_statement()}

		// prepare next predicate
		this.predicate = KT_RDF_REST;

	@{end_method('collection_object')}

	@//@object-literal
}

module.exports = function(...a_args) {
	let g_config = {};

	@{normalize_reader_config('g_config')}

	// create reader, return output stream
	return (new reader(g_config)).output;
};
