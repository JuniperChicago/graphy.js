@import '../schema.js.jmacs'

const bkit = require('bkit');

const A_CHAPTERS = [
	{label:'@{S_TERM_HA}', cue:null, start:2},
	{label:'@{S_TERM_HP}', cue:'@{S_TERM_HA}'},
	{label:'@{S_TERM_SA}', cue:'@{S_TERM_HP}'},
	{label:'@{S_TERM_SP}', cue:'@{S_TERM_SA}'},
	{label:'@{S_TERM_PA}', cue:null, start:2},
	{label:'@{S_TERM_PP}', cue:'@{S_TERM_PA}'},
	{label:'@{S_TERM_OA}', cue:'@{S_TERM_HP}'},
	{label:'@{S_TERM_OP}', cue:'@{S_TERM_OA}'},
	{label:'@{S_TERM_LP}', cue:'@{S_TERM_OP}'},
	{label:'@{S_TERM_LL}', cue:'@{S_TERM_LP}'},
	{label:'@{S_TERM_LDA}', cue:'@{S_TERM_LL}'},
	{label:'@{S_TERM_LDP}', cue:'@{S_TERM_LDA}'},
];

module.exports = {
	/* eslint-disable quotes, quote-props */
	...@{
		JSON.stringify(
			bat_define('protocol', 'brp:dictionary.concise-term:pp12oc', {
				implements: 'bri:dictionary.concise-term',
				datatypes: {
					vuint: 'brdt:vuint',
				},
				members: {
					chapter: 'bri:chapter.concise-term',
				},
			}), null, '\t')},
	/* eslint-enable */

	class: dc_super => class dictionary_pp12oc extends dc_super {
		constructor(kd_datatypes, kd_members) {
			super(kd_datatypes, kd_members);

			// number of chapters
			let nl_chapters = kd_datatypes.vuint();

			// prefixes chapter
			let k_chapter_prefixes = kd_members.chapter();

			// instead of using prefix in chapter-mode, use as hash
			let h_prefixes = {};
			let i_prefix = 1;

			for(let at_prefix_iri of k_chapter_prefixes.each()) {
				h_prefixes[i_prefix++] = bkit.decode_utf_8(at_prefix_iri);
			}

			// create data view constructor ref
			let n_prefixes = k_chapter_prefixes.word_count;
			let dc_prefix_view = bkit.uint_array(n_prefixes);

			// word index that chapters will start at
			let i_start = k_chapter_prefixes.word_count + 1;

			// chapter ranges
			let h_ranges = {
				// eslint-disable-next-line quote-props
				'@{S_PREFIXES}': {
					lo: 1,
					hi: i_start,
				},
			};

			// chapter objects
			let h_chapters = {};

			// each chapter
			for(let i_chapter=0; i_chapter<12; i_chapter++) {
				let k_chapter = kd_members.chapter();
				let s_chapter = k_chapter.label;

				// skipped chapters
				while(s_chapter !== A_CHAPTERS[i_chapter].label) {
					let {
						label: s_chapter_skipped,
						cue: s_chapter_cue,
						start: i_start_skipped,
					} = A_CHAPTERS[i_chapter++];

					// no instance
					h_chapters[s_chapter_skipped] = null;

					// take cue from previous chapter
					if(s_chapter_cue) {
						let i_cue_hi = h_ranges[s_chapter_cue].hi;

						// set would-be range
						h_ranges[s_chapter_skipped] = {
							lo: i_cue_hi,
							hi: i_cue_hi,
						};
					}
					// init
					else {
						h_ranges[s_chapter_skipped] = {
							lo: i_start_skipped,
							hi: i_start_skipped,
						};
					}
				}

				// store instance to hash
				h_chapters[s_chapter] = k_chapter;

				// set range for term searching
				let g_chapter = A_CHAPTERS[i_chapter];
				let i_lo = g_chapter.cue? h_ranges[g_chapter.cue].hi: g_chapter.start;
				h_ranges[s_chapter] = {
					lo: i_lo,
					hi: i_lo + k_chapter.word_count,
				};

				// set chapter's start range
				k_chapter.offset = i_lo;
			}

			// save fields
			Object.assign(this, {
				prefixes: h_prefixes,
				ranges: h_ranges,
				chapters: h_chapters,
				prefix_view: dc_prefix_view,
				prefix_bytes: dc_prefix_view.BYTES_PER_ELEMENT,
			});
		}

		produce(i_term, s_role) {
			return this['produce_'+s_role](i_term);
		}

		produce_hop(i_term) {
			let {
				ranges: {
					@{S_TERM_HA}: h_range_ha,
					@{S_TERM_HP}: h_range_hp,
				},
				chapters: h_chapters,
			} = this;

			if(i_term < 2) {
				throw new RangeError('invalid term ID');
			}
			else if(i_term <= h_range_hp.hi) {
				if(i_term <= h_range_ha.hi) {
					return this.word_to_node_absolute(h_chapters.@{S_TERM_HA}.produce(i_term));
				}
				else {
					return this.word_to_node_prefixed(h_chapters.@{S_TERM_HP}.produce(i_term));
				}
			}
			else {
				throw new RangeError('term id exceeds hop id range');
			}
		}

	},
};
