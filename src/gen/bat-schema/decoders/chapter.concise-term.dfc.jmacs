@import '../schema.js.jmacs'

module.exports = {
	/* eslint-disable quotes, quote-props */
	...@{
		JSON.stringify(
			bat_define('protocol', 'brp:chapter.concise-term:dfc', {
				implements: 'bri:chapter.concise-term',
				datatypes: {
					string: 'bre:ntu8-string',
					vuint: 'bre:vuint',
					typed_array: 'bre:typed-array',
				},
			}), null, '\t')},
	/* eslint-enable */

	class: dc_super => class extends dc_super {
		constructor(kbd, k_decoders) {
			super();

			// section label
			let s_label = k_decoders.string();

			// block k
			let n_block_k = k_decoders.vuint();

			// word count
			let n_words = k_decoders.vuint();

			// indices
			let at_indices = k_decoders.typed_array();

			// contents (remainder of data)
			let at_contents = kbd.grab();

			Object.assign(this, {
				label: s_label,
				offset: 1,
				block_k: n_block_k,
				word_count: n_words,
				indices: at_indices,
				contents: at_contents,
			});
		}

		produce(i_term) {
			let {
				block_k: n_block_k,
				indices: at_indices,
				contents: at_contents,
			} = this;

			let i_key = i_term - this.offset;

			let i_block = i_key >>> n_block_k;
			let i_word = i_block << n_block_k;
			let i_contents = at_indices[i_block];

			//
			let n_block_size = 1 << n_block_k;
			let a_block_idx = new Array(n_block_size);
			let a_shares = new Array(n_block_size);
			a_block_idx[0] = i_contents;
			a_shares[0] = 0;
			let i_block_idx = 0;

			// head word
			let nl_word = at_contents.indexOf(0, i_contents) - i_contents;

			// head word shares no characters
			let n_share = 0;

			// word is within block
			if(i_word < i_key) {
				// skip over null char
				i_contents += 1;

				// skip words until arriving at target
				let kbd_contents = new bkit.buffer_decoder(at_contents);
				kbd_contents.read = i_contents;
				do {
					// skip over previous word
					kbd_contents.read += nl_word;

					// save share chars value
					a_shares[++i_block_idx] = n_share = kbd_contents.vuint();

					// save length of word
					nl_word = kbd_contents.vuint();

					// save index of word
					a_block_idx[i_block_idx] = kbd_contents.read;
				} while(++i_word < i_key);

				// update index
				i_contents = kbd_contents.read;
			}

			// prep to construct word
			let at_word = new Uint8Array(n_share + nl_word);

			// copy known part from current word
			at_word.set(at_contents.subarray(i_contents, i_contents+nl_word), n_share);

			// while needing to borrow from neighbor
			while(n_share > 0) {
				// check previous word's share value
				let n_prev_share = a_shares[--i_block_idx];

				// not interested!
				if(n_prev_share >= n_share) continue;

				// jump back to start of word content
				i_contents = a_block_idx[i_block_idx];

				// borrow from word
				at_word.set(at_contents.subarray(i_contents, i_contents+(n_share-n_prev_share)), n_prev_share);

				// adjust number of characters needed
				n_share = n_prev_share;
			}

			return at_word;
		}
	},
};
