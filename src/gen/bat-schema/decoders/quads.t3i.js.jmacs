@import '../schema.js.jmacs'

class Index {
	constructor(g_self) {
		Object.assign(this, g_self);
	}

	/**
	 * @abstract
	 */
	each_a() {
		throw new Error(`.each_a() was not implemented by subclass ${this}`);
	}

	/**
	 * @abstract
	 */
	fetch_b_values_a() {
		throw new Error(`.fetch_b_values_a() was not implemented by subclass ${this}`);
	}

	/**
	 * @abstract
	 */
	fetch_c_ids_ab() {
		throw new Error(`.fetch_c_ids_ab() was not implemented by subclass ${this}`);
	}

	/**
	 * @abstract
	 */
	fetch_bc_ids_a() {
		throw new Error(`.fetch_bc_ids_a() was not implemented by subclass ${this}`);
	}
}

const H_USES = {
	spo: class Index_SPO extends Index {
		constructor(k_quads) {
			super({
				triples: k_quads.triples,
			});
		}

		/**
		 * @overrides
		 */
		* each_a() {
			yield* this.triples.each_a();
		}

		/**
		 * @param {GTAR_Uint_TermId} a - 
		 * @overrides
		 */
		* fetch_b_values_a(i_a) {
			yield* this.triples.fetch_b_values_a(i_a);
		}

		/**
		 * @param {GTAR_Uint_TermId} a - 
		 * @param {GTAR_Uint_PairOffset} off_b - 
		 * @overrides
		 */
		* fetch_c_ids_ab(i_a, c_off_b) {
			yield* this.triples.fetch_c_ids_ab(i_a, c_off_b);
		}

		/**
		 * @param {GTAR_Uint_TermId} a - 
		 * @overrides
		 */
		* fetch_bc_ids_a(i_a) {
			let k_triples = this.triples;
			for(let {id:i_b, offset:c_off_b} of k_triples.fetch_b_values_a(i_a)) {
				for(let i_c of k_triples.fetch_c_ids_ab(i_a, c_off_b)) {
					yield [i_b, i_c];
				}
			}
		}
	},

	pso: class Index_PSO extends Index {
		constructor(k_quads) {
			super({
				triples: k_quads.triples,
				wavelet: k_quads.ps_index,
			});
		}

		* each_a() {
			yield* this.bitmap.each();
		}

		* fetch_b_values_a(i_a) {
			let k_wavelet = this.wavelet;
			let n_bs = k_wavelet.rank(i_a);

			for(let i_wb=0; i_wb<n_bs; i_wb++) {
				k_wavelet.select(i_a, i_wb);
			}

			yield* this.triples.fetch_b_values_a(i_a);
		}

		* fetch_c_ids_ab(i_a, c_off_b) {
			yield* this.triples.fetch_c_ids_ab(i_a, c_off_b);
		}
	},


	ops: class Index_OPS extends Index {
		constructor(k_quads) {
			super({
				triples: k_quads.triples,
				wavelet: k_quads.wavelet,
				bitmap: k_quads.op_index,
			});
		}

		/**
		 * @overrides
		 */
		* each_a() {
			yield* this.bitmap.each();
		}

		/**
		 * @overrides
		 */
		* fetch_b_values_a(i_a) {
			let k_wavelet = this.wavelet;
			for(let c_off_b of this.bitmap.fetch_ids(i_a)) {
				yield {
					id: k_wavelet.access(c_off_b),
					offset: c_off_b,
				};
			}
		}

		/**
		 * @overrides
		 */
		* fetch_c_ids_ab(i_a, c_off_b) {
			yield this.wavelet.bs.rank_1(c_off_b)+1;
		}
	},

};

module.exports = {
	/* eslint-disable quotes, quote-props */
	...@{
		JSON.stringify(
			bat_define('protocol', 'brp:quads:t3i', {
				implements: 'bri:quads',
				members: {
					triples: 'bri:triples',
					op_index: 'bri:bitmap',
					ps_index: 'bri:wavelet',
				},
			}), null, '\t')},
	/* eslint-enable */

	class: dc_super => class extends dc_super {
		constructor(kd_datatypes, kd_members) {
			super(kd_datatypes, kd_members);

			// triples
			let k_triples = kd_members.triples();

			// OP index
			let k_op_index = kd_members.op_index();

			Object.assign(this, {
				triples: k_triples,
				op_index: k_op_index,
			});
		}

		use(s_use) {
			return new (H_USES[s_use])(this);
		}
	},
};
