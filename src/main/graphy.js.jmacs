@import '../share/channel.jmacs'

@.{
	let h_content_types = {
		ttl: {},
		trig: {},
		nt: {},
		nq: {},
	};
}

@> content(s_content)
	// @{s_content} package
	const @{s_content} = {
		// read @{s_content} output
		get read() {
			// memoize
			delete @{s_content}.read;
			return @{s_content}.read = require('@{channel(`content.${s_content}.read`)}');  // eslint-disable-line global-require
		},

		// turbo @{s_content} output
		get turbo() {
			// memoize
			delete @{s_content}.turbo;
			return @{s_content}.turbo = require('@{channel(`content.${s_content}.turbo`)}');  // eslint-disable-line global-require
		},

		// write @{s_content} input
		get write() {
			// memoize
			delete @{s_content}.write;
			return @{s_content}.write = require('@{channel(`content.${s_content}.write`)}');  // eslint-disable-line global-require
		},

		// // parse @{s_content} input
		// parse(...a_args) {
		// 	return @{s_content}.parser(...a_args);
		// 	// if(1 === a_args.length) {
		// 	// 	a_args[0].validate = true;
		// 	// }
		// 	// else {
		// 	// 	a_args = [
		// 	// 		a_args[0] || null,
		// 	// 		Object.assign(a_args[1] || {}, {
		// 	// 			validate: true,
		// 	// 		}),
		// 	// 	];
		// 	// }
		// 	// return @{s_content}.deserializer(...a_args);
		// },
	};
@;

@*{
	for(let s_content in h_content_types) {
		yield content(s_content);
	}
}


// // SPARQL Results package
// const sparql_results = {
// 	// deserialize sparql_results input
// 	get deserializer() {
// 		// memoize
// 		delete sparql_results.deserializer;
// 		return (sparql_results.deserializer = require('../sparql-results/deserializer.js'));
// 	},
// };


const H_MIMES = {
	'text/turtle': ttl,
	'application/trig': trig,
	'application/n-triples': nt,
	'application/n-quads': nq,
	// 'application/sparql-results+json': sparql_results,
};

const H_SPARQL_RESULT_TYPES = {
	uri: h => graphy.namedNode(h.value),
	iri: h => graphy.namedNode(h.value),
	bnode: h => graphy.blankNode(h.value),
	literal: (h) => {
		// language
		if('xml:lang' in h) {
			return graphy.literal(h.value, h['xml:lang']);
		}
		// datatype
		else if('datatype' in h) {
			return graphy.literal(h.value, graphy.namedNode(h.datatype));
		}
		// simple
		else {
			return graphy.literal(h.value);
		}
	},

	// old version of SPARQL results
	'typed-literal': h => graphy.literal(h.value, graphy.namedNode(h.datatype)),
};


@> memoize(s_package)
	@//@object-literal
	get @{s_package}() {
		// memoize
		delete graphy.@{s_package};
		return (graphy.@{s_package} = require('@{channel(s_package)}'));
	},
@;

@.{
	let h_standalones = {
		bat: {},
		set: {},
		viz: {},
		// store: {},
	};
}

const graphy = module.exports = Object.assign({

	/**
	* API:
	**/

	content: {
		@*{
			for(let s_content in h_content_types) {
				yield /* syntax: js */ `${s_content},\n`;
			}
		}
	},

	// load triple data from arbitrary parser into memory
	get load() {
		// memoize
		delete graphy.load;
		return (graphy.load = require('./rdf-loader.js'));  // eslint-disable-line global-require
	},

	// // 
	// get bat() {
	// 	// memoize
	// 	delete graphy.bat;
	// 	return graphy.bat = require('../bat/main.js');
	// },
	// bat: require('../bat/main.js'),

	/**
	* content types:
	**/

	@*{
		for(let s_content in h_content_types) {
			yield `${s_content},\n`;
		}
	}
	// sparql_results,
	// sparqlResults: sparql_results,

	/*
	* access to flavor by mime
	*/

	write(pm_format, ...a_args) {
		let k_format = H_MIMES[pm_format];
		if(!k_format) return null;
		let k_writer = k_format.write;
		if(a_args.length) {
			return k_writer(...a_args);
		}
		return k_writer;
	},

	read(pm_format, ...a_args) {
		let k_format = H_MIMES[pm_format];
		if(!k_format) return null;
		let k_reader = k_format.read;
		if(a_args.length) {
			return k_reader(...a_args);
		}
		return k_reader;
	},

	store: {
		memory: {
			get create() {
				delete graphy.store.memory.create;
				return (graphy.store.memory.create = require('@{channel('store.memory.create')}'));
			},
		},
	},

	@*{
		for(let s_package in h_standalones) {
			yield memoize(s_package)+'\n';
		}
	}

	fromSPARQLResult(h_term) {
		return H_SPARQL_RESULT_TYPES[h_term.type](h_term);
	},

}, require('@{channel('api.data.factory')}'));

// export graphy to window object if in main thread of browser
if('undefined' !== typeof window) window.graphy = graphy;
