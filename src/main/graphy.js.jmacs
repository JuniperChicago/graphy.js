
@.{
	let h_formats = {
		ttl: {},
		trig: {},
		nt: {},
		nq: {},
	};
}

@> format(s_format)
	// @{s_format} package
	const @{s_format} = {
		// serialize @{s_format} output
		get serializer() {
			// memoize
			delete @{s_format}.serializer;
			return @{s_format}.serializer = require('@graphy/@{s_format}-serializer');
		},

		// deserialize @{s_format} input
		get deserializer() {
			// memoize
			delete @{s_format}.deserializer;
			return @{s_format}.deserializer = require('@graphy/@{s_format}-deserializer');
		},

		// parse @{s_format} input
		parse(...a_args) {
			if(1 === a_args.length) a_args[0].validate = true;
			else a_args[1].validate = true;
			return @{s_format}.deserializer(...a_args);
		},
	};
@;

@*{
	for(let s_format in h_formats) {
		yield format(s_format);
	}
}


// SPARQL Results package
const sparql_results = {
	// deserialize sparql_results input
	get deserializer() {
		// memoize
		delete sparql_results.deserializer;
		// return (sparql_results.deserializer = require('../sparql-results/deserializer.js'));
	},
};


const H_MIMES = {
	'text/turtle': ttl,
	'application/trig': trig,
	'application/n-triples': nt,
	'application/n-quads': nq,
	'application/sparql-results+json': sparql_results,
};

const H_SPARQL_RESULT_TYPES = {
	uri: h => graphy.namedNode(h.value),
	iri: h => graphy.namedNode(h.value),
	bnode: h => graphy.blankNode(h.value),
	literal: (h) => {
		// language
		if('xml:lang' in h) {
			return graphy.literal(h.value, h['xml:lang']);
		}
		// datatype
		else if('datatype' in h) {
			return graphy.literal(h.value, graphy.namedNode(h.datatype));
		}
		// simple
		else {
			return graphy.literal(h.value);
		}
	},

	// old version of SPARQL results
	'typed-literal': h => graphy.literal(h.value, graphy.namedNode(h.datatype)),
};


@> memoize(s_package)
	@//@object-literal
	get @{s_package}() {
		// memoize
		delete graphy.@{s_package};
		return (graphy.@{s_package} = require('@graphy/@{s_package}'));
	},
@;

@.{
	let h_standalones = {
		set: {},
		viz: {},
		store: {},
		writer: {},
	};
}

const graphy = module.exports = Object.assign({

	/**
	* API:
	**/

	// load triple data from arbitrary parser into memory
	get load() {
		// memoize
		delete graphy.load;
		return (graphy.load = require('./rdf-loader.js'));
	},

	// // 
	// get bat() {
	// 	// memoize
	// 	delete graphy.bat;
	// 	return graphy.bat = require('../bat/main.js');
	// },
	// bat: require('../bat/main.js'),

	/**
	* formats:
	**/

	@*{
		for(let s_format in h_formats) {
			yield `${s_format},\n`;
		}
	}
	sparql_results,
	sparqlResults: sparql_results,

	/*
	* access to flavor by mime
	*/
	serializer(pm_format, ...a_args) {
		let k_format = H_MIMES[pm_format];
		if(!k_format) return null;
		let dc_serializer = k_format.serializer;
		if(a_args.length) {
			return dc_serializer(...a_args);
		}
		return dc_serializer;
	},

	deserializer(pm_format, ...a_args) {
		let k_format = H_MIMES[pm_format];
		if(!k_format) return null;
		let dc_deserializer = k_format.deserializer;
		if(a_args.length) {
			return dc_deserializer(...a_args);
		}
		return dc_deserializer;
	},

	parse(pm_format, ...a_args) {
		let k_format = H_MIMES[pm_format];
		if(!k_format) return null;
		let dc_parser = k_format.parser;
		if(a_args.length) {
			return dc_parser(...a_args);
		}
		return dc_parser;
	},

	@*{
		for(let s_package in h_standalones) {
			yield memoize(s_package)+'\n';
		}
	}

	fromSPARQLResult(h_term) {
		return H_SPARQL_RESULT_TYPES[h_term.type](h_term);
	},

}, require('@graphy/factory'));

// export graphy to window object if in main thread of browser
if('undefined' !== typeof window) window.graphy = graphy;
