
@.{
	let h_formats = {
		ttl: {},
		trig: {},
		nt: {},
		nq: {},
	};
}

@> format(s_format)
	// @{s_format} package
	const @{s_format} = {
		// parse @{s_format} output
		get parse() {
			// memoize
			delete @{s_format}.parse;
			return @{s_format}.parse = require('@graphy/format.@{s_format}.parse');
		},

		// turbo @{s_format} output
		get turbo() {
			// memoize
			delete @{s_format}.turbo;
			return @{s_format}.turbo = require('@graphy/format.@{s_format}.turbo');
		},

		// write @{s_format} input
		get write() {
			// memoize
			delete @{s_format}.write;
			return @{s_format}.write = require('@graphy/format.@{s_format}.write');
		},

		// // parse @{s_format} input
		// parse(...a_args) {
		// 	return @{s_format}.parser(...a_args);
		// 	// if(1 === a_args.length) {
		// 	// 	a_args[0].validate = true;
		// 	// }
		// 	// else {
		// 	// 	a_args = [
		// 	// 		a_args[0] || null,
		// 	// 		Object.assign(a_args[1] || {}, {
		// 	// 			validate: true,
		// 	// 		}),
		// 	// 	];
		// 	// }
		// 	// return @{s_format}.deserializer(...a_args);
		// },
	};
@;

@*{
	for(let s_format in h_formats) {
		yield format(s_format);
	}
}


// // SPARQL Results package
// const sparql_results = {
// 	// deserialize sparql_results input
// 	get deserializer() {
// 		// memoize
// 		delete sparql_results.deserializer;
// 		return (sparql_results.deserializer = require('../sparql-results/deserializer.js'));
// 	},
// };


const H_MIMES = {
	'text/turtle': ttl,
	'application/trig': trig,
	'application/n-triples': nt,
	'application/n-quads': nq,
	// 'application/sparql-results+json': sparql_results,
};

const H_SPARQL_RESULT_TYPES = {
	uri: h => graphy.namedNode(h.value),
	iri: h => graphy.namedNode(h.value),
	bnode: h => graphy.blankNode(h.value),
	literal: (h) => {
		// language
		if('xml:lang' in h) {
			return graphy.literal(h.value, h['xml:lang']);
		}
		// datatype
		else if('datatype' in h) {
			return graphy.literal(h.value, graphy.namedNode(h.datatype));
		}
		// simple
		else {
			return graphy.literal(h.value);
		}
	},

	// old version of SPARQL results
	'typed-literal': h => graphy.literal(h.value, graphy.namedNode(h.datatype)),
};


@> memoize(s_package)
	@//@object-literal
	get @{s_package}() {
		// memoize
		delete graphy.@{s_package};
		return (graphy.@{s_package} = require('@graphy/@{s_package}'));
	},
@;

@.{
	let h_standalones = {
		bat: {},
		set: {},
		viz: {},
		store: {},
	};
}

const graphy = module.exports = Object.assign({

	/**
	* API:
	**/

	format: {
		@*{
			for(let s_format in h_formats) {
				yield /* syntax: js */ `${s_format},\n`;
			}
		}
	},

	// load triple data from arbitrary parser into memory
	get load() {
		// memoize
		delete graphy.load;
		return (graphy.load = require('./rdf-loader.js'));
	},

	// // 
	// get bat() {
	// 	// memoize
	// 	delete graphy.bat;
	// 	return graphy.bat = require('../bat/main.js');
	// },
	// bat: require('../bat/main.js'),

	/**
	* formats:
	**/

	@*{
		for(let s_format in h_formats) {
			yield `${s_format},\n`;
		}
	}
	// sparql_results,
	// sparqlResults: sparql_results,

	/*
	* access to flavor by mime
	*/

	write(pm_format, ...a_args) {
		let k_format = H_MIMES[pm_format];
		if(!k_format) return null;
		let dc_writer = k_format.writer;
		if(a_args.length) {
			return dc_writer(...a_args);
		}
		return dc_writer;
	},

	parse(pm_format, ...a_args) {
		let k_format = H_MIMES[pm_format];
		if(!k_format) return null;
		let dc_parser = k_format.parser;
		if(a_args.length) {
			return dc_parser(...a_args);
		}
		return dc_parser;
	},

	@*{
		for(let s_package in h_standalones) {
			yield memoize(s_package)+'\n';
		}
	}

	fromSPARQLResult(h_term) {
		return H_SPARQL_RESULT_TYPES[h_term.type](h_term);
	},

}, require('@graphy/factory'));

// export graphy to window object if in main thread of browser
if('undefined' !== typeof window) window.graphy = graphy;
