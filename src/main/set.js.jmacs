const crypto = require('crypto');

const stream = require('@graphy/stream');
const factory = require('@graphy/factory');


const $_KEYS = Symbol('key-count');
const $_QUADS = Symbol('quad-count');

class Issuer {
	constructor(s_prefix='_:c14n') {
		Object.assign(this, {
			prefix: s_prefix,
			counter: 0,
			existing: {},
		});
	}

	issue(s_label) {
		if(s_label in this.existing) return this.existing[s_label];

		return (this.existing[s_label] = this.prefix+(this.counter++));
	}

	has(s_label) {
		return s_label in this.existing;
	}

	clone() {
		return Object.assign(new Issuer(this.prefix), {
			counter: this.counter,
			existing: Object.assign({}, this.existing),
		});
	}
}

const F_SORT_CANONICALIZER_HASH = (g_a, g_b) => g_a.hash < g_b.hash? -1: (g_a.hash > g_b.hash? 1: 0);

const permutations = function *(a_list) {
	let b_done = false;
	let h_left = {};

	if(a_list.lenth <= 1) {
		yield a_list;
		return;
	}

	a_list.sort();
	for(let s_item of a_list) {
		h_left[s_item] = true;
	}

	do {
		yield a_list;

		let s_k = null;
		let i_pos = 0;
		let nl_list = a_list.length;
		for(let i_item=0; i_item<nl_list; i_item++) {
			let s_item = a_list[i_item];
			let b_left = h_left[s_item];
			if((null === s_k || s_item > s_k)
				&& ((b_left && i_item > 0 && s_item > a_list[i_item-1])
					|| (!b_left && i_item < (nl_list-1) && s_item > a_list[i_item+1]))
			) {
				s_k = s_item;
				i_pos = i_item;
			}
		}

		if(null === s_k) {
			b_done = true;
		}
		else {
			let i_swap = h_left[s_k]? i_pos-1: i_pos+1;
			a_list[i_pos] = a_list[i_swap];
			a_list[i_swap] = s_k;

			// reverse direction of all elements larger thn k
			for(let s_item of a_list) {
				if(s_item > s_k) {
					h_left[s_item] = !h_left[s_item];
				}
			}
		}
	} while(!b_done);

	yield a_list;
};

@.{
	const A_TERM_ROLES_BLANK_NODES = ['graph', 'subject', 'object'];
}

class Canonicalizer_ct {
	constructor(k_set) {
		Object.assign(this, {
			set: k_set,
			blanks: {},
			issuer: new Issuer('_r'),
			quads: [...k_set.ct_quads()],
		});
	}

	normalize() {
		let {
			blanks: h_blanks,
			issuer: k_issuer,
			quads: a_quads,
		} = this;

		let h_hashes = {};
		let h_non_normal = {};

		// each quad
		for(let a_quad of a_quads) {
			let [sct_graph, sct_subject, , sct_object] = a_quad;

			@> normalize_check(s_var)
				if('_' === @{s_var}[0]) {
					if(@{s_var} in h_blanks) {
						h_blanks[@{s_var}].quads.push(a_quad);
					}
					else {
						h_blanks[@{s_var}] = {quads:[a_quad]};
						h_non_normal[@{s_var}] = true;
					}
				}
			@;
			@*{
				for(let s_var of A_TERM_ROLES_BLANK_NODES.map(s => `sct_${s}`)) {
					yield normalize_check(s_var);
				}
			}
		}

		let b_simple = false;

		do {
			b_simple = false;

			h_hashes = {};

			for(let sct_blank in h_non_normal) {
				let p_blank = this.hash_first_degree_quads(sct_blank);

				if(p_blank in h_hashes) {
					h_hashes[p_blank].push(sct_blank);
				}
				else {
					h_hashes[p_blank] = [sct_blank];
				}
			}

			for(let p_blank of Object.keys(h_hashes).sort()) {
				let a_blanks = h_hashes[p_blank];
				if(a_blanks.length > 1) continue;

				let sct_blank_0 = a_blanks[0];
				k_issuer.issue(sct_blank_0);

				delete h_non_normal[sct_blank_0];

				delete h_hashes[p_blank];

				b_simple = true;
			}
		} while(b_simple);

		for(let p_blank of Object.keys(h_hashes).sort()) {
			let a_paths = [];
			for(let sct_blank of h_hashes[p_blank]) {
				if(k_issuer.has(sct_blank)) continue;

				let k_issuer_tmp = new Issuer('_g');
				k_issuer_tmp.issue(sct_blank);
				
				a_paths.push(
					this.hash_n_degree_quads(sct_blank, k_issuer_tmp));
			}

			for(let g_hash_result of a_paths.sort(F_SORT_CANONICALIZER_HASH)) {
				for(let sct_existing in g_hash_result.issuer.existing) {
					k_issuer.issue(sct_existing);
				}
			}
		}

		let a_normalized = [];
		let s_issuer_prefix = k_issuer.prefix;
		for(let a_quad of a_quads) {
			let [sct_graph, sct_subject, sct_predicate, sct_object] = a_quad;

			@> normalize_update(s_var)
				if('_' === @{s_var}[0] && !@{s_var}.startsWith(s_issuer_prefix)) {
					@{s_var} = k_issuer.issue(@{s_var});
				}
			@;

			@*{
				for(let s_var of A_TERM_ROLES_BLANK_NODES.map(s => `sct_${s}`)) {
					yield normalize_update(s_var);
				}
			}

			a_normalized.push([
				sct_graph,
				sct_subject,
				sct_predicate,
				sct_object,
			].join('\0\t')+'\0\n');
		}

		return a_normalized.sort().join('');
	}

	hash_first_degree_quads(sct_blank) {
		let {
			blanks: h_blanks,
			quads: a_quads,
		} = this;

		let g_blank = h_blanks[sct_blank];
		if('hash' in g_blank) return g_blank.hash;

		let a_nquads = [];
		for(let a_quad of a_quads) {
			let [sct_graph, sct_subject, sct_predicate, sct_object] = a_quad;

			@> normalize_1st_deg(s_var)
				sct_blank === @{s_var}
					? '_i'
					: ('_' === @{s_var}[0]
						? '_o'
						: @{s_var}),
			@;

			a_nquads.push([
				@{normalize_1st_deg('sct_graph')}
				@{normalize_1st_deg('sct_subject')}
				sct_predicate,
				@{normalize_1st_deg('sct_object')}
			].join('\0\t')+'\0\n');
		}

		let p_hash = crypto.createHash('sha256')
			.update(a_nquads.sort().join('\n'))
			.digest('hex');

		g_blank.hash = p_hash;

		return p_hash;
	}

	hash_n_degree_quads(sct_blank, k_issuer) {
		let {
			issuer: k_issuer_root,
		} = this;

		let h_related = this.hash_to_related(sct_blank, k_issuer);

		let d_hash = crypto.createHash('sha256');
		for(let p_related of Object.keys(h_related).sort()) {
			d_hash.update(p_related);
			let s_path_chosen = '';
			let k_issuer_chosen;

			for(let a_perm of permutations(h_related[p_related])) {
				let k_issuer_copy = k_issuer.clone();
				let s_path = '';
				let a_recurse = [];

				let b_next_perm = false;
				for(let p_other of a_perm) {
					if(k_issuer_root.has(p_other)) {
						s_path += k_issuer_root.issue(p_other);
					}
					else {
						if(!k_issuer_copy.has(p_other)) {
							a_recurse.push(p_other);
						}

						s_path += k_issuer_copy.issue(p_other);
					}

					if(s_path_chosen.length
						&& s_path.length >= s_path_chosen.length
						&& s_path > s_path_chosen
					) {
						b_next_perm = true;
						break;
					}
				}

				if(b_next_perm) continue;

				for(let p_other of a_recurse) {
					let g_hash_result = this.hash_n_degree_quads(p_other, k_issuer_copy);

					s_path += k_issuer_copy.issue(p_other);

					s_path += '_#'+g_hash_result.hash;

					k_issuer_copy = g_hash_result.issuer;

					if(s_path_chosen.length
						&& s_path.length >= s_path_chosen.length
						&& s_path > s_path_chosen
					) {
						b_next_perm = true;
						break;
					}
				}

				if(b_next_perm) continue;

				if(!s_path_chosen.length || s_path < s_path_chosen) {
					s_path_chosen = s_path;
					k_issuer_chosen = k_issuer_copy;
				}
			}

			d_hash.update(s_path_chosen);

			k_issuer = k_issuer_chosen;
		}

		return {
			hash: d_hash.digest('hex'),
			issuer: k_issuer,
		};
	}

	hash_to_related(sct_blank, k_issuer) {
		let {
			blanks: h_blanks,
		} = this;

		let h_related = {};
		for(let a_quad of h_blanks[sct_blank].quads) {
			let [sct_graph, sct_subject, , sct_object] = a_quad;
			@> normalize_hash_related(s_var, i_var)
				if('_' === @{s_var}[0] && @{s_var} !== sct_blank) {
					let p_related = this.hash_related_blank_node(@{s_var}, a_quad, k_issuer, @{i_var});
					if(p_related in h_related) {
						h_related[p_related].push(@{s_var});
					}
					else {
						h_related[p_related] = [@{s_var}];
					}
				}
			@;
			@{normalize_hash_related('sct_graph', 0)}
			@{normalize_hash_related('sct_subject', 1)}
			@{normalize_hash_related('sct_object', 3)}
		}

		return h_related;
	}

	hash_related_blank_node(sct_blank, a_quad, k_issuer, i_role) {
		let k_issuer_root = this.issuer;
		let sct_use;
		if(k_issuer_root.has(sct_blank)) {
			sct_use = k_issuer_root.issue(sct_blank);
		}
		else if(k_issuer.has(sct_blank)) {
			sct_use = k_issuer.issue(sct_blank);
		}
		else {
			sct_use = this.hash_first_degree_quads(sct_blank);
		}

		let d_hash = crypto.createHash('sha256');
		d_hash.update(i_role+'');
		if(i_role) {
			d_hash.update(`<${a_quad[2]}>`);
		}

		d_hash.update(sct_use);

		return d_hash.digest('hex');
	}
}

class QuadSet extends stream.Writable {
	constructor(h_quad_tree=null, g_config={}) {
		super({
			// expect quads as input
			objectMode: true,

			// on write method
			write(g_quad, s_encoding, fk_write) {
				this.add(g_quad);
				fk_write();
			},
		});

		Object.assign(this, {
			quad_tree: h_quad_tree || {[$_KEYS]:0, [$_QUADS]:0},
			digest: null,
			root_blanks: {},
			leaf_blanks: {},
			debug: g_config.debug || false,
		});
	}

	*quads() {
		let h_quads = this.quad_tree;
		for(let s_graph in h_quads) {
			let h_subjects = h_quads[s_graph];
			let g_graph = factory.ct(s_graph);
			for(let s_subject in h_subjects) {
				let h_predicates = h_subjects[s_subject];
				let g_subject = factory.ct(s_subject);
				for(let s_predicate in h_predicates) {
					let as_objects = h_predicates[s_predicate];
					let g_predicate = factory.ct(s_predicate);
					for(let s_object of as_objects) {
						yield factory.quad(
							g_subject,
							g_predicate,
							factory.ct(s_object),
							g_graph,
						);
					}
				}
			}
		}
	}

	*ct_quads() {
		let h_quads = this.quad_tree;
		for(let sct_graph in h_quads) {
			let h_subjects = h_quads[sct_graph];
			for(let sct_subject in h_subjects) {
				let h_predicates = h_subjects[sct_subject];
				for(let sct_predicate in h_predicates) {
					let as_objects = h_predicates[sct_predicate];
					for(let sct_object of as_objects) {
						yield [sct_graph, sct_subject, sct_predicate, sct_object];
					}
				}
			}
		}
	}

	*graphs() {
		for(let s_graph in this.quad_tree) {
			yield s_graph;
		}
	}

	*subjects(s_graph) {
		let h_subjects = this.quad_tree[s_graph];
		for(let s_subject in h_subjects) {
			yield s_subject;
		}
	}

	*predicates(s_graph, s_subject) {
		let h_predicates = this.quad_tree[s_graph][s_subject];
		for(let s_predicate in h_predicates) {
			yield s_predicate;
		}
	}

	*objects(s_graph, s_subject, s_predicate) {
		yield* this.quad_tree[s_graph][s_subject][s_predicate];
	}

	// add a quad to this set
	add(g_quad) {
		let h_quads = this.quad_tree;

		let p_graph = g_quad.graph.concise();
		let p_subject = g_quad.subject.concise();
		let p_predicate = g_quad.predicate.concise();
		let p_object = g_quad.object.concise();

		// first encounter of graph
		if(!(p_graph in h_quads)) {
			// add new tree under graph
			h_quads[p_graph] = {
				[$_KEYS]: 1,
				[$_QUADS]: 1,
				[p_subject]: {
					[$_KEYS]: 1,
					[$_QUADS]: 1,
					[p_predicate]: new Set([p_object]),
				},
			};

			// increment how many graphs there are in this set
			h_quads[$_KEYS] += 1;
		}
		// graph exists
		else {
			let h_triples = h_quads[p_graph];

			// first encounter of subject
			if(!(p_subject in h_triples)) {
				// add new tree under subject
				h_triples[p_subject] = {
					[$_KEYS]: 1,
					[$_QUADS]: 1,
					[p_predicate]: new Set([p_object]),
				};

				// increment how many subjects there are under this graph
				h_triples[$_KEYS] += 1;
			}
			// subject exists
			else {
				let h_pairs = h_triples[p_subject];

				// first encounter of predicate
				if(!(p_predicate in h_pairs)) {
					// add new set under predicate
					h_pairs[p_predicate] = new Set([p_object]);

					// increment how many predicates there are under this subject
					h_pairs[$_KEYS] += 1;
				}
				// predicate exists
				else {
					let as_objects = h_pairs[p_predicate];

					// first encounter of object
					if(!as_objects.has(p_object)) {
						// add object to set
						as_objects.add(p_object);
					}
					// duplicate
					else {
						return;
					}
				}

				// increment how many quads there are under this subject
				h_pairs[$_QUADS] += 1;
			}

			// increment how many quads there are under this graph
			h_triples[$_QUADS] += 1;
		}

		// increment how many quads there are in set
		h_quads[$_QUADS] += 1;

		// subject is blank node
		if(g_quad.subject.isBlankNode) {
			let h_root_blanks = this.root_blanks;
			if(p_subject in h_root_blanks) {
				h_root_blanks[p_subject].add(g_quad);
			}
			else {
				h_root_blanks[p_subject] = new Set([g_quad]);
			}
		}

		// object is blank node
		if(g_quad.object.isBlankNode) {
			let h_leaf_blanks = this.leaf_blanks;
			if(p_object in h_leaf_blanks) {
				h_leaf_blanks[p_object].add(g_quad);
			}
			else {
				h_leaf_blanks[p_object] = new Set([g_quad]);
			}
		}

		// invalidate hash and canonicalization
		this.hash = this.canonicalization = null;
	}

	equals(k_other) {
		// both have digest precomputed
		if(this.digest && k_other.digest) {
			return this.digest === k_other.digest;
		}

		// ref quads
		let h_quads_a = this.quad_tree;
		let h_quads_b = k_other.quad_tree;

		// different key count or quad count; cannot be equal
		if(h_quads_a[$_QUADS] !== h_quads_b[$_QUADS] || h_quads_a[$_KEYS] !== h_quads_b[$_KEYS]) {
			return false;
		}

		// compare digests
		return this.hash() === k_other.hash();
	}

	// generate the canonical string representation of a quad
	canonicalize_quad(g_quad, h_hashed, a_visited) {
		let {
			subject: h_subject,
			object: h_object,
		} = g_quad;

		return g_quad.graph.concise()+'\0\n'
			+(h_subject.isBlankNode
				? this.hash_blank_node(h_subject.concise(), h_hashed, a_visited)
				: h_subject.concise()+'')+'\0\n'
			+g_quad.predicate.concise()+'\0\n'
			+(h_object.isBlankNode
				? this.hash_blank_node(h_object.concise(), h_hashed, a_visited)
				: h_object.concise())+'\0\n';
	}

	canonicalize() {
		let k_normalize = new Canonicalizer_ct(this);
		return k_normalize.normalize();
	}

	// create union of two sets
	union(k_other) {
		// ref quads
		let h_quads_a = this.quad_tree;
		let h_quads_b = k_other.quad_tree;

		// a has less keys than b; swap quads
		if(h_quads_a[$_KEYS] < h_quads_b[$_KEYS]) {
			[h_quads_a, h_quads_b] = [h_quads_b, h_quads_a];
		}

		// prep quads union
		let h_quads_u = Object.create(h_quads_a);

		// each graph in a
		for(let p_graph in h_quads_a) {
			// graph is also in b
			if(p_graph in h_quads_b) {
				// ref triples
				let h_triples_a = h_quads_a[p_graph];
				let h_triples_b = h_quads_b[p_graph];

				// a has less keys than b; swap triples
				if(h_triples_a[$_KEYS] < h_triples_b[$_KEYS]) {
					[h_triples_a, h_triples_b] = [h_triples_b, h_triples_a];
				}

				// prep triples union and save it to quads union
				let h_triples_u = h_quads_u[p_graph] = Object.create(h_triples_a);

				// each subject in a
				for(let p_subject in h_triples_a) {
					// subject is also in b
					if(p_subject in h_triples_b) {
						// ref pairs
						let h_pairs_a = h_triples_a[p_subject];
						let h_pairs_b = h_triples_b[p_subject];

						// a has less keys than b; swap pairs
						if(h_pairs_a[$_KEYS] < h_pairs_b[$_KEYS]) {
							[h_pairs_a, h_pairs_b] = [h_pairs_b, h_pairs_a];
						}

						// prep pairs union and save it to triples union
						let h_pairs_u = h_triples_u[p_subject] = Object.create(h_pairs_a);

						// each predicate in a
						for(let p_predicate in h_pairs_a) {
							// predicate is also in b
							if(p_predicate in h_pairs_b) {
								// ref objects
								let as_objects_a = h_pairs_a[p_predicate];
								let as_objects_b = h_pairs_b[p_predicate];

								// union sets and save it to pairs union
								let as_objects_u = h_pairs_u[p_predicate] = new Set([...as_objects_a, ...as_objects_b]);

								// update quad counts with difference
								let n_quads_add = as_objects_u.size - as_objects_a.size;
								h_pairs_u[$_QUADS] += n_quads_add;
								h_triples_u[$_QUADS] += n_quads_add;
								h_quads_u[$_QUADS] += n_quads_add;
							}
						}

						// each predicate in b
						for(let p_predicate in h_pairs_b) {
							// predicate is not in a
							if(!(p_predicate in h_triples_a)) {
								// add all objects from this predicate
								h_pairs_u[p_predicate] = h_pairs_b[p_predicate];

								// update key count
								h_pairs_u[$_KEYS] += 1;

								// update quad counts
								let n_quads_add = h_pairs_b[p_predicate].size;
								h_pairs_u[$_QUADS] += n_quads_add;
								h_triples_u[$_QUADS] += n_quads_add;
								h_quads_u[$_QUADS] += n_quads_add;
							}
						}
					}
				}

				// each subject in b
				for(let p_subject in h_triples_b) {
					// subject is not is a
					if(!(p_subject in h_triples_a)) {
						// add all pairs from this subject
						let h_pairs_u = h_triples_u[p_subject] = h_triples_b[p_subject];

						// update key count
						h_triples_u[$_KEYS] += 1;

						// update quad counts
						let n_quads_add = h_pairs_u[$_QUADS];
						h_triples_u[$_QUADS] += n_quads_add;
						h_quads_u[$_QUADS] += n_quads_add;
					}
				}
			}
		}

		// each graph in b
		for(let p_graph in h_quads_b) {
			// graph is not in a
			if(!(p_graph in h_quads_b)) {
				// add all triples from this graph
				let h_triples_u = h_quads_u[p_graph] = h_quads_b[p_graph];

				// update key count
				h_quads_u[$_KEYS] += 1;

				// update quad counts
				let n_quads_add = h_triples_u[$_QUADS];
				h_quads_u[$_QUADS] += n_quads_add;
			}
		}

		return new QuadSet(h_quads_u);
	}

	// compute intersection of two sets
	intersection(k_other) {
		// ref quads
		let h_quads_a = this.quad_tree;
		let h_quads_b = k_other.quad_tree;

		// set b has less quads than set a; swap quadss
		if(h_quads_b[$_KEYS] < h_quads_a[$_KEYS]) {
			[h_quads_a, h_quads_b] = [h_quads_b, h_quads_a];
		}

		// prep quads intersection
		let h_quads_i = {[$_KEYS]:0, [$_QUADS]:0};

		// each graph in a
		for(let p_graph in h_quads_a) {
			// graph is also in b
			if(p_graph in h_quads_b) {
				// ref tripless
				let h_triples_a = h_quads_a[p_graph];
				let h_triples_b = h_quads_b[p_graph];

				// set b has less triples than set a; swap triples
				if(h_triples_b[$_KEYS] < h_triples_a[$_KEYS]) {
					[h_triples_a, h_triples_b] = [h_triples_b, h_triples_a];
				}

				// prep triples intersection
				let h_triples_i = {[$_KEYS]:0, [$_QUADS]:0};

				// each subject in a
				for(let p_subject in h_triples_a) {
					// subject is also in b
					if(p_subject in h_triples_b) {
						// ref pairs
						let h_pairs_a = h_triples_a[p_subject];
						let h_pairs_b = h_triples_b[p_subject];

						// set b has less pairs than set a; swap pairs
						if(h_pairs_b[$_KEYS] < h_pairs_a[$_KEYS]) {
							[h_pairs_a, h_pairs_b] = [h_pairs_b, h_pairs_a];
						}

						// prep pairs intersection
						let h_pairs_i = {[$_KEYS]:0, [$_QUADS]:0};

						// each predicate in a
						for(let p_predicate in h_pairs_a) {
							// predicate is also in b
							if(p_predicate in h_pairs_b) {
								// ref objects
								let as_objects_a = h_pairs_a[p_predicate];
								let as_objects_b = h_pairs_b[p_predicate];

								// set b has less objects than set a; swap objects
								if(as_objects_b.size < as_objects_a.size) {
									[as_objects_a, as_objects_b] = [as_objects_b, as_objects_a];
								}

								// prep objects intersection
								let as_objects_i = new Set();

								// each object in a
								for(let p_object of as_objects_a) {
									// object is also in b
									if(as_objects_b.has(p_object)) {
										// add to intersection
										as_objects_i.add(p_object);
									}
								}

								// non-empty object intersection
								if(as_objects_i) {
									// add objects to pair
									h_pairs_i[p_predicate] = as_objects_i;

									// update key count
									h_pairs_i[$_KEYS] += 1;

									// update quad count
									h_pairs_i[$_QUADS] += as_objects_i.size;
								}
							}
						}

						// non-empty pairs intersection
						if(h_pairs_i[$_KEYS]) {
							// add pairs to triples
							h_triples_i[p_subject] = h_pairs_i;

							// update key count
							h_triples_i[$_KEYS] += 1;

							// update quad count
							h_triples_i[$_QUADS] += 1;
						}
					}
				}

				// non-empty triples intersection
				if(h_triples_i[$_KEYS]) {
					// add triples to quads
					h_quads_i[p_graph] = h_triples_i;

					// update key count
					h_quads_i[$_KEYS] += 1;

					// update quad count
					h_quads_i[$_QUADS] += 1;
				}
			}
		}

		return new QuadSet(h_quads_i);
	}

	// subtract a subset from this
	minus_subset(k_subset) {
		// ref quads
		let h_quads_a = this.quad_tree;
		let h_quads_b = k_subset.quad_tree;

		// prep quads remainder
		let h_quads_r = {[$_KEYS]:0, [$_QUADS]:0};

		// each graph in a
		for(let p_graph in h_quads_a) {
			// graph is also in b
			if(p_graph in h_quads_b) {
				// ref tripless
				let h_triples_a = h_quads_a[p_graph];
				let h_triples_b = h_quads_b[p_graph];

				// prep triples remainder
				let h_triples_r = {[$_KEYS]:0, [$_QUADS]:0};

				// each subject in a
				for(let p_subject in h_triples_a) {
					// subject is also in b
					if(p_subject in h_triples_b) {
						// ref pairs
						let h_pairs_a = h_triples_a[p_subject];
						let h_pairs_b = h_triples_b[p_subject];

						// prep pairs remainder
						let h_pairs_r = {[$_KEYS]:0, [$_QUADS]:0};

						// each predicate in b
						for(let p_predicate in h_pairs_b) {
							// ref objects
							let as_objects_a = h_pairs_a[p_predicate];
							let as_objects_b = h_pairs_b[p_predicate];

							// prep objects remainder
							let as_objects_r = new Set(as_objects_a);

							// each object in b
							for(let p_object of as_objects_b) {
								// remove from remainder
								as_objects_r.delete(p_object);
							}

							// non-empty object remainder
							if(as_objects_r.size) {
								// add objects to pair
								h_pairs_r[p_predicate] = as_objects_r;

								// update key count
								h_pairs_r[$_KEYS] += 1;

								// update quad count
								h_pairs_r[$_QUADS] += as_objects_r.size;
							}
						}

						// non-empty pairs remainder
						if(h_pairs_r[$_KEYS]) {
							// add pairs to triples
							h_triples_r[p_subject] = h_pairs_r;

							// update key count
							h_triples_r[$_KEYS] += 1;

							// update quad count
							h_triples_r[$_QUADS] += h_pairs_r[$_QUADS];
						}
					}
					// subject is not in b
					else {
						// add all pairs from this subject
						let h_pairs_r = h_triples_r[p_subject] = h_triples_a[p_graph];

						// update key count
						h_triples_r[$_KEYS] += 1;

						// update quad count
						h_triples_r[$_QUADS] += h_pairs_r[$_QUADS];
					}
				}

				// non-empty triples intersection
				if(h_triples_r[$_KEYS]) {
					// add triples to quads
					h_quads_r[p_graph] = h_triples_r;

					// update key count
					h_quads_r[$_KEYS] += 1;

					// update quad count
					h_quads_r[$_QUADS] += h_triples_r[$_QUADS];
				}
			}
			// graph is not in b
			else {
				// add all triples from this graph
				let h_triples_r = h_quads_r[p_graph] = h_quads_a[p_graph];

				// update key count
				h_quads_r[$_KEYS] += 1;

				// update quad count
				h_quads_r[$_QUADS] += h_triples_r[$_QUADS];
			}
		}

		// return new quad set
		return new QuadSet(h_quads_r);
	}

	// tests if another set is included in this set
	includes(k_other) {
		// compute intersection first
		let k_i = this.intersection(k_other);

		// (A ∩ B) == B
		return k_i.equals(k_other);
	}

	// subtract another set from this
	minus(k_other) {
		// compte intersection first
		let k_i = this.intersection(k_other);

		// A - (A ∩ B)
		return this.minus_subset(k_i);
	}

	// compute the difference of two sets
	difference(k_other) {
		// compute intersection first
		let k_i = this.intersection(k_other);

		// (A - (A ∩ B)) ∪ (B - (A ∩ B))
		return this.minus_subset(k_i)
			.union(k_other.minus_subset(k_i));
	}

	// count how many quads match the given selector
	count(a_terms=[]) {
		// no terms; return quad count
		if(!a_terms.length) return this.quad_tree[$_QUADS];

		// normalize terms
		let act_terms = a_terms.map((z) => {
			// concise term string
			if('string' === typeof z) return z;

			// rdfjs term
			if('termType' in z) {
				// graphy term
				if('concise' in z) return z.concise();

				// foreign term; make graphy
				return factory.term(z).concsie();
			}

			// null
			if(null === z) return z;

			// invalid
			throw new TypeError(`invalid type for term in array: ${z}`);
		});

		// ref quads
		let h_quads = this.quad_tree;

		// number of terms
		let nl_terms = act_terms.length;

		// matching trees
		let a_trees = [];

		// graph
		let p_graph = act_terms[0];

		// variable; take all graphs
		if(null === p_graph) {
			a_trees = Object.values(h_quads);
		}
		// specific
		else {
			a_trees = [h_quads[p_graph]];
		}

		// subject
		if(nl_terms > 1) {
			let p_subject = act_terms[1];

			// prep to swap out trees
			let a_swap = [];

			// variable
			if(null === p_subject) {
				// take all subjects
				a_trees.forEach((h) => {
					a_swap.push(...Object.values(h));
				});
			}
			// specific
			else {
				a_trees.forEach((h) => {
					if(p_subject in h) {
						a_swap.push(h[p_subject]);
					}
				});
			}

			// swap in for trees
			a_trees = a_swap;

			// predicate given
			if(nl_terms > 2) {
				let p_predicate = act_terms[2];

				// prep to swap out trees
				a_swap = [];

				// variable
				if(null === p_predicate) {
					// take all predicates
					a_trees.forEach((h) => {
						a_swap.push(...Object.values(h));
					});
				}
				// specific
				else {
					a_trees.forEach((h) => {
						if(p_predicate in h) {
							a_swap.push(h[p_predicate]);
						}
					});
				}

				// swap in for trees
				a_trees = a_swap;

				// object given
				if(nl_terms > 3) {
					let p_object = act_terms[3];

					// prep to count objects
					let c_objects = 0;

					// variable
					if(null === p_object) {
						// take all objects
						a_trees.forEach((as) => {
							c_objects += as.size;
						});
					}
					// specific
					else {
						// count objects
						a_trees.forEach((h) => {
							if(p_object in h) {
								c_objects += 1;
							}
						});
					}

					// more terms given
					if(nl_terms > 4) {
						throw new Error(`too many values given in terms array`);
					}

					// object count
					return c_objects;
				}
			}
		}

		// reduce final quad count
		return a_trees.reduce((c, h) => c + h[$_QUADS], 0);
	}
}

Object.assign(QuadSet, {
	isGraphySet: true,
});

module.exports = function(...a_args) {
	return new QuadSet(...a_args);
};
