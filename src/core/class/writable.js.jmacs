@import '../../share/channel.jmacs'
@import '../../share/iris.jmacs'
@import '../../share/writer.jmacs'

const factory = require('@{channel('core.data.factory')}');
const Scribable = require('@{channel('core.class.scribable')}');

const R_DIRECTIVE_CONTENTS = /^`\[[^\]]+\](.*)$/;

const HM_COERCIONS_DEFAULT = new Map([
	[Date, dt => factory.dateTime(dt)],
	[Number, x => factory.number(x)],
]);

class Writable extends Scribable {
	constructor(gc_writable={}) {
		super(gc_writable);

		let {
			collections: gc_collections=null,
		} = gc_writable;

		// start with default coercions map
		let hm_coercions = HM_COERCIONS_DEFAULT;

		// user is overriding coercions
		if(gc_writable.coercions) {
			// copy default map
			hm_coercions = new Map(hm_coercions);

			// add each entry from user-defined map
			for(let [dc_type, f_transform] of gc_writable.coercions) {
				hm_coercions.set(dc_type, f_transform);
			}
		}

		// collections 
		let g_collections = {
			first: '>@{P_IRI_RDF}first',
			rest: '>@{P_IRI_RDF}rest',
			nil: '>@{P_IRI_RDF}nil',
		};

		// custom transcoder
		if(gc_collections) {
			let {
				first: sc1_first=null,
				rest: sc1_rest=null,
				nil: sc1_nil=null,
			} = gc_collections;

			if(sc1_first) g_collections.first = sc1_first;
			if(sc1_rest) g_collections.rest = sc1_rest;
			if(sc1_nil) g_collections.nil = sc1_nil;
		}

		Object.assign(this, {
			_xc_state: @{XC_STATE_INITIAL},
			_hm_coercions: hm_coercions,
			_g_collections: g_collections,
		});

		// // one new sources
		// this.on('pipe', (ds_src) => {
		// 	// listen for prefix events
		// 	ds_src.on('prefix', (s_prefix_id, p_iri) => {
		// 		this.write({
		// 			type: 'prefixes',
		// 			value: {
		// 				[s_prefix_id]: p_iri,
		// 			},
		// 		})
		// 	});

		// 	// listen for comment events
		// 	ds_src.on('comment', (s_comment) => {
		// 		this.write({
		// 			type: 'c3',
		// 			value: {
		// 				[factory.comment()]: s_comment,
		// 			},
		// 		});
		// 	});
		// });

	}

	// serialize comment
	_serialize_comment(s_comment) {
		let s_write = '';

		// non-data state
		if(@{XC_STATE_DATA} !== this._xc_state) {
			// break line
			s_write += '\n';

			// update state
			this._xc_state = @{XC_STATE_DATA};
		}

		return s_write+(super._serialize_comment(s_comment) || '');
	}

	// // serialize newlines
	// _serialize_newlines(n_newlines) {  // eslint-disable-line class-methods-use-this
	// 	// no need to check/change state
	// 	return '\n'.repeat(n_newlines);
	// }

	// transcode collection into concise-pairs hash
	_transcode_collection(a_collection) {
		let g_collections = this._g_collections;

		// empty collection
		if(!a_collection.length) {
			return g_collections.nil;
			// return {
			// 	[g_collections.first]: g_collections.nil,
			// };
		}
		// non-empty collection
		else {
			let z_item = a_collection[0];
			let w_first = z_item;

			// item is nested collection; transcode
			if(Array.isArray(z_item)) {
				w_first = this._transcode_collection(z_item);  // eslint-disable-line no-invalid-this
			}

			return {
				// first item
				[g_collections.first]: w_first,

				// rest of items
				[g_collections.rest]: 1 === a_collection.length
					? g_collections.nil
					: this._transcode_collection(a_collection.slice(1)),  // eslint-disable-line no-invalid-this
			};
		}
	}


	// // route writable data events
	// data_event(g_event) {
	// 	let {
	// 		type: s_type,
	// 		value: z_value,
	// 	} = g_event;

	// 	// method id
	// 	let s_method = 'serialize_'+s_type;

	// 	// event type exists
	// 	if('function' === typeof this[s_method]) {
	// 		return this[s_method](z_value);
	// 	}
	// 	// no such event type
	// 	else {
	// 		throw new Error(`no such writable data event type for RDF stream: '${s_type}'`);
	// 	}
	// }


	// serialize a writable data event directive
	_encode_directive(sc1_directive, w_value) {
		// directive contents
		let m_directive = R_DIRECTIVE_CONTENTS.exec(sc1_directive);
		if(!m_directive) {
			throw new Error(`Invalid writable data event directive string: "${sc1_directive}"`);
		}

		// parse as JSON
		let g_directive;
		try {
			g_directive = JSON.parse(m_directive[1]);
		}
		catch(e_parse) {
			throw new Error(`Unable to parse JSON in writable data event directive: "${m_directive[1]}"`);
		}

		// directive type
		let s_type = g_directive.type;

		// deduce directive type
		switch(s_type) {
			// comment
			case 'comment': {
				// serializer supports commenting; serialize comment
				if(this._serialize_comment) {
					return this._serialize_comment(w_value+'', g_directive);
				}
				break;
			}

			// newlines
			case 'newlines': {
				// serializer supports newlines; serialize newlines
				if(this._serialize_newlines) {
					return this._serialize_newlines(w_value);
				}
				break;
			}

			// other
			default: {
				throw new Error(`Invalid writable data event directive type: '${s_type}'`);
			}
		}

		// nothing
		return '';
	}

	// if not overriden by subclass, serialize quads in default graph
	_serialize_c4(hc4_quads) {
		let h_prefixes = this._h_prefixes;
		let a_unions = [];
		let s_write = '';

		// each graph in quads hash
		for(let sv1_graph in hc4_quads) {
			// non-default graph; union from dataset
			if('*' !== sv1_graph) a_unions.push(sv1_graph);
			
			// add all quads from graph
			s_write += this._serialize_c3(hc4_quads[sv1_graph]);
		}

		// a union was performed
		if(a_unions.length) {
			// warn about implicit union
			let s_warning = `Destination format does not support quads; an implicit union into the default graph was performed on the quads contained in graphs: ${a_unions.map(sc1 => factory.c1(sc1, h_prefixes).verbose()).join(', ')}`;

			// emit warning, wasn't listened to; force thru warn/stderr channel
			if(!this.emit('warning', s_warning)) {
				console.warn(s_warning);
			}
		}

		return s_write;
	}
}

module.exports = Writable;
