const stream = require('stream');

@> until()
	until(s_event) {
		return new Promise((fk_until, fe_until) => {
			this.once(s_event, fk_until);
		});
	}
@;

class Readable extends stream.Readable {
	constructor(gc_readable={}) {
		super(gc_readable);

		// use iterator
		if(gc_readable.iterator) {
			throw new Error('readable stream iterator shortcut not yet implemented');
		}
	}

	@{until()}
}

class Writable extends stream.Writable {
	@{until()}
}

class Transform extends stream.Transform {
	@{until()}
}

module.exports = {
	...stream,
	Readable,
	Writable,
	Transform,
	quads_to_json(ds_dst) {
		// serializse json
		let ds_json = new stream.Transform({
			writableObjectMode: true,
			readableObjectMode: false,

			transform(g_quad, s_encoding, fk_transform) {
				fk_transform(null, JSON.stringify(g_quad.isolate())+'\n');
			},
		});

		// pipe thru transform first
		ds_json.pipe(ds_dst);

		// re-assign output
		return ds_json;
	},
};
