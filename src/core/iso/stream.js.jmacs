const stream = require('stream');

@> until()
	@//@object-literal
	until(s_event) {
		// special case returns `this`
		if('end' === s_event) {
			return new Promise((fk_until, fe_until) => {
				this.once(s_event, (...a_args) => {
					fk_until(this, ...a_args);
				});
			});
		}
		else {
			return new Promise((fk_until, fe_until) => {
				this.once(s_event, fk_until);
			});
		}
	}
@;
@> bucket()
	bucket(s_encoding='utf8') {
		let g_readable = this._readableState;

		// object mode
		if(g_readable.objectMode) {
			// async operation
			return new Promise((fk_bucket, fe_bucket) => {
				let a_data = [];

				// pipe to writable
				this.pipe(new stream.Writable({
					write(w_event, s_write_encoding, fk_write) {
						a_data.push(w_event);
						fk_write();
					},

					writev(a_chunks, fk_writev) {
						a_data.push(...a_chunks);
						fk_writev();
					},
				}))
					// error
					.on('error', (e_stream) => {
						fe_bucket(e_stream);
					})
					// wait for it to finish
					.on('finish', () => {
						fk_bucket(a_data);
					});
			});
		}
		// utf8-encoded strings
		else if('utf8' === s_encoding || 'utf-8' === s_encoding) {
			// async operation
			return new Promise((fk_bucket, fe_bucket) => {
				let s_data = '';

				// set encoding
				this.setEncoding(s_encoding);

				// pipe to writable
				this.pipe(new stream.Writable({
					decodeStrings: false,

					write(s_chunk, s_write_encoding, fk_write) {
						s_data += s_chunk;
						fk_write();
					},

					writev(a_chunks, fk_writev) {
						s_data += a_chunks.join('');
						fk_writev();
					},
				}))
					// error
					.on('error', (e_stream) => {
						fe_bucket(e_stream);
					})
					// wait for it to finish
					.on('finish', () => {
						fk_bucket(s_data);
					});
			});
		}
		// buffer
		else if('buffer' === s_encoding) {
			// async operation
			return new Promise((fk_bucket, fe_bucket) => {
				let ab_data = Buffer.from([]);

				// pipe to writable
				this.pipe(new stream.Writable({
					decodeStrings: true,

					write(ab_chunk, s_write_encoding, fk_write) {
						ab_data = Buffer.concat([ab_data, ab_chunk], ab_data.length+ab_chunk.length);
						fk_write();
					},
				}))
					// error
					.on('error', (e_stream) => {
						fe_bucket(e_stream);
					})
					// wait for it to finish
					.on('finish', () => {
						fk_bucket(ab_data);
					});
			});
		}
	}
@;

@//@
class Readable extends stream.Readable {
	constructor(gc_readable={}) {
		super(gc_readable);

		// use iterator
		if(gc_readable.iterator) {
			throw new Error('readable stream iterator shortcut not yet implemented');
		}
	}

	@{until()}

	@{bucket()}
}

class Writable extends stream.Writable {
	@{until()}
}

class Duplex extends stream.Duplex {
	@{until()}

	@{bucket()}
}

class Transform extends stream.Transform {
	@{until()}

	@{bucket()}
}

// eslint-disable-next-line no-new-func
const b_is_node = (new Function(/* syntax: js */ `try {return this===global;}catch(e){return false;}`))();

// node.js
if(b_is_node) {
	// patch for node < v10
	if((+(/^v(\d+)/.exec(process.version)[1])) < 10) {
		// override destroy methods
		Transform.prototype.destroy = Duplex.prototype.destroy = function(e_destroy, fke_destroy) {
			this._readableState.destroyed = true;
			this._writableState.destroyed = true;

			let f_emit_close = () => {
				if(!this._writableState.emitClose) return;
				if(!this._readableState.emitClose) return;
				this.emit('close');
			};

			this._destroy(e_destroy || null, (e_destroy_re) => {
				if(!fke_destroy && e_destroy_re) {
					process.nextTick(() => {
						this.emit('error', e_destroy_re);
						f_emit_close();
					});
					this._writableState.errorEmitted = true;
				}
				else  {
					process.nextTick(f_emit_close);
					if(fke_destroy) fke_destroy(e_destroy_re);
				}
			});

			return this;
		};

		// override default _destroy implementations
		Transform.prototype._destroy = Duplex.prototype._destroy = (e_destroy, fke_destroy) => fke_destroy(e_destroy);
	}
}

module.exports = {
	...stream,
	Readable,
	Writable,
	Duplex,
	Transform,

	// create a transform from quad objects into JSON strings for trivial serialization
	quads_to_json(ds_dst) {
		// serializse json
		let ds_json = new Transform({
			writableObjectMode: true,
			readableObjectMode: false,

			transform(g_quad, s_encoding, fk_transform) {
				fk_transform(null, JSON.stringify(g_quad.isolate())+'\n');
			},
		});

		// pipe thru transform first
		ds_json.pipe(ds_dst);

		// re-assign output
		return ds_json;
	},

	// create a simple, single-event readable stream
	source(w_push, s_encoding=null) {
		// encoding not explicit, string given; assume utf8
		if(!s_encoding && 'string' === typeof w_push) s_encoding = 'utf8';

		// readable
		return new Readable({
			objectMode: !s_encoding && 'object' === typeof w_push && !Buffer.isBuffer(w_push),

			read() {
				this.push(w_push, s_encoding);
				this.push(null);
			},
		});
	}
};
