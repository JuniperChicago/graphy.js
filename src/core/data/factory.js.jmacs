@import '../../share/iris.jmacs'

// const DC_URL = require('../isomorphic/locals.js').URL;
const DC_URL = require('url').URL;

const RT_IRI_DIRTY = /[\u0000-\u0020<>"{}|^`\\]/;
const R_IRI_ESCAPES = /([\u0000-\u0020<>"{}|^`\\])/g;

@>> MK_RANGE_PN_HIGH(b_extend=false)
	@// #x00B7
	@- b_extend
		@//@regex
		{-\u00b6
		\u00b8-\u00bf
	@//@
	@:
		@//@regex
		{-\u00bf
	@;

	@//@regex
	\u00d7\u00f7

	@//@
	@- !b_extend
		\u0300-\u306f
	@;

	@//@regex
	\u037e
	\u2000-\u200b

	@- b_extend
		\u200e-\u203e
		\u2041-\u206f
	@:
		\u200e-\u206f
	@;

	@//@regex
	\u2190-\u2bff
	\u2ff0-\u3000
	\ud800-\uf8ff
	\ufdd0-\ufddf
	\ufffe\uffff
@;

@>> MK_RT_AVOID_PNAME_LOCAL()
	@//@regex
	^
	(?:
		\\
		| [						@// * first character *
			\u0000-\/ 			@// 0-:
			;-@					@// A-Z
			[-^					@// _
			`					@// a-z
			@{MK_RANGE_PN_HIGH()}
		] .+
		| (?:
			.+?					@// * acceptable preceeding characters *
			(?:					@// * middle characters *
				\\
				| [
					\u0000-,
					\/;-@
					[-^
					`
					@{MK_RANGE_PN_HIGH(true)}
				]
			)
			.+					@// * at least one final character *
		)
		| (?:
			.+?					@// * acceptable preceeding characters *
			(?:					@// * final character *
				\\
				| [
					\u0000-, 	@// -
					.\/			@// 0-:
					;-@			@// A-Z
					[-^			@// _
					`			@// a-z
					@{MK_RANGE_PN_HIGH(true)}
				]
			)
		)
	)
	$
@;

@>> MK_RT_AVOID_PNAME_NS()
	@//@regex
	^
	(?:
		[
			\u0000-@ 			@// A-Z
			[-`					@// a-z
			@{MK_RANGE_PN_HIGH()}
		] .+
		| (?:
			.+?					@// * acceptable preceeding characters *
			[
				\u0000-, 	@// -.
				\/			@// 0-9
				:-@			@// A-Z
				[-^			@// _
				`			@// a-z
				@{MK_RANGE_PN_HIGH(true)}
			]
			.*
		)
		| .+ \. 				@// * ends with a full stop character *
	)
	$
@;



const RT_AVOID_PNAME_NS = /@{MK_RT_AVOID_PNAME_NS()}/;
const RT_AVOID_PNAME_LOCAL = /@{MK_RT_AVOID_PNAME_LOCAL()}/;

const RT_BOOLEAN_TRUE = /^([Tt](rue)?|TRUE)$/;
const RT_BOOLEAN_FALSE = /^([Ff](alse)?|FALSE)$/;

const F_REPLACE_IRI_ESCAPE = (s_fragment, s_char) => {
	let x_code = s_char.codePointAt(0);
	if(x_code <= 0xffff) {
		return `\\u${x_code.toString(16).padStart(4, '0')}`
	}
	else {
		return `\\U${x_code.toString(16).padStart(8, '0')}`
	}
};

const S_UUID_V4 = 'xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx';
const R_UUID_V4 = /[xy]/g;

const uuid_v4 = () => {
	let dt_now = Date.now();
	if('undefined' !== typeof performance) dt_now += performance.now();
	return S_UUID_V4.replace(R_UUID_V4, (s) => {
		let x_r = (dt_now + (Math.random()*16)) % 16 | 0;
		dt_now = Math.floor(dt_now / 16);
		return ('x' === s? x_r: ((x_r & 0x3) | 0x8)).toString(16);
	});
};

// attempt to turn an iri into a prefixed name
const concise = (p_iri, h_prefixes) => {
	// best prefix id
	let s_best_prefix_id = '';

	// length of longest matching iri
	let nl_best_prefix_iri = -1;

	// each prefix in hash
	for(let s_prefix_id in h_prefixes) {
		let p_prefix_iri = h_prefixes[s_prefix_id];

		// target iri starts with prefix iri and its longer than the current best
		if(p_iri.startsWith(p_prefix_iri) && p_prefix_iri.length > nl_best_prefix_iri) {
			// save prefix id as best
			s_best_prefix_id = s_prefix_id;

			// update best iri length
			nl_best_prefix_iri = p_prefix_iri.length;
		}
	}

	// found a prefix
	if(-1 !== nl_best_prefix_iri) {
		return s_best_prefix_id+':'+p_iri.slice(nl_best_prefix_iri);
	}

	// no prefix found; default to full iri
	return '>'+p_iri;
};

// take a dirty iri and clean it up
const clean_iri = (p_iri_dirty) => {
	// clean iri
	let p_iri = p_iri_dirty;

	// try parsing as URI
	try {
		p_iri = (new DC_URL(p_iri_dirty)).toString();
	}
	// not a URI
	catch(e_parse) {
		// illegal characters
		if(RT_IRI_DIRTY.test(p_iri_dirty)) {
			// escape them
			p_iri = p_iri_dirty.replace(R_IRI_ESCAPES, F_REPLACE_IRI_ESCAPE)
		}
	}

	return p_iri;
};

class GenericTerm {
	valueOf() {
		return this.concise();
	}

	equals(h_other) {
		return this === h_other
			|| (h_other.termType === this.termType && h_other.value === this.value);
	}
} Object.assign(GenericTerm.prototype, {
	isGraphyTerm: true,
});


class NamedNode extends GenericTerm {
	constructor(s_iri) {
		super();
		this.value = s_iri;
	}

	concise(h_prefixes={}) {
		return concise(this.value, h_prefixes);
	}

	terse(h_prefixes={}) {
		let p_iri = clean_iri(this.value);

		// try finding prefix to compress
		let sct_node = concise(p_iri, h_prefixes);

		// none of the prefixes contain this iri; use full iriref
		if('>' === sct_node[0]) return '<'+p_iri+'>';

		let i_colon = sct_node.indexOf(':');

		// avoid using prefixed name; use full iriref
		if(RT_AVOID_PNAME_LOCAL.test(sct_node.slice(i_colon+1))
			|| RT_AVOID_PNAME_NS.test(sct_node.slice(0, i_colon))
		) {
			return '<'+p_iri+'>';
		}

		// use terse prefixed name
		return sct_node;
	}

	verbose() {
		return '<'+clean_iri(this.value)+'>';
	}

	isolate() {
		return {
			termType: 'NamedNode',
			value: this.value,
		};
	}
} Object.assign(NamedNode.prototype, {
	termType: 'NamedNode',
	isNamedNode: true,
});

const KT_RDF_TYPE = new NamedNode('@{P_IRI_RDF}type');
const KT_RDF_LANG_STRING = new NamedNode('@{P_IRI_RDF}langString');

const KT_RDF_FIRST = new NamedNode('@{P_IRI_RDF}first');
const KT_RDF_REST = new NamedNode('@{P_IRI_RDF}rest');
const KT_RDF_NIL = new NamedNode('@{P_IRI_RDF}nil');

const KT_XSD_DATE = new NamedNode('@{P_IRI_XSD}date');
const KT_XSD_DATETIME = new NamedNode('@{P_IRI_XSD}dateTime');
const KT_XSD_STRING = new NamedNode('@{P_IRI_XSD}string');

class Literal extends GenericTerm {
	constructor(s_value, z_datatype_or_lang) {
		super();
		this.value = s_value;
		if(z_datatype_or_lang) {
			if('string' === typeof z_datatype_or_lang) {
				this.language = z_datatype_or_lang.toLowerCase();
				this.datatype = KT_RDF_LANG_STRING;
			}
			else {
				this.datatype = z_datatype_or_lang;
			}
		}
	}

	equals(h_other) {
		return this === h_other
			|| ('Literal' === h_other.termType && h_other.value === this.value
				&& this.datatype.equals(h_other.datatype) && h_other.language === this.language);
	}

	verbose() {
		return JSON.stringify(this.value)
			+ (this.language
				? '@'+this.language
				: (!this.datatype.equals(KT_XSD_STRING)
					? '^^'+this.datatype.verbose()
					: ''));
	}

	concise(h_prefixes) {
		if(this.language) {
			return '@'+this.language+'"'+this.value;
		}
		else if(this.hasOwnProperty('datatype')) {
			return '^'+concise(this.datatype.value, h_prefixes)+'"'+this.value;
		}
		else {
			return '"'+this.value;
		}
	}

	terse(h_prefixes={}) {
		// turn into terse
		let st_datatype = this.datatype.terse(h_prefixes);

		// stringify literal
		return JSON.stringify(this.value)
			+ (this.language
				? '@'+this.language
				: (!this.datatype.equals(KT_XSD_STRING)
					? '^^'+st_datatype
					: ''));
	}

	isolate() {
		return {
			termType: 'Literal',
			value: this.value,
			language: this.language,
			datatype: Object.assign({}, this.datatype),
		};
	}
} Object.assign(Literal.prototype, {
	datatype: KT_XSD_STRING,
	language: '',
	termType: 'Literal',
	isLiteral: true,
});


@> literal(s_type, g_config)
	@.let b_boolean = 'boolean' === s_type;
	@.let s_arg = (b_boolean? 'b': 'x')+'_value';
	@.let s_type_caps = s_type.toUpperCase();
	@.let s_type_proper = s_type_caps.slice(0, 1)+s_type.slice(1);
	const KT_XSD_@{s_type_caps} = new NamedNode('@{P_IRI_XSD}@{s_type}');
	class Literal_@{s_type_proper} extends Literal {
		@//@class
		constructor(@{s_arg}) {
			super(@{s_arg}+'');
			@- b_boolean
				this.boolean = @{s_arg};
			@:
				this.number = @{s_arg};
			@;
		}

		concise(h_prefixes={}) {
			return '^'+KT_XSD_@{s_type_caps}.concise(h_prefixes)+'"'+this.value;
		}

		terse() {
			@{g_config.terse}
		}
	} Object.assign(Literal_@{s_type_proper}.prototype, {
		datatype: KT_XSD_@{s_type_caps},
		@- b_boolean
			isBoolean: true,
		@:
			isNumeric: true,
			is@{s_type_proper}: true,
		@;
	});
@;


@.{
	let h_literals = {
		integer: {
			construct: s_arg => /* syntax: js */ `
				let s_type = typeof ${s_arg};

				// a number was given
				if('number' === s_type) {
					// not a finite number
					if(!Number.isFinite(${s_arg})) {
						// NaN
						if(Number.isNaN(${s_arg})) {
							throw new Error('XSD integer cannot encode NaN. Try using double');
						}

						throw new Error('XSD integer cannot encode +/-infinity. Try using double');
					}
					// not an integer
					else if(!Number.isInteger(${s_arg})) {
						throw new Error(\`Number is not an integer: \${${s_arg}}\`);
					}

					return new Literal_Integer(${s_arg});
				}
				// string
				else if('string' === s_type) {
					// empty string
					if('' === ${s_arg}) {
						throw new Error('Refusing to serialize empty string as xsd:integer');
					}

					// parse to number
					let x_value = +${s_arg};

					// failed to parse or not an integer
					if(Number.isNaN(x_value) || !Number.isInteger(x_value)) {
						throw new Error(\`Invalid integer string: \${${s_arg}}\`);
					}

					return new Literal_Integer(x_value);
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as xsd:integer');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as xsd:integer');
					}

					// invalid
					throw new Error('XSD integer expects a number type or integer string');
				}
			`,
			terse: /* syntax: js */ `
				return this.value.includes('e')
					? \`"\${this.value}"^^<${P_IRI_XSD}integer>\`
					: this.value;
			`,
		},

		double: {
			construct: s_arg => /* syntax: js */ `
				let s_type = typeof ${s_arg};

				// a number was given
				if('number' === s_type) {
					// not a finite number
					if(!Number.isFinite(${s_arg})) {
						// NaN
						if(Number.isNaN(${s_arg})) {
							return new Literal_NaN();
						}

						return ${s_arg} > 0
							? new Literal_PositiveInfinity()
							: new Literal_NegativeInfinity();
					}

					return new Literal_Double(${s_arg});
				}
				// string
				else if('string' === s_type) {
					// empty string
					if('' === ${s_arg}) {
						throw new Error('Refusing to serialize empty string as xsd:double');
					}

					// parse to number
					let x_value = +${s_arg};

					// failed to parse
					if(Number.isNaN(x_value)) {
						throw new Error(\`Invalid decimal string: \${${s_arg}}\`);
					}

					return new Literal_Double(x_value);
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as xsd:double');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as xsd:double');
					}

					// invalid
					throw new Error('XSD double expects a number type or double string');
				}
			`,
			terse: /* syntax: js */ `
				return this.number.toExponential();
			`,
		},

		decimal: {
			construct: s_arg => /* syntax: js */ `
				let s_type = typeof ${s_arg};

				// a number was given
				if('number' === s_type) {
					// not a finite number
					if(!Number.isFinite(${s_arg})) {
						// NaN
						if(Number.isNaN(${s_arg})) {
							throw new Error('XSD decimal cannot encode NaN. Try using double');
						}

						throw new Error('XSD decimal cannot encode +/-infinity. Try using double');
					}

					return new Literal_Decimal(${s_arg});
				}
				// string
				else if('string' === s_type) {
					// empty string
					if('' === ${s_arg}) {
						throw new Error('Refusing to serialize empty string as xsd:decimal');
					}

					// parse to number
					let x_value = +${s_arg};

					// failed to parse
					if(Number.isNaN(x_value)) {
						throw new Error(\`Invalid decimal string: \${${s_arg}}\`);
					}

					return new Literal_Decimal(x_value);
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as xsd:decimal');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as xsd:decimal');
					}

					// invalid
					throw new Error('XSD decimal expects a number type or decimal string');
				}
			`,
			terse: /* syntax: js */ `
				return this.value.includes('e')
					? \`"\${this.value}"^^<${P_IRI_XSD}decimal>\`
					: this.value+(Number.isInteger(this.number)? '.0': '');
			`,
		},

		boolean: {
			construct: s_arg => /* syntax: js */ `
				let s_type = typeof ${s_arg};

				// boolean
				if('boolean' === s_type) {
					return new Literal_Boolean(${s_arg});
				}
				// number
				else if('number' === s_type) {
					// 1
					if(1 === ${s_arg}) {
						return new Literal_Boolean(true);
					}
					// 0
					else if(0 === ${s_arg}) {
						return new Literal_Boolean(false);
					}

					// invalid
					throw new Error(\`Boolean value '${s_arg}' must be either a '1' or '0' if using numbers\`);
				}
				// string
				else if('string' === s_type) {
					// truthy value
					if(RT_BOOLEAN_TRUE.test(${s_arg})) {
						return new Literal_Boolean(true);
					}
					// falsy value
					else if(RT_BOOLEAN_FALSE.test(${s_arg})) {
						return new Literal_Boolean(false);
					}

					// empty string
					if('' === ${s_arg}) {
						throw new Error('Refusing to serialize empty string as xsd:boolean');
					}

					// failed to parse
					throw new Error(\`Invalid boolean string: \${${s_arg}}\`);
				}
				// undefined
				else if('undefined' === s_type) {
					throw new Error('Refusing to serialize undefined value as xsd:boolean');
				}
				// other
				else {
					// null
					if(null === ${s_arg}) {
						throw new Error('Refusing to serialize null value as xsd:boolean');
					}

					// invalid
					throw new Error('XSD boolean expects a boolean type or boolean string');
				}
			`,
			terse: /* syntax: js */ `
				return this.value+'';
			`,
		},
	};
}

@*{
	for(let s_type in h_literals) {
		yield literal(s_type, h_literals[s_type])+'\n';
	}
}


class Literal_PositiveInfinity extends Literal_Double {
	constructor() {
		super(Infinity);
		this.value = 'INF';
	}

	terse() {
		return 'INF';
	}
} Object.assign(Literal_PositiveInfinity.prototype, {
	isInfinite: true,
});

class Literal_NegativeInfinity extends Literal_Double {
	constructor() {
		super(-Infinity);
		this.value = '-INF';
	}

	terse() {
		return '-INF';
	}
} Object.assign(Literal_NegativeInfinity.prototype, {
	isInfinite: true,
});

class Literal_NaN extends Literal_Double {
	constructor() {
		super(NaN);
		this.value = 'NaN';
	}

	terse() {
		return 'NaN';
	}
} Object.assign(Literal_NaN.prototype, {
	isNaN: true,
});


function BlankNode(s_value, b_anonymous=false) {
	this.value = s_value;
	this.isAnonymous = b_anonymous;
} BlankNode.prototype = Object.assign(
	Object.create(GenericTerm.prototype), {
		termType: 'BlankNode',
		isBlankNode: true,
		concise() {
			return '_'+this.value;
		},
		terse() {
			return '_:'+this.value;
		},
		verbose() {
			return '_:'+this.value;
		},
		isolate() {
			return {
				termType: 'BlankNode',
				value: this.value,
			};
		},
	});

function DefaultGraph() {}
DefaultGraph.prototype = Object.assign(
	Object.create(GenericTerm.prototype), {
		value: '',
		termType: 'DefaultGraph',
		isDefaultGraph: true,
		concise() {
			return '*';
		},
		terse() {
			return '';
		},
		verbose() {
			return '';
		},
		isolate() {
			return {
				termType: 'DefaultGraph',
				value: '',
			};
		},
	});

function NoGraph() {}
NoGraph.prototype = Object.assign(
	Object.create(GenericTerm.prototype), {
		value: '',
		termType: 'NoGraph',
		concise() {
			return '';
		},
		terse() {
			return '';
		},
		verbose() {
			return '';
		},
		isolate() {
			return {
				termType: 'NoGraph',
				value: '',
			};
		},
	});

const KT_DEFAULT_GRAPH = new DefaultGraph();
function Quad(h_subject, h_predicate, h_object, h_graph=KT_DEFAULT_GRAPH) {
	this.subject = h_subject;
	this.predicate = h_predicate;
	this.object = h_object;
	this.graph = h_graph;
} Object.assign(Quad.prototype, {
	isGraphyQuad: true,
	equals(y_other) {
		return this === y_other
			|| (this.object.equals(y_other.object)
				&& this.subject.equals(y_other.subject)
				&& this.predicate.equals(y_other.predicate)
				&& this.graph.equals(y_other.graph));
	},
	valueOf() {
		return this.verbose();
	},
	concise() {
		return [
			this.graph.concise(),
			this.subject.concise(),
			this.predicate.concise(),
			this.object.concise(),
		];
	},
	terse(h_prefixes) {
		let b_graph = !this.graph.isDefaultGraph;
		return (b_graph? '': this.graph.terse(h_prefixes)+' { ')
			+this.subject.terse(h_prefixes)
			+' '+this.predicate.terse(h_prefixes)
			+' '+this.object.terse(h_prefixes)+' .'
			+(b_graph? ' }': '');
	},
	verbose() {
		return this.subject.verbose()
			+' '+this.predicate.verbose()
			+' '+this.object.verbose()
			+' '+(this.graph.isDefaultGraph? '': this.graph.verbose()+' ')+'.';
	},
	isolate() {
		return {
			subject: this.subject.isolate(),
			predicate: this.predicate.isolate(),
			object: this.object.isolate(),
			graph: this.graph.isolate(),
		};
	},
});

const H_NO_GRAPH = new NoGraph();
function Triple(h_subject, h_predicate, h_object) {
	this.subject = h_subject;
	this.predicate = h_predicate;
	this.object = h_object;
	this.graph = H_NO_GRAPH;
} Triple.prototype = Object.assign(
	Object.create(Quad.prototype, {
		// equals(y_other) {
		// 	return this === y_other
		// 		|| (this.object.equals(y_other.object)
		// 			&& this.subject.equals(y_other.subject)
		// 			&& this.predicate.equals(y_other.predicate));
		// },
	}));

let g_raw = {
	namedNode(p_iri) {
		return new NamedNode(p_iri);
	},
	blankNode(s_label, b_anonymous) {
		return new BlankNode(s_label, b_anonymous);
	},
	literal(s_value, w_datatype_or_lang) {
		return new Literal(s_value, w_datatype_or_lang);
	},
	defaultGraph() {
		return new DefaultGraph();
	},
	quad(kt_subject, kt_predicate, kt_object, kt_graph) {
		return new Quad(kt_subject, kt_predicate, kt_object, kt_graph || KT_DEFAULT_GRAPH);
	},
	@*{
		for(let s_type in h_literals) {
			yield /* syntax: js */ `
				${s_type}(w) {
					return new Literal_${s_type[0].toUpperCase()+s_type.slice(1)}(w);
				},
			`;
		}
	}
};


const normalize_ct_hash = (hct_graph, h_prefixes) => {
	let hvt_graph = {};
	for(let sct_key of hct_graph) {
		hvt_graph[factory.ct(sct_key, h_prefixes).verbose()] = normalize_ct_value(hct_graph[sct_key], h_prefixes);
	}
	return hvt_graph;
};

const normalize_ct_value = (z_input, h_prefixes, b_leaf=false) => {
	if('string' === typeof z_input) {
		let sct_input = z_input;
		return [factory.ct(sct_input, h_prefixes).verbose()];
	}
	else if(Array.isArray(z_input)) {
		// an array within an array; a list!
		if(b_leaf) {
			throw new Error('list expansion not yet implemented');
		}
		else {
			let a_objects = z_input;
			return a_objects.map(z_object => normalize_ct_value(z_object, h_prefixes, true)[0]);
		}
	}
	// TODO: coercibles
	else {
		// blank node
		let hct_input = z_input;
		return [normalize_ct_hash(hct_input, h_prefixes)];
	}
};

const factory = module.exports = {
	concise,

	raw: g_raw,
	unfiltered: g_raw,

	number(x) {
		// not finite or not a number
		if('number' === typeof x && (!Number.isFinite(x) || Number.isNaN(x))) {
			return factory.double(x);
		}
		// integer
		else if(Number.isInteger(x)) {
			return factory.integer(x);
		}
		// non-integer
		else {
			return factory.decimal(x);
		}
	},

	date(dt) {
		return factory.literal(dt.toISOString().replace(/T.+$/, 'Z'), KT_XSD_DATE);
	},

	dateTime(dt) {
		return factory.literal(dt.toISOString(), KT_XSD_DATETIME);
	},

	namedNode(p_iri) {
		return new NamedNode(p_iri);
	},

	blankNode(z_label) {
		// no label given, generate a UUID
		if(!z_label) {
			// eslint-disable-next-line no-undef
			return new BlankNode(uuid_v4(), true);
		}
		// label given
		else if('string' === typeof z_label) {
			return new BlankNode(z_label);
		}
		// parser or graph object given
		else if('object' === typeof z_label) {
			return new BlankNode(z_label.next_label(), true);
		}

		throw new TypeError('unexpected type for `label` parameter');
	},

	literal(s_value, w_datatype_or_lang) {
		return new Literal(s_value, w_datatype_or_lang);
	},

	@*{
		for(let s_type in h_literals) {
			let g_config = h_literals[s_type];
			yield /* syntax: js */ `${s_type}(w_value) {
				${g_config.construct('w_value')}
			},\n`;
		}
	}

	defaultGraph() {
		return new DefaultGraph();
	},


	triple(h_subject, h_predicate, h_object) {
		return new Triple(h_subject, h_predicate, h_object);
	},

	quad(h_subject, h_predicate, h_object, h_graph) {
		return new Quad(h_subject, h_predicate, h_object, h_graph || KT_DEFAULT_GRAPH);
	},

	term(z_term, w_prefixes) {
		// concise term
		if('string' === typeof z_term) {
			return factory.c1(z_term, w_prefixes);
		}
		// rdfjs term
		else {
			return factory.from.rdfjs_term(z_term);
		}
	},

	/**
	 * construct a term object from a concise term string
	 * @param  {c1_string} term - a representation of the term object to create
	 * @param  {Object} prefixes - mappings for prefixes
	 * @return {Term} - an RDFJS-compatible term object
	 */
	c1(sct_term, h_prefixes={}) {
		// deduce term type
		switch(sct_term[0]) {
			// datatyped literal
			case '^': {
				// find literal's contents delimiter
				let i_contents = sct_term.indexOf('"');

				// no delimiter
				if(-1 === i_contents) {
					throw new Error(`invalid concise-term string, no content literal delimiter found: ${sct_term}`);
				}

				// extract datatype
				let s_datatype = sct_term.slice(1, i_contents);

				// make term
				return factory.literal(sct_term.slice(i_contents+1), factory.c1_node_explicit(s_datatype, h_prefixes));
			}

			// languaged literal
			case '@': {
				// find literal's contents delimiter
				let i_contents = sct_term.indexOf('"');

				// no delimiter
				if(-1 === i_contents) {
					throw new Error(`invalid concise-term string, no content literal delimiter found: ${sct_term}`);
				}

				// extract language
				let s_language = sct_term.slice(1, i_contents);

				// make term
				return factory.literal(sct_term.slice(i_contents+1), s_language);
			}

			// simple literal
			case '"': {
				// make term
				return factory.literal(sct_term.slice(1));
			}

			// prefixed name
			default: return factory.c1_node(sct_term, h_prefixes);
		}
	},

	// construct a term object from a concise term string for nodes
	c1_node(sct_node, h_prefixes={}) {
		// rdf:type shortcut
		if('a' === sct_node) return KT_RDF_TYPE;

		// default graph
		if('*' === sct_node) return factory.defaultGraph();

		// blank node
		if('_' === sct_node[0]) {
			if(':' !== sct_node[1]) throw new Error(`invliad concise-term string, prefixes are not allowed to start with an underscore: ${sct_node}`);

			return factory.blankNode(sct_node.slice(2));
		}

		// other
		return factory.c1_node_explicit(sct_node, h_prefixes);
	},

	// construct a term object from a concise term string for nodes (no shortcuts)
	c1_node_explicit(sct_node, h_prefixes={}) {
		// deduce term type
		switch(sct_node[0]) {
			// iri
			case '>': return factory.namedNode(sct_node.slice(1));

			// invalid concise-term string
			case '<': throw new Error(`Whoops! It looks like this concise-term string starts with a '<' character. Remember to use '>' if you are trying to make an absolute IRI reference.\nInvalid concise-term string '${sct_node}'`);
			case '`': throw new Error(`The backtick character '\`' is reserved for concise-struct key directives and should not be used in the object position.\nInvalid concise-term string '${sct_node}'`);

			// prefixed name
			default: return this.c1_prefixed_node(sct_node, h_prefixes);
		}
	},

	// construct a term object from a concise term string for prefixed nodes
	c1_prefixed_node(sct_node, h_prefixes={}) {
		// find prefix delimiter
		let i_colon = sct_node.indexOf(':');

		// no delimter; invalid concise-term string for node
		if(-1 === i_colon) throw new Error(`A relative or prefixed node must include a ':' character. \nInvalid concise-term string for node: '${sct_node}'`);

		// prefix id
		let s_prefix_id = sct_node.slice(0, i_colon);

		// suffix
		let s_suffix = sct_node.slice(i_colon+1);

		// find prefix in hash
		if(s_prefix_id in h_prefixes) {
			return factory.namedNode(h_prefixes[s_prefix_id]+s_suffix);
		}
		// prefix not exists
		else {
			throw new Error(`Prefix not defined: '${s_prefix_id}'`);
		}
	},

	* quads(hct_quads, h_prefixes={}) {
		for(let sct_graph in hct_quads) {
			yield* factory.triples(hct_quads[sct_graph], h_prefixes, sct_graph);
		}
	},

	* triples(hct_triples, h_prefixes={}, sct_graph='*') {
		let k_graph = factory.c1(sct_graph, h_prefixes);
		for(let sct_subject in hct_triples) {
			let k_subject = factory.c1(sct_subject, h_prefixes);
			let hct_pairs = hct_triples[sct_subject];

			yield* factory.pairs(k_graph, k_subject, hct_pairs, h_prefixes);
		}
	},

	* pairs(k_graph, k_subject, hct_pairs, h_prefixes={}) {
		for(let sct_predicate in hct_pairs) {
			let k_predicate = factory.c1(sct_predicate, h_prefixes);
			let z_objects = hct_pairs[sct_predicate];

			yield* factory.objects(k_graph, k_subject, k_predicate, z_objects, h_prefixes);
		}
	},

	* collection(k_graph, k_subject, a_objects, h_prefixes={}) {
		// first item
		yield* factory.objects(k_graph, k_subject, KT_RDF_FIRST, a_objects[0], h_prefixes);

		// rest of items
		let a_rest = a_objects.slice(1);

		// no more
		if(!a_rest.length) {
			yield new Quad(k_subject, KT_RDF_REST, KT_RDF_NIL, k_graph);
		}
		// more remain
		else {
			// anonymous blank node
			let k_hop = factory.blankNode();

			// incoming triple
			yield new Quad(k_subject, KT_RDF_REST, k_hop, k_graph);

			// outgoing triples
			yield* factory.collection(k_graph, k_hop, a_rest, h_prefixes);
		}
	},

	* objects(k_graph, k_subject, k_predicate, z_objects, h_prefixes, b_nested=false) {
		// value type
		let s_type = typeof z_objects;
		switch(s_type) {
			// c1-string
			case 'string': {
				yield new Quad(k_subject, k_predicate, factory.c1(z_objects, h_prefixes), k_graph);
				break;
			}

			// number
			case 'number': {
				yield new Quad(k_subject, k_predicate, factory.number(z_objects), k_graph);
				break;
			}

			// object
			case 'object': {
				// array
				if(Array.isArray(z_objects)) {
					// RDF collection
					if(b_nested) {
						// anonymous blank node
						let k_hop = factory.blankNode();

						// incoming triple
						yield new Quad(k_subject, k_predicate, k_hop, k_graph);

						// outgoing triple
						yield* factory.collection(k_graph, k_hop, z_objects, h_prefixes);
					}
					// list of objects
					else {
						for(let z_item of z_objects) {
							yield* factory.objects(k_graph, k_subject, k_predicate, z_item, h_prefixes, true);
						}
					}
				}
				// simple object
				else {
					// anonymous blank node
					let k_hop = factory.blankNode();

					// incoming triple
					yield new Quad(k_subject, k_predicate, k_hop, k_graph);

					// outgoing triples
					yield* factory.pairs(k_graph, k_hop, z_objects, h_prefixes);
				}
				break;
			}

			// other
			default: {
				throw new Error(`invalid object type: ${typeof z_objects}`);
			}
		}
	},

	from: {
		term(z_term) {
			if(z_term.isGraphyTerm) return z_term;

			return factory.from.rdfjs_term(z_term);
		},

		quad(g_quad) {
			let g_from = factory.from;
			return new Quad(
				g_from.rdfjs_term(g_quad.subject),
				g_from.rdfjs_term(g_quad.predicate),
				g_from.rdfjs_term(g_quad.object),
				g_from.rdfjs_term(g_quad.graph),
			);
		},

		rdfjs_term(g_term) {
			switch(g_term.termType) {
				case 'NamedNode': return new NamedNode(g_term.value);
				case 'BlankNode': return new BlankNode(g_term.value);
				case 'Literal': return new Literal(g_term.value, g_term.language
					? g_term.language
					: (g_term.datatype
						? new NamedNode(g_term.datatype.value)
						: null));
				case 'DefaultGraph': return new DefaultGraph();
				default: {
					throw new TypeError(`invalid termType: ${g_term.termType}`);
				}
			}
		},

		sparql_result(g_term) {
			switch(g_term.type) {
				case 'uri': {
					return new NamedNode(g_term.value);
				}

				case 'literal':
				case 'typed-literal': {
					if('xml:lang' in g_term) {
						return new Literal(g_term.value, g_term['xml:lang']);
					}
					else if('datatype' in g_term) {
						return new Literal(g_term.value, new NamedNode(g_term.datatype));
					}
					else {
						return new Literal(g_term.value);
					}
				}

				case 'bnode': {
					return new BlankNode(g_term.value);
				}

				default: {
					throw new Error(`unexpected SPARQL Result JSON Format Term type: ${g_term.type}`);
				}
			}
		},
	},


	/**
	 * @param  {Object} config - 
	 * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
	 * 	in order to write a comment to the document (only works with supporting serializers)
	 */
	comment(g_config={}) {
		return `\`[${uuid_v4()}]${JSON.stringify({...g_config, type:'comment'})}`;
	},

	/**
	 * @param  {integer} [line_count=1] - number of newlines to insert
	 * @return {string} a `concise-term string` directive to be used as a key in `concise-term structs`
	 * 	in order to write the given number of newlines to the document (only works with supporting serializers)
	 */
	newlines() {
		// if(!Number.isInteger(n_line_count)) throw new TypeError('graphy/core.data.factory#newlines() expects `line_count` argument to be an integer');
		return `\`[${uuid_v4()}]{"type":"newlines"}`;
	},

};

Object.assign(factory, {
	c3: factory.triples,
	c4: factory.quads,
});
